{"version":3,"file":"webworkerAll-HcPN6wip.js","sources":["../../node_modules/pixi.js/lib/app/ResizePlugin.mjs","../../node_modules/pixi.js/lib/app/TickerPlugin.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs","../../node_modules/pixi.js/lib/filters/FilterPipe.mjs","../../node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","../../node_modules/pixi.js/lib/filters/FilterSystem.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","../../node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","../../node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs","../../node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","../../node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","../../node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","../../node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","../../node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs","../../node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs","../../node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs","../../node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","../../node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","../../node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","../../node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","../../node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","../../node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","../../node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs","../../node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs","../../node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","../../node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","../../node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","../../node_modules/pixi.js/lib/utils/browser/isSafari.mjs","../../node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","../../node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","../../node_modules/pixi.js/lib/app/init.mjs","../../node_modules/pixi.js/lib/scene/graphics/init.mjs","../../node_modules/pixi.js/lib/scene/mesh/init.mjs","../../node_modules/pixi.js/lib/scene/particle-container/init.mjs","../../node_modules/pixi.js/lib/scene/text/init.mjs","../../node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","../../node_modules/pixi.js/lib/scene/text-html/init.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","../../node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","../../node_modules/pixi.js/lib/filters/init.mjs"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './passthrough.frag.mjs';\nimport source from './passthrough.wgsl.mjs';\n\n\"use strict\";\nclass PassthroughFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: { source, entryPoint: \"mainVertex\" },\n      fragment: { source, entryPoint: \"mainFragment\" },\n      name: \"passthrough-filter\"\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"passthrough-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram\n    });\n  }\n}\n\nexport { PassthroughFilter };\n//# sourceMappingURL=PassthroughFilter.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import '../../../maths/index.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempProjectionMatrix = new Matrix();\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const actualMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    if (renderGroup?.isCachedAsTexture) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);\n    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);\n    } else {\n      bounds.matrix = renderable.worldTransform;\n    }\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = actualMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { PassthroughFilter } from './defaults/passthrough/PassthroughFilter.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n    /** The first enabled filter index in the current filter list. */\n    this.firstEnabledIndex = -1;\n    /** The last enabled filter index in the current filter list. */\n    this.lastEnabledIndex = -1;\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();\n    this._setupBindGroupsAndRender(filterToApply, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.orig.width,\n      1 / sprite.texture.orig.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this._passthroughFilter?.destroy(true);\n    this._passthroughFilter = null;\n  }\n  _getPassthroughFilter() {\n    this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());\n    return this._passthroughFilter;\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    const firstEnabled = filterData.firstEnabledIndex;\n    const lastEnabled = filterData.lastEnabledIndex;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (firstEnabled === lastEnabled) {\n      filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      for (let i = firstEnabled; i < lastEnabled; i++) {\n        const filter = filters[i];\n        if (!filter.enabled)\n          continue;\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    let firstEnabledIndex = -1;\n    let lastEnabledIndex = -1;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (!filter.enabled)\n        continue;\n      if (firstEnabledIndex === -1)\n        firstEnabledIndex = i;\n      lastEnabledIndex = i;\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = true;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n    filterData.firstEnabledIndex = firstEnabledIndex;\n    filterData.lastEnabledIndex = lastEnabledIndex;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 0) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * Creates a new Graphics object.\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.didViewUpdate = true;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The underlying graphics context used for drawing operations.\n   * Controls how shapes and paths are rendered.\n   * @example\n   * ```ts\n   * // Create a shared context\n   * const sharedContext = new GraphicsContext();\n   *\n   * // Create graphics objects sharing the same context\n   * const graphics1 = new Graphics();\n   * const graphics2 = new Graphics();\n   *\n   * // Assign shared context\n   * graphics1.context = sharedContext;\n   * graphics2.context = sharedContext;\n   *\n   * // Both graphics will show the same shapes\n   * sharedContext\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @see {@link GraphicsContext} For drawing operations\n   * @see {@link GraphicsOptions} For context configuration\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphics object.\n   * Returns the boundaries after all graphical operations but before any transforms.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Get bounds information\n   * const bounds = graphics.bounds;\n   * console.log(bounds.width);  // 100\n   * console.log(bounds.height); // 100\n   * ```\n   * @readonly\n   * @see {@link Bounds} For bounds operations\n   * @see {@link Container#getBounds} For transformed bounds\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * Returns true if the point lies within the Graphics object's rendered area.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Check point intersection\n   * if (graphics.containsPoint({ x: 50, y: 50 })) {\n   *     console.log('Point is inside rectangle!');\n   * }\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is inside the Graphics object\n   * @see {@link Graphics#bounds} For bounding box checks\n   * @see {@link PointData} For point data structure\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @example\n   * ```ts\n   * // Destroy the graphics and its context\n   * graphics.destroy();\n   * graphics.destroy(true);\n   * graphics.destroy({ context: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context.\n   * The fill style can be a color, gradient, pattern, or a complex style object.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics\n   *     .setFillStyle({ color: 0xff0000 }) // Red fill\n   *     .rect(0, 0, 100, 100)\n   *     .fill();\n   *\n   * // Gradient fill\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setFillStyle(gradient)\n   *     .circle(100, 100, 50)\n   *     .fill();\n   *\n   * // Pattern fill\n   * const pattern = new FillPattern(texture);\n   * graphics\n   *     .setFillStyle({\n   *         fill: pattern,\n   *         alpha: 0.5\n   *     })\n   *     .rect(0, 0, 200, 200)\n   *     .fill();\n   * ```\n   * @param {FillInput} args - The fill style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link FillStyle} For fill style options\n   * @see {@link FillGradient} For gradient fills\n   * @see {@link FillPattern} For pattern fills\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context.\n   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color stroke\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 2,\n   *         color: 0x000000\n   *     })\n   *     .rect(0, 0, 100, 100)\n   *     .stroke();\n   *\n   * // Complex stroke style\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 4,\n   *         color: 0xff0000,\n   *         alpha: 0.5,\n   *         join: 'round',\n   *         cap: 'round',\n   *         alignment: 0.5\n   *     })\n   *     .circle(100, 100, 50)\n   *     .stroke();\n   *\n   * // Gradient stroke\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 10,\n   *         fill: gradient\n   *     })\n   *     .poly([0,0, 100,50, 0,100])\n   *     .stroke();\n   * ```\n   * @param {StrokeInput} args - The stroke style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link FillPattern} For pattern strokes\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style or specified style.\n   * Outlines the shape using the stroke settings.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Stroke with direct color\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .stroke({\n   *         width: 2,\n   *         color: 0xff0000\n   *     }); // 2px red stroke\n   *\n   * // Fill with texture\n   * graphics\n   *    .rect(0, 0, 100, 100)\n   *    .stroke(myTexture); // Fill with texture\n   *\n   * // Stroke with gradient\n   * const gradient = new FillGradient({\n   *     end: { x: 1, y: 0 },\n   *     colorStops: [\n   *         { offset: 0, color: 0xff0000 },\n   *         { offset: 0.5, color: 0x00ff00 },\n   *         { offset: 1, color: 0x0000ff },\n   *     ],\n   * });\n   *\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .stroke({\n   *         width: 4,\n   *         fill: gradient,\n   *         alignment: 0.5,\n   *         join: 'round'\n   *     });\n   * ```\n   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n   * - A stroke style object with width, color, etc.\n   * - A gradient\n   * - A pattern\n   * If omitted, uses current stroke style.\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link setStrokeStyle} For setting default stroke style\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   * graphics\n   *     .circle(150, 150, 50)\n   *     .fill({ color: 0x00ff00 })\n   *     .beginPath() // Starts a new path\n   *     .circle(250, 150, 50)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for chaining\n   * @see {@link Graphics#moveTo} For starting a new subpath\n   * @see {@link Graphics#closePath} For closing the current path\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path.\n   *\n   * If a hole is not completely in a shape, it will fail to cut correctly.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw outer circle\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *     .circle(100, 100, 25) // Inner circle\n   *     .cut() // Cuts out the inner circle from the outer circle\n   * ```\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start point.\n   *\n   * This is useful for completing shapes and ensuring they are properly closed for fills.\n   * @example\n   * ```ts\n   * // Create a triangle with closed path\n   * const graphics = new Graphics();\n   * graphics\n   *     .moveTo(50, 50)\n   *     .lineTo(100, 100)\n   *     .lineTo(0, 100)\n   *     .closePath()\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path\n   * @see {@link Graphics#fill} For filling closed paths\n   * @see {@link Graphics#stroke} For stroking paths\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /**\n   * Saves the current graphics state onto a stack. The state includes:\n   * - Current transformation matrix\n   * - Current fill style\n   * - Current stroke style\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Save state before complex operations\n   * graphics.save();\n   *\n   * // Create transformed and styled shape\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4)\n   *     .setFillStyle({\n   *         color: 0xff0000,\n   *         alpha: 0.5\n   *     })\n   *     .rect(-25, -25, 50, 50)\n   *     .fill();\n   *\n   * // Restore to original state\n   * graphics.restore();\n   *\n   * // Continue drawing with previous state\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .fill();\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#restore} For restoring the saved state\n   * @see {@link Graphics#setTransform} For setting transformations\n   */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * This matrix represents all accumulated transformations including translate, scale, and rotate.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply some transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4);\n   *\n   * // Get the current transform matrix\n   * const matrix = graphics.getTransform();\n   * console.log(matrix.tx, matrix.ty); // 100, 100\n   *\n   * // Use the matrix for other operations\n   * graphics\n   *     .setTransform(matrix)\n   *     .circle(0, 0, 50)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @returns The current transformation matrix.\n   * @see {@link Graphics#setTransform} For setting the transform matrix\n   * @see {@link Matrix} For matrix operations\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .scaleTransform(2, 2)\n   *     .circle(0, 0, 25)\n   *     .fill({ color: 0xff0000 });\n   * // Reset transform to default state\n   * graphics\n   *     .resetTransform()\n   *     .circle(50, 50, 25) // Will draw at actual coordinates\n   *     .fill({ color: 0x00ff00 });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#getTransform} For getting the current transform\n   * @see {@link Graphics#setTransform} For setting a specific transform\n   * @see {@link Graphics#save} For saving the current transform state\n   * @see {@link Graphics#restore} For restoring a previous transform state\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it.\n   * This includes clearing the current path, fill style, stroke style, and transformations.\n   *\n   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n   * > Instead, they are intended to be used for static or semi-static graphics that\n   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw some shapes\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 })\n   *     .rect(200, 100, 100, 50)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Clear all graphics\n   * graphics.clear();\n   *\n   * // Start fresh with new shapes\n   * graphics\n   *     .circle(150, 150, 30)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n   * @see {@link Graphics#save} For saving the current state\n   * @see {@link Graphics#restore} For restoring a previous state\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * Gets or sets the current fill style for the graphics context. The fill style determines\n   * how shapes are filled when using the fill() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics.fillStyle = {\n   *     color: 0xff0000,  // Red\n   *     alpha: 1\n   * };\n   *\n   * // Using gradients\n   * const gradient = new FillGradient({\n   *     end: { x: 0, y: 1 }, // Vertical gradient\n   *     stops: [\n   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n   *     ]\n   * });\n   *\n   * graphics.fillStyle = {\n   *     fill: gradient,\n   *     alpha: 0.8\n   * };\n   *\n   * // Using patterns\n   * graphics.fillStyle = {\n   *     texture: myTexture,\n   *     alpha: 1,\n   *     matrix: new Matrix()\n   *         .scale(0.5, 0.5)\n   *         .rotate(Math.PI / 4)\n   * };\n   * ```\n   * @type {ConvertedFillStyle}\n   * @see {@link FillStyle} For all available fill style options\n   * @see {@link FillGradient} For creating gradient fills\n   * @see {@link Graphics#fill} For applying the fill to paths\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * Gets or sets the current stroke style for the graphics context. The stroke style determines\n   * how paths are outlined when using the stroke() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic stroke style\n   * graphics.strokeStyle = {\n   *     width: 2,\n   *     color: 0xff0000,\n   *     alpha: 1\n   * };\n   *\n   * // Using with gradients\n   * const gradient = new FillGradient({\n   *   end: { x: 0, y: 1 },\n   *   stops: [\n   *       { offset: 0, color: 0xff0000, alpha: 1 },\n   *       { offset: 1, color: 0x0000ff, alpha: 1 }\n   *   ]\n   * });\n   *\n   * graphics.strokeStyle = {\n   *     width: 4,\n   *     fill: gradient,\n   *     alignment: 0.5,\n   *     join: 'round',\n   *     cap: 'round'\n   * };\n   *\n   * // Complex stroke settings\n   * graphics.strokeStyle = {\n   *     width: 6,\n   *     color: 0x00ff00,\n   *     alpha: 0.5,\n   *     join: 'miter',\n   *     miterLimit: 10,\n   * };\n   * ```\n   * @see {@link StrokeStyle} For all available stroke style options\n   * @see {@link Graphics#stroke} For applying the stroke to paths\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object that copies the current graphics content.\n   * The clone can either share the same context (shallow clone) or have its own independent\n   * context (deep clone).\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Create original graphics content\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Create a shallow clone (shared context)\n   * const shallowClone = graphics.clone();\n   *\n   * // Changes to original affect the clone\n   * graphics\n   *     .circle(200, 100, 30)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Create a deep clone (independent context)\n   * const deepClone = graphics.clone(true);\n   *\n   * // Modify deep clone independently\n   * deepClone\n   *     .translateTransform(100, 100)\n   *     .circle(0, 0, 40)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @param deep - Whether to create a deep clone of the graphics object.\n   *              If false (default), the context will be shared between objects.\n   *              If true, creates an independent copy of the context.\n   * @returns A new Graphics instance with either shared or copied context\n   * @see {@link Graphics#context} For accessing the underlying graphics context\n   * @see {@link GraphicsContext} For understanding the shared context behavior\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\nimport { nextPow2 } from '../../maths/misc/pow2.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nlet _internalCanvas = null;\nlet _internalContext = null;\nfunction ensureInternalCanvas(width, height) {\n  if (!_internalCanvas) {\n    _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n    _internalContext = _internalCanvas.getContext(\"2d\", { willReadFrequently: true });\n    _internalContext.globalCompositeOperation = \"copy\";\n    _internalContext.globalAlpha = 1;\n  }\n  if (_internalCanvas.width < width || _internalCanvas.height < height) {\n    _internalCanvas.width = nextPow2(width);\n    _internalCanvas.height = nextPow2(height);\n  }\n}\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(...args) {\n  let options = args[0];\n  if (!options.canvas) {\n    options = { canvas: args[0], resolution: args[1] };\n  }\n  const { canvas } = options;\n  const resolution = Math.min(options.resolution ?? 1, 1);\n  const width = options.width ?? canvas.width;\n  const height = options.height ?? canvas.height;\n  let output = options.output;\n  ensureInternalCanvas(width, height);\n  if (!_internalContext) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  _internalContext.drawImage(\n    canvas,\n    0,\n    0,\n    width,\n    height,\n    0,\n    0,\n    width * resolution,\n    height * resolution\n  );\n  const imageData = _internalContext.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  _internalContext.globalCompositeOperation = \"source-over\";\n  _internalContext.strokeRect(left, top, right - left, bottom - top);\n  _internalContext.globalCompositeOperation = \"copy\";\n  output ?? (output = new Rectangle());\n  output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n  return output;\n}\n\nexport { getCanvasBoundingBox };\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n","import { Color } from '../../../color/Color.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nclass CanvasTextGeneratorClass {\n  /**\n   * Creates a canvas with the specified text rendered to it.\n   *\n   * Generates a canvas of appropriate size, renders the text with the provided style,\n   * and returns both the canvas/context and a Rectangle representing the text bounds.\n   *\n   * When trim is enabled in the style, the frame will represent the bounds of the\n   * non-transparent pixels, which can be smaller than the full canvas.\n   * @param options - The options for generating the text canvas\n   * @param options.text - The text to render\n   * @param options.style - The style to apply to the text\n   * @param options.resolution - The resolution of the canvas (defaults to 1)\n   * @param options.padding\n   * @returns An object containing the canvas/context and the frame (bounds) of the text\n   */\n  getCanvasAndContext(options) {\n    const { text, style, resolution = 1 } = options;\n    const padding = style._getFinalPadding();\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n    const frame = style.trim ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect }) : tempRect.set(0, 0, width, height);\n    return {\n      canvasAndContext,\n      frame\n    };\n  }\n  /**\n   * Returns a canvas and context to the pool.\n   *\n   * This should be called when you're done with the canvas to allow reuse\n   * and prevent memory leaks.\n   * @param canvasAndContext - The canvas and context to return to the pool\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @param text - The text to render\n   * @param style - The style of the text\n   * @param padding - The padding of the text\n   * @param resolution - The resolution of the text\n   * @param canvasAndContext - The canvas and context to render the text to\n   */\n  _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    context.textBaseline = style.textBaseline;\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n        if (style._stroke?.width) {\n          const strokePadding = style._stroke.width * 0.5 + padding * 2;\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + padding,\n            linePositionY + padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + padding,\n            linePositionY + padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   *\n   * This method handles rendering text with the correct letter spacing, using either:\n   * 1. Native letter spacing if supported by the browser\n   * 2. Manual letter spacing calculation if not natively supported\n   *\n   * For manual letter spacing, it calculates the position of each character\n   * based on its width and the desired spacing.\n   * @param text - The text to draw\n   * @param style - The text style to apply\n   * @param canvasAndContext - The canvas and context to draw to\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Whether to render the stroke (true) or fill (false)\n   * @private\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n}\nconst CanvasTextGenerator = new CanvasTextGeneratorClass();\n\nexport { CanvasTextGenerator };\n//# sourceMappingURL=CanvasTextGenerator.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n    this.image = DOMAdapter.get().createImage();\n  }\n  destroy() {\n    this.svgRoot.remove();\n    this.foreignObject.remove();\n    this.styleElement.remove();\n    this.domElement.remove();\n    this.image.src = \"\";\n    this.image.remove();\n    this.svgRoot = null;\n    this.foreignObject = null;\n    this.styleElement = null;\n    this.domElement = null;\n    this.image = null;\n    this.canvasAndContext = null;\n  }\n}\n\nexport { HTMLTextRenderData };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const doublePadding = style.padding * 2;\n  return {\n    width: contentBounds.width - doublePadding,\n    height: contentBounds.height - doublePadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshGpuData {\n  destroy() {\n  }\n}\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        mesh._texture\n      );\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const meshData = this._getMeshData(mesh);\n    if (mesh.didViewUpdate) {\n      meshData.indexSize = mesh._geometry.indices?.length;\n      meshData.vertexSize = mesh._geometry.positions?.length;\n    }\n    if (meshData.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    mesh._gpuData[this.renderer.uid].meshData = {\n      batched: mesh.batched,\n      indexSize: 0,\n      vertexSize: 0\n    };\n    return mesh._gpuData[this.renderer.uid].meshData;\n  }\n  _getBatchableMesh(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = new BatchableMesh();\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshGpuData, MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","\"use strict\";\nclass GlParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const state = particleContainerPipe.state;\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.resources.uTexture = container.texture._source;\n    shader.resources.uniforms = particleContainerPipe.localUniforms;\n    const gl = renderer.gl;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.shader.bind(shader);\n    renderer.state.set(state);\n    renderer.geometry.bind(buffer.geometry, shader.glProgram);\n    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n  }\n}\n\nexport { GlParticleContainerAdaptor };\n//# sourceMappingURL=GlParticleContainerAdaptor.mjs.map\n","\"use strict\";\nclass GpuParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n    const state = particleContainerPipe.state;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.encoder.draw({\n      geometry: buffer.geometry,\n      shader: container.shader || particleContainerPipe.defaultShader,\n      state,\n      size: container.particleChildren.length * 6\n    });\n  }\n}\n\nexport { GpuParticleContainerAdaptor };\n//# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map\n","\"use strict\";\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (totalIndices > 65535) {\n    outBuffer || (outBuffer = new Uint32Array(totalIndices));\n  } else {\n    outBuffer || (outBuffer = new Uint16Array(totalIndices));\n  }\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexport { createIndicesForQuads };\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction generateParticleUpdateFunction(properties) {\n  return {\n    dynamicUpdate: generateUpdateFunction(properties, true),\n    staticUpdate: generateUpdateFunction(properties, false)\n  };\n}\nfunction generateUpdateFunction(properties, dynamic) {\n  const funcFragments = [];\n  funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n  let offset = 0;\n  for (const i in properties) {\n    const property = properties[i];\n    if (dynamic !== property.dynamic)\n      continue;\n    funcFragments.push(`offset = index + ${offset}`);\n    funcFragments.push(property.code);\n    const attributeInfo = getAttributeInfoFromFormat(property.format);\n    offset += attributeInfo.stride / 4;\n  }\n  funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n  funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n  const functionSource = funcFragments.join(\"\\n\");\n  return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\nexport { generateParticleUpdateFunction };\n//# sourceMappingURL=generateParticleUpdateFunction.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads.mjs';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction.mjs';\n\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads(size);\n    const geometry = new Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(\n        this.indexBuffer,\n        this.indexBuffer.byteLength,\n        true\n      );\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(\n      this.dynamicAttributeBuffer.float32View,\n      particles.length * this._dynamicStride * 4,\n      true\n    );\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(\n        staticAttributeBuffer.float32View,\n        particles.length * this._staticStride * 4,\n        true\n      );\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\n\nexport { ParticleBuffer };\n//# sourceMappingURL=ParticleBuffer.mjs.map\n","var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n","var wgsl = \"\\nstruct ParticleUniforms {\\n  uTranslationMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uRound:f32,\\n  uResolution:vec2<f32>,\\n};\\n\\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\\n{\\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n   if(uniforms.uRound == 1.0) {\\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\\n   }\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport fragment from './particles.frag.mjs';\nimport vertex from './particles.vert.mjs';\nimport wgsl from './particles.wgsl.mjs';\n\n\"use strict\";\nclass ParticleShader extends Shader {\n  constructor() {\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment\n    });\n    const gpuProgram = GpuProgram.from({\n      fragment: {\n        source: wgsl,\n        entryPoint: \"mainFragment\"\n      },\n      vertex: {\n        source: wgsl,\n        entryPoint: \"mainVertex\"\n      }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        // this will be replaced with the texture from the particle container\n        uTexture: Texture.WHITE.source,\n        // this will be replaced with the texture style from the particle container\n        uSampler: new TextureStyle({}),\n        // this will be replaced with the local uniforms from the particle container\n        uniforms: {\n          uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Color(16777215), type: \"vec4<f32>\" },\n          uRound: { value: 1, type: \"f32\" },\n          uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n        }\n      }\n    });\n  }\n}\n\nexport { ParticleShader };\n//# sourceMappingURL=ParticleShader.mjs.map\n","var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport { ParticleShader } from './shader/ParticleShader.mjs';\n\n\"use strict\";\nclass ParticleContainerPipe {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */\n  constructor(renderer, adaptor) {\n    /** @internal */\n    this.state = State.for2d();\n    /** Local uniforms that are used for rendering particles. */\n    this.localUniforms = new UniformGroup({\n      uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uRound: { value: 1, type: \"f32\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    });\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.defaultShader = new ParticleShader();\n    this.state = State.for2d();\n  }\n  validateRenderable(_renderable) {\n    return false;\n  }\n  addRenderable(renderable, instructionSet) {\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderable);\n  }\n  getBuffers(renderable) {\n    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n  }\n  _initBuffer(renderable) {\n    renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n      size: renderable.particleChildren.length,\n      properties: renderable._properties\n    });\n    return renderable._gpuData[this.renderer.uid];\n  }\n  updateRenderable(_renderable) {\n  }\n  execute(container) {\n    const children = container.particleChildren;\n    if (children.length === 0) {\n      return;\n    }\n    const renderer = this.renderer;\n    const buffer = this.getBuffers(container);\n    container.texture || (container.texture = children[0].texture);\n    const state = this.state;\n    buffer.update(children, container._childrenDirty);\n    container._childrenDirty = false;\n    state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n    const uniforms = this.localUniforms.uniforms;\n    const transformationMatrix = uniforms.uTranslationMatrix;\n    container.worldTransform.copyTo(transformationMatrix);\n    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n    uniforms.uRound = renderer._roundPixels | container._roundPixels;\n    color32BitToUniform(\n      container.groupColorAlpha,\n      uniforms.uColor,\n      0\n    );\n    this.adaptor.execute(this, container);\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    this.renderer = null;\n    if (this.defaultShader) {\n      this.defaultShader.destroy();\n      this.defaultShader = null;\n    }\n  }\n}\n\nexport { ParticleContainerPipe };\n//# sourceMappingURL=ParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GlParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GlParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGlParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GlParticleContainerPipe };\n//# sourceMappingURL=GlParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GpuParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GpuParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGpuParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GpuParticleContainerPipe };\n//# sourceMappingURL=GpuParticleContainerPipe.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpriteGpuData, NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.default2d;\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpriteGpuData, TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader {\n  constructor(maxTextures) {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextGraphics extends Graphics {\n  destroy() {\n    if (this.context.customShader) {\n      this.context.customShader.destroy();\n    }\n    super.destroy();\n  }\n}\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n      }\n    }\n    const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    let fontSize = bitmapFont.fontMetrics.fontSize;\n    let lineHeight = bitmapFont.lineHeight;\n    if (style.lineHeight) {\n      fontSize = style.fontSize / scale;\n      lineHeight = style.lineHeight / scale;\n    }\n    let linePositionYShift = (lineHeight - fontSize) / 2;\n    if (linePositionYShift - bitmapFont.baseLineOffset < 0) {\n      linePositionYShift = 0;\n    }\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = line.chars[j];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          const texture = charData.texture;\n          context.texture(\n            texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset + linePositionYShift),\n            texture.orig.width,\n            texture.orig.height\n          );\n        }\n      }\n      currentY += lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = new BitmapTextGraphics();\n    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    return proxyRenderable;\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextGraphics, BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableHTMLText extends BatchableSprite {\n  /**\n   * Creates an instance of BatchableHTMLText.\n   * @param renderer - The renderer instance to be used.\n   */\n  constructor(renderer) {\n    super();\n    this.generatingTexture = false;\n    this.currentKey = \"--\";\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n  destroy() {\n    const { htmlText } = this._renderer;\n    htmlText.getReferenceCount(this.currentKey) === null ? htmlText.returnTexturePromise(this.texturePromise) : htmlText.decreaseReferenceCount(this.currentKey);\n    this._renderer.runners.resolutionChange.remove(this);\n    this.texturePromise = null;\n    this._renderer = null;\n  }\n}\n\nexport { BatchableHTMLText };\n//# sourceMappingURL=BatchableHTMLText.mjs.map\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\n\n\"use strict\";\nfunction updateTextBounds(batchableSprite, text) {\n  const { texture, bounds } = batchableSprite;\n  const padding = text._style._getFinalPadding();\n  updateQuadBounds(bounds, text._anchor, texture);\n  const paddingOffset = text._anchor._x * padding * 2;\n  const paddingOffsetY = text._anchor._y * padding * 2;\n  bounds.minX -= padding - paddingOffset;\n  bounds.minY -= padding - paddingOffsetY;\n  bounds.maxX -= padding - paddingOffset;\n  bounds.maxY -= padding - paddingOffsetY;\n}\n\nexport { updateTextBounds };\n//# sourceMappingURL=updateTextBounds.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateTextBounds } from '../text/utils/updateTextBounds.mjs';\nimport { BatchableHTMLText } from './BatchableHTMLText.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText.styleKey;\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (htmlText._didTextUpdate) {\n      const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n      if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {\n        this._updateGpuText(htmlText).catch((e) => {\n          console.error(e);\n        });\n      }\n      htmlText._didTextUpdate = false;\n      updateTextBounds(batchableHTMLText, htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    batchableHTMLText._batcher.updateElement(batchableHTMLText);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (batchableHTMLText.generatingTexture)\n      return;\n    const oldTexturePromise = batchableHTMLText.texturePromise;\n    batchableHTMLText.texturePromise = null;\n    batchableHTMLText.generatingTexture = true;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n    if (oldTexturePromise) {\n      texturePromise = texturePromise.finally(() => {\n        this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n        this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n      });\n    }\n    batchableHTMLText.texturePromise = texturePromise;\n    batchableHTMLText.currentKey = htmlText.styleKey;\n    batchableHTMLText.texture = await texturePromise;\n    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    batchableHTMLText.generatingTexture = false;\n    updateTextBounds(batchableHTMLText, htmlText);\n  }\n  _getGpuText(htmlText) {\n    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const batchableHTMLText = new BatchableHTMLText(this._renderer);\n    batchableHTMLText.renderable = htmlText;\n    batchableHTMLText.transform = htmlText.groupTransform;\n    batchableHTMLText.texture = Texture.EMPTY;\n    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n    return batchableHTMLText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { entries } = Cache.get(`${fontFamily}-and-url`);\n      const promises = [];\n      entries.forEach((entry) => {\n        const url = entry.url;\n        const faces = entry.faces;\n        const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n        promises.push(\n          ...out.map(\n            (style) => loadFontCSS(\n              {\n                fontWeight: style.weight,\n                fontStyle: style.style,\n                fontFamily\n              },\n              url\n            )\n          )\n        );\n      });\n      FontStylePromiseCache.set(\n        fontFamily,\n        Promise.all(promises).then((css) => css.join(\"\\n\"))\n      );\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */\n  getTexture(options) {\n    return this.getTexturePromise(options);\n  }\n  /**\n   * Increases the reference count for a texture.\n   * @param text - The HTMLText instance associated with the texture.\n   */\n  getManagedTexture(text) {\n    const textKey = text.styleKey;\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  /**\n   * Gets the current reference count for a texture associated with a text key.\n   * @param textKey - The unique key identifying the text style configuration\n   * @returns The number of Text instances currently using this texture\n   */\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey]?.usageCount ?? null;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Decreases the reference count for a texture.\n   * If the count reaches zero, the texture is cleaned up.\n   * @param textKey - The key associated with the HTMLText instance.\n   */\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture.texture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture.texture);\n        }).catch(() => {\n          warn(\"HTMLTextSystem: Failed to clean texture\");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  /**\n   * Returns a promise that resolves to a texture for the given HTMLText options.\n   * @param options - The options for the HTMLText.\n   * @returns A promise that resolves to a Texture.\n   */\n  getTexturePromise(options) {\n    return this._buildTexturePromise(options);\n  }\n  async _buildTexturePromise(options) {\n    const { text, style, resolution, textureStyle } = options;\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(fontFamilies);\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    const uvSafeOffset = 2;\n    image.width = (width | 0) + uvSafeOffset;\n    image.height = (height | 0) + uvSafeOffset;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    const resource = image;\n    let canvasAndContext;\n    if (this._createCanvas) {\n      canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(\n      canvasAndContext ? canvasAndContext.canvas : resource,\n      image.width - uvSafeOffset,\n      image.height - uvSafeOffset,\n      resolution\n    );\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  returnTexturePromise(texturePromise) {\n    texturePromise.then((texture) => {\n      this._cleanUp(texture);\n    }).catch(() => {\n      warn(\"HTMLTextSystem: Failed to clean texture\");\n    });\n  }\n  _cleanUp(texture) {\n    TexturePool.returnTexture(texture, true);\n    texture.source.resource = null;\n    texture.source.uploadMethodId = \"unknown\";\n  }\n  destroy() {\n    this._renderer = null;\n    for (const key in this._activeTextures) {\n      if (this._activeTextures[key])\n        this.returnTexturePromise(this._activeTextures[key].promise);\n    }\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  return canvasAndContext;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableText extends BatchableSprite {\n  constructor(renderer) {\n    super();\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  destroy() {\n    const { canvasText } = this._renderer;\n    const refCount = canvasText.getReferenceCount(this.currentKey);\n    if (refCount > 0) {\n      canvasText.decreaseReferenceCount(this.currentKey);\n    } else if (this.texture) {\n      canvasText.returnTexture(this.texture);\n    }\n    this._renderer.runners.resolutionChange.remove(this);\n    this._renderer = null;\n  }\n}\n\nexport { BatchableText };\n//# sourceMappingURL=BatchableText.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateTextBounds } from '../utils/updateTextBounds.mjs';\nimport { BatchableText } from './BatchableText.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text.styleKey;\n    if (gpuText.currentKey !== newKey)\n      return true;\n    return text._didTextUpdate;\n  }\n  addRenderable(text, instructionSet) {\n    const batchableText = this._getGpuText(text);\n    if (text._didTextUpdate) {\n      const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n      if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {\n        this._updateGpuText(text);\n      }\n      text._didTextUpdate = false;\n      updateTextBounds(batchableText, text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n  }\n  updateRenderable(text) {\n    const batchableText = this._getGpuText(text);\n    batchableText._batcher.updateElement(batchableText);\n  }\n  _updateGpuText(text) {\n    const batchableText = this._getGpuText(text);\n    if (batchableText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n    }\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n    batchableText.currentKey = text.styleKey;\n  }\n  _getGpuText(text) {\n    return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const batchableText = new BatchableText(this._renderer);\n    batchableText.currentKey = \"--\";\n    batchableText.renderable = text;\n    batchableText.transform = text.groupTransform;\n    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    text._gpuData[this._renderer.uid] = batchableText;\n    return batchableText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextGenerator } from './CanvasTextGenerator.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTexture(options, _resolution, _style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style: _style,\n        resolution: _resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    if (!(options.textureStyle instanceof TextureStyle)) {\n      options.textureStyle = new TextureStyle(options.textureStyle);\n    }\n    if (typeof options.text !== \"string\") {\n      options.text = options.text.toString();\n    }\n    const { text, style, textureStyle } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n      text,\n      style,\n      resolution\n    });\n    const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (style.trim) {\n      frame.pad(style.padding);\n      texture.frame.copyFrom(frame);\n      texture.frame.scale(1 / resolution);\n      texture.updateUvs();\n    }\n    if (style.filters) {\n      const filteredTexture = this._applyFilters(texture, style.filters);\n      this.returnTexture(texture);\n      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      return filteredTexture;\n    }\n    this._renderer.texture.initSource(texture._source);\n    CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.returnTexture(texture, true);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */\n  renderTextToCanvas() {\n    deprecation(\n      \"8.10.0\",\n      \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\"\n    );\n  }\n  /**\n   * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n   * @param text - The Text object that needs a texture\n   * @returns A Texture instance that represents the rendered text\n   * @remarks\n   * This method performs the following:\n   * 1. Sets the appropriate resolution based on auto-resolution settings\n   * 2. Checks if a texture already exists for the text's style\n   * 3. Creates a new texture if needed or returns an existing one\n   * 4. Manages reference counting for texture reuse\n   */\n  getManagedTexture(text) {\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    const textKey = text.styleKey;\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const texture = this.getTexture({\n      text: text.text,\n      style: text.style,\n      resolution: text._resolution,\n      textureStyle: text.textureStyle\n    });\n    this._activeTextures[textKey] = {\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  /**\n   * Decreases the reference count for a texture associated with a text key.\n   * When the reference count reaches zero, the texture is returned to the pool.\n   * @param textKey - The unique key identifying the text style configuration\n   * @remarks\n   * This method is crucial for memory management, ensuring textures are properly\n   * cleaned up when they are no longer needed by any Text instances.\n   */\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      this.returnTexture(activeTexture.texture);\n      this._activeTextures[textKey] = null;\n    }\n  }\n  /**\n   * Gets the current reference count for a texture associated with a text key.\n   * @param textKey - The unique key identifying the text style configuration\n   * @returns The number of Text instances currently using this texture\n   */\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey]?.usageCount ?? 0;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */\n  _applyFilters(texture, filters) {\n    const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n    const resultTexture = this._renderer.filter.generateFilteredTexture({\n      texture,\n      filters\n    });\n    this._renderer.renderTarget.bind(currentRenderTarget, false);\n    return resultTexture;\n  }\n  destroy() {\n    this._renderer = null;\n    for (const key in this._activeTextures) {\n      if (this._activeTextures[key])\n        this.returnTexture(this._activeTextures[key].texture);\n    }\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe.mjs';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe.mjs';\n\n\"use strict\";\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","source","PassthroughFilter","Filter","constructor","super","gpuProgram","GpuProgram","from","vertex","entryPoint","fragment","name","glProgram","GlProgram","FilterPipe","_renderer","push","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","type","WebGLPipes","WebGPUPipes","CanvasPipes","tempProjectionMatrix","Matrix","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterData","skip","inputTexture","backTexture","filters","bounds","Bounds","blendRequired","outputRenderSurface","globalFrame","x","y","firstEnabledIndex","lastEnabledIndex","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderTarget","renderSurface","colorTextureSource","colorTexture","rootResolution","resolution","rootAntialias","antialias","every","enabled","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","offsetY","minX","minY","_calculateGlobalFrame","_setupFilterTextures","generateFilteredTexture","texture","addRect","frame","rectangle","TexturePool","getOptimalTexture","Texture","EMPTY","finishRenderPass","_applyFiltersToTexture","outputTexture","alphaMode","_popFilterData","globalUniforms","returnTexture","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","_resolution","Math","floor","ceil","copyToTexture","applyFilter","input","output","clear","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","filterToApply","_getPassthroughFilter","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","_source","worldTransform","copyTo","renderGroup","parentRenderGroup","cacheToLocalTransform","prepend","invert","scale","orig","translate","anchor","_passthroughFilter","uniformBatch","batchUniforms","getUboResource","setResource","style","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","getRenderTarget","bind","sourceWidth","sourceHeight","uniforms","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","resource","isRoot","update","currentIndex","lastIndex","prevFilterData","renderables","actualMatrix","matrix","i","length","renderable","globalDisplayStatus","isCachedAsTexture","copyFrom","textureOffsetInverseTransform","append","_parentCacheAsTextureRenderGroup","inverseWorldTransform","groupTransform","addBounds","getGlobalRenderableBounds","filterArea","applyMatrix","getFastGlobalBounds","filterFrameTransform","firstEnabled","lastEnabled","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","padding","clipToViewport","min","compatibleRenderers","backBuffer","useBackBuffer","warn","fitBounds","pad","isPositive","index","WebGLSystem","WebGPUSystem","Graphics","ViewContainer","GraphicsContext","context","roundPixels","rest","label","_context","_ownedContext","on","onViewUpdate","didViewUpdate","allowChildren","off","updateBounds","containsPoint","point","_callContextMethod","method","args","setFillStyle","setStrokeStyle","fill","stroke","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","closePath","ellipse","circle","path","lineTo","moveTo","quadraticCurveTo","rect","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","setTransform","transform","translateTransform","fillStyle","strokeStyle","clone","deep","lineStyle","color","alpha","deprecation","v8_0_0","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","_MeshGeometry","positions","uvs","indices","defaultOptions","shrinkToFit","shrinkBuffersToFit","Buffer","usage","BufferUsage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","_internalCanvas","_internalContext","checkRow","checkColumn","top","bottom","getCanvasBoundingBox","canvas","DOMAdapter","createCanvas","getContext","willReadFrequently","globalCompositeOperation","globalAlpha","nextPow2","ensureInternalCanvas","TypeError","drawImage","getImageData","left","right","Rectangle","strokeRect","tempRect","CanvasTextGenerator","getCanvasAndContext","text","_getFinalPadding","measured","CanvasTextMetrics","measureText","max","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","_renderTextToCanvas","trim","returnCanvasAndContext","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","textBaseline","_stroke","lineWidth","miterLimit","lineJoin","join","lineCap","cap","linePositionX","linePositionY","passesCount","dropShadow","isShadowPass","dsOffsetText","dsOffsetShadow","shadowOptions","dropShadowColor","dropShadowAlpha","shadowColor","Color","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","distance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","_fill","getCanvasFillStyle","strokePadding","linePositionYShift","fontSize","strokeWidth","i2","ascent","align","_drawLetterSpacing","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","overflow","appendChild","image","createImage","src","tempHTMLTextRenderData","GraphicsGpuData","batches","batched","forEach","BigPool","return","GraphicsPipe","adaptor","State","for2d","_adaptor","runners","contextChange","validateRenderable","graphics","wasBatched","_gpuData","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","_rebuild","_addToBatcher","updateRenderable","_getGpuDataForRenderable","_batcher","updateElement","isRenderable","getGpuContext","customShader","blendMode","groupBlendMode","localUniforms","resources","uTransformMatrix","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","gpuData","_updateBatchesForRenderable","batchPipe","addToBatch","uid","_initGpuDataForRenderable","map","batchClone","BatchableGraphics","_PlaneGeometry","verticesX","verticesY","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","BatchableMesh","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_textureMatrixUpdateId","_uvUpdateId","_topology","reset","setTexture","uvBuffer","getBuffer","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","multiplyUvs","attributeSize","indexSize","MeshGpuData","MeshPipe","localUniformsBindGroup","mesh","meshData","_getMeshData","isBatched","_geometry","vertexSize","batchableMesh","_getBatchableMesh","_texture","checkAndUpdateTexture","batcher","gpuBatchableMesh","getAdjustedBlendModeBlend","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","uTexture","gl","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","size","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","key","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","wgsl","ParticleShader","Shader","WHITE","uSampler","TextureStyle","uTranslationMatrix","uResolution","ParticleContainerPipe","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerPipe","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updateUvs","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","NineSliceSpritePipe","gpuSprite","_getGpuSprite","_updateBatchableSprite","batchableSprite","_initGPUSprite","tilingBit","header","main","tilingBitGl","TilingSpriteShader","compileHighShaderGpuProgram","bits","localUniformBit","roundPixelsBit","compileHighShaderGlProgram","localUniformBitGl","roundPixelsBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","a","b","c","d","tx","ty","mapCoord","sharedQuad","TilingSpriteGpuData","canBatch","slice","TilingSpritePipe","default2d","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","bindGroup","_tileTransform","_initTilingSpriteData","renderableData","addressMode","applyAnchorToTexture","array","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isPowerOfTwo","localUniformMSDFBit","end","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","maxTextures","uDistance","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","getBatchSamplersUniformGroup","BitmapTextGraphics","BitmapTextPipe","bitmapText","graphicsRenderable","_getGpuBitmapText","syncWithProxy","_didTextUpdate","_updateContext","_updateDistanceField","proxyGraphics","bitmapFont","BitmapFontManager","getFont","_style","distanceField","limits","maxBatchableTextures","chars","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","_anchor","_x","_y","tint","applyFillAsTint","fontMetrics","line","charPositions","char","charData","round","xOffset","yOffset","initGpuText","proxyRenderable","fontFamily","dynamicFont","Cache","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","range","proxy","groupColor","localDisplayStatus","groupAlpha","BatchableHTMLText","BatchableSprite","generatingTexture","currentKey","resolutionChange","_autoResolution","htmlText","getReferenceCount","returnTexturePromise","texturePromise","decreaseReferenceCount","updateTextBounds","updateQuadBounds","paddingOffset","paddingOffsetY","maxX","maxY","HTMLTextPipe","gpuText","_getGpuText","newKey","styleKey","batchableHTMLText","_updateGpuText","catch","e","oldTexturePromise","getTexturePromise","finally","structureDidChange","tempBounds","getPo2TextureFromSource","uploadMethodId","emit","async","loadFontCSS","url","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","fontWeight","fontStyle","FontStylePromiseCache","Map","HTMLTextSystem","_activeTextures","_createCanvas","WEBGPU","getTexture","getManagedTexture","textKey","_increaseReferenceCount","promise","_buildTexturePromise","then","usageCount","activeTexture","_cleanUp","textureStyle","htmlTextData","fontFamilies","dedupe","matches","match","addFontFamily","fontFamily2","Array","isArray","split","tagStyles","extractFontFamilies","fontCSS","fontPromises","has","entries","promises","entry","out","faces","face","weight","all","css","getFontCss","fontStyleCSS","htmlTextRenderData","innerHTML","cssStyle","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","toString","XMLSerializer","serializeToString","getSVGUrl","delay","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","clearRect","getTemporaryCanvasFromImage","initSource","CanvasSystem","BatchableText","canvasText","CanvasTextPipe","batchableText","CanvasTextSystem","_textKey","TextStyle","filteredTexture","_applyFilters","renderTextToCanvas","currentRenderTarget","resultTexture","extensions","GraphicsContextSystem"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68]}