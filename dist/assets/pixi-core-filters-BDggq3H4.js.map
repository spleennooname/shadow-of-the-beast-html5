{"version":3,"file":"pixi-core-filters-BDggq3H4.js","sources":["../../node_modules/pixi.js/lib/filters/FilterEffect.mjs","../../node_modules/pixi.js/lib/filters/Filter.mjs","../../node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs","../../node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs","../../node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/const.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs","../../node_modules/pixi.js/lib/filters/FilterPipe.mjs","../../node_modules/pixi.js/lib/filters/FilterSystem.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","../../node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","../../node_modules/pixi.js/lib/filters/init.mjs"],"sourcesContent":["\"use strict\";\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = \"filter\";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexport { FilterEffect };\n//# sourceMappingURL=FilterEffect.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct AlphaUniforms {\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n \\n    var sample = textureSample(uTexture, uSampler, uv);\\n    \\n    return sample * alphaUniforms.uAlpha;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=alpha.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './alpha.frag.mjs';\nimport source from './alpha.wgsl.mjs';\n\n\"use strict\";\nconst _AlphaFilter = class _AlphaFilter extends Filter {\n  constructor(options) {\n    options = { ..._AlphaFilter.defaultOptions, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"alpha-filter\"\n    });\n    const { alpha, ...rest } = options;\n    const alphaUniforms = new UniformGroup({\n      uAlpha: { value: alpha, type: \"f32\" }\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        alphaUniforms\n      }\n    });\n  }\n  /**\n   * The alpha value of the filter.\n   * Controls the transparency of the filtered display object.\n   * @example\n   * ```ts\n   * // Create filter with initial alpha\n   * const filter = new AlphaFilter({ alpha: 0.5 });\n   *\n   * // Update alpha value dynamically\n   * filter.alpha = 0.8;\n   * ```\n   * @default 1\n   * @remarks\n   * - 0 = fully transparent\n   * - 1 = fully opaque\n   * - Values are clamped between 0 and 1\n   */\n  get alpha() {\n    return this.resources.alphaUniforms.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.resources.alphaUniforms.uniforms.uAlpha = value;\n  }\n};\n/**\n * Default options for the AlphaFilter.\n * @example\n * ```ts\n * AlphaFilter.defaultOptions = {\n *     alpha: 0.5, // Default alpha value\n * };\n * // Use default options\n * const filter = new AlphaFilter(); // Uses default alpha of 0.5\n * ```\n */\n_AlphaFilter.defaultOptions = {\n  /**\n   * Amount of alpha transparency to apply.\n   * - 0 = fully transparent\n   * - 1 = fully opaque (default)\n   * @default 1\n   */\n  alpha: 1\n};\nlet AlphaFilter = _AlphaFilter;\n\nexport { AlphaFilter };\n//# sourceMappingURL=AlphaFilter.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform float uAlpha;\\nuniform sampler2D uTexture;\\n\\nvoid main()\\n{\\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=alpha.frag.mjs.map\n","\"use strict\";\nconst GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n};\n\nexport { GAUSSIAN_VALUES };\n//# sourceMappingURL=const.mjs.map\n","import { GAUSSIAN_VALUES } from '../const.mjs';\n\n\"use strict\";\nconst fragTemplate = [\n  \"in vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uTexture;\",\n  \"out vec4 finalColor;\",\n  \"void main(void)\",\n  \"{\",\n  \"    finalColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(\"\\n\");\nfunction generateBlurFragSource(kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  let fragSource = fragTemplate;\n  let blurLoop = \"\";\n  const template = \"finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;\";\n  let value;\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace(\"%index%\", i.toString());\n    value = i;\n    if (i >= halfLength) {\n      value = kernelSize - i - 1;\n    }\n    blur = blur.replace(\"%value%\", kernel[value].toString());\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  fragSource = fragSource.replace(\"%blur%\", blurLoop);\n  fragSource = fragSource.replace(\"%size%\", kernelSize.toString());\n  return fragSource;\n}\n\nexport { generateBlurFragSource };\n//# sourceMappingURL=generateBlurFragSource.mjs.map\n","import { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { generateBlurFragSource } from './generateBlurFragSource.mjs';\nimport { generateBlurVertSource } from './generateBlurVertSource.mjs';\n\n\"use strict\";\nfunction generateBlurGlProgram(horizontal, kernelSize) {\n  const vertex = generateBlurVertSource(kernelSize, horizontal);\n  const fragment = generateBlurFragSource(kernelSize);\n  return GlProgram.from({\n    vertex,\n    fragment,\n    name: `blur-${horizontal ? \"horizontal\" : \"vertical\"}-pass-filter`\n  });\n}\n\nexport { generateBlurGlProgram };\n//# sourceMappingURL=generateBlurGlProgram.mjs.map\n","\"use strict\";\nconst vertTemplate = `\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(kernelSize, x) {\n  const halfLength = Math.ceil(kernelSize / 2);\n  let vertSource = vertTemplate;\n  let blurLoop = \"\";\n  let template;\n  if (x) {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);\";\n  } else {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);\";\n  }\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace(\"%index%\", i.toString());\n    blur = blur.replace(\"%sampleIndex%\", `${i - (halfLength - 1)}.0`);\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  vertSource = vertSource.replace(\"%blur%\", blurLoop);\n  vertSource = vertSource.replace(\"%size%\", kernelSize.toString());\n  vertSource = vertSource.replace(\"%dimension%\", x ? \"z\" : \"w\");\n  return vertSource;\n}\n\nexport { generateBlurVertSource };\n//# sourceMappingURL=generateBlurVertSource.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../../rendering/renderers/types.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport { generateBlurGlProgram } from './gl/generateBlurGlProgram.mjs';\nimport { generateBlurProgram } from './gpu/generateBlurProgram.mjs';\n\n\"use strict\";\nconst _BlurFilterPass = class _BlurFilterPass extends Filter {\n  /**\n   * @param options\n   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n   * @param options.strength - The strength of the blur filter.\n   * @param options.quality - The quality of the blur filter.\n   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n   */\n  constructor(options) {\n    options = { ..._BlurFilterPass.defaultOptions, ...options };\n    const glProgram = generateBlurGlProgram(options.horizontal, options.kernelSize);\n    const gpuProgram = generateBlurProgram(options.horizontal, options.kernelSize);\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        blurUniforms: {\n          uStrength: { value: 0, type: \"f32\" }\n        }\n      },\n      ...options\n    });\n    this.horizontal = options.horizontal;\n    this._quality = 0;\n    this.quality = options.quality;\n    this.blur = options.strength;\n    this._uniforms = this.resources.blurUniforms.uniforms;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   */\n  apply(filterManager, input, output, clearMode) {\n    this._uniforms.uStrength = this.strength / this.passes;\n    if (this.passes === 1) {\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const tempTexture = TexturePool.getSameSizeTexture(input);\n      let flip = input;\n      let flop = tempTexture;\n      this._state.blend = false;\n      const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;\n      for (let i = 0; i < this.passes - 1; i++) {\n        filterManager.applyFilter(this, flip, flop, i === 0 ? true : shouldClear);\n        const temp = flop;\n        flop = flip;\n        flip = temp;\n      }\n      this._state.blend = true;\n      filterManager.applyFilter(this, flip, output, clearMode);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  /**\n   * Sets the strength of both the blur.\n   * @default 16\n   */\n  get blur() {\n    return this.strength;\n  }\n  set blur(value) {\n    this.padding = 1 + Math.abs(value) * 2;\n    this.strength = value;\n  }\n  /**\n   * Sets the quality of the blur by modifying the number of passes. More passes means higher\n   * quality blurring but the lower the performance.\n   * @default 4\n   */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.passes = value;\n  }\n};\n/** Default blur filter pass options */\n_BlurFilterPass.defaultOptions = {\n  /** The strength of the blur filter. */\n  strength: 8,\n  /** The quality of the blur filter. */\n  quality: 4,\n  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n  kernelSize: 5\n};\nlet BlurFilterPass = _BlurFilterPass;\n\nexport { BlurFilterPass };\n//# sourceMappingURL=BlurFilterPass.mjs.map\n","import { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { GAUSSIAN_VALUES } from '../const.mjs';\nimport source from './blur-template.wgsl.mjs';\n\n\"use strict\";\nfunction generateBlurProgram(horizontal, kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  const blurStructSource = [];\n  const blurOutSource = [];\n  const blurSamplingSource = [];\n  for (let i = 0; i < kernelSize; i++) {\n    blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;\n    if (horizontal) {\n      blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;\n    } else {\n      blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;\n    }\n    const kernelIndex = i < halfLength ? i : kernelSize - i - 1;\n    const kernelValue = kernel[kernelIndex].toString();\n    blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;\n  }\n  const blurStruct = blurStructSource.join(\"\\n\");\n  const blurOut = blurOutSource.join(\"\\n\");\n  const blurSampling = blurSamplingSource.join(\"\\n\");\n  const finalSource = source.replace(\"%blur-struct%\", blurStruct).replace(\"%blur-vertex-out%\", blurOut).replace(\"%blur-fragment-in%\", blurStruct).replace(\"%blur-sampling%\", blurSampling).replace(\"%dimension%\", horizontal ? \"z\" : \"w\");\n  return GpuProgram.from({\n    vertex: {\n      source: finalSource,\n      entryPoint: \"mainVertex\"\n    },\n    fragment: {\n      source: finalSource,\n      entryPoint: \"mainFragment\"\n    }\n  });\n}\n\nexport { generateBlurProgram };\n//# sourceMappingURL=generateBlurProgram.mjs.map\n","var source = \"\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct BlurUniforms {\\n  uStrength:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    %blur-struct%\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n\\n  let filteredCord = filterTextureCoord(aPosition);\\n\\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\\n\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n    %blur-vertex-out%\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  %blur-fragment-in%\\n) -> @location(0) vec4<f32> {\\n\\n    var   finalColor = vec4(0.0);\\n\\n    %blur-sampling%\\n\\n    return finalColor;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=blur-template.wgsl.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../../rendering/renderers/types.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport { BlurFilterPass } from './BlurFilterPass.mjs';\n\n\"use strict\";\nclass BlurFilter extends Filter {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }\");\n      options = { strength: options };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.resolution = args[2] || \"inherit\";\n      if (args[3] !== void 0)\n        options.kernelSize = args[3];\n    }\n    options = { ...BlurFilterPass.defaultOptions, ...options };\n    const { strength, strengthX, strengthY, quality, ...rest } = options;\n    super({\n      ...rest,\n      compatibleRenderers: RendererType.BOTH,\n      resources: {}\n    });\n    this._repeatEdgePixels = false;\n    this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });\n    this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });\n    this.quality = quality;\n    this.strengthX = strengthX ?? strength;\n    this.strengthY = strengthY ?? strength;\n    this.repeatEdgePixels = false;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   * @advanced\n   */\n  apply(filterManager, input, output, clearMode) {\n    const xStrength = Math.abs(this.blurXFilter.strength);\n    const yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      const tempTexture = TexturePool.getSameSizeTexture(input);\n      this.blurXFilter.blendMode = \"normal\";\n      this.blurXFilter.apply(filterManager, input, tempTexture, true);\n      this.blurYFilter.blendMode = this.blendMode;\n      this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);\n      TexturePool.returnTexture(tempTexture);\n    } else if (yStrength) {\n      this.blurYFilter.blendMode = this.blendMode;\n      this.blurYFilter.apply(filterManager, input, output, clearMode);\n    } else {\n      this.blurXFilter.blendMode = this.blendMode;\n      this.blurXFilter.apply(filterManager, input, output, clearMode);\n    }\n  }\n  updatePadding() {\n    if (this._repeatEdgePixels) {\n      this.padding = 0;\n    } else {\n      this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;\n    }\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously.\n   * Controls the overall intensity of the Gaussian blur effect.\n   * @example\n   * ```ts\n   * // Set equal blur strength for both axes\n   * filter.strength = 8;\n   *\n   * // Will throw error if X and Y are different\n   * filter.strengthX = 4;\n   * filter.strengthY = 8;\n   * filter.strength; // Error: BlurFilter's strengthX and strengthY are different\n   * ```\n   * @default 8\n   * @throws {Error} If strengthX and strengthY are different values\n   */\n  get strength() {\n    if (this.strengthX !== this.strengthY) {\n      throw new Error(\"BlurFilter's strengthX and strengthY are different\");\n    }\n    return this.strengthX;\n  }\n  set strength(value) {\n    this.blurXFilter.blur = this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the number of passes for blur. More passes means higher quality blurring.\n   * Controls the precision and smoothness of the blur effect at the cost of performance.\n   * @example\n   * ```ts\n   * // High quality blur (slower)\n   * filter.quality = 8;\n   *\n   * // Low quality blur (faster)\n   * filter.quality = 2;\n   * ```\n   * @default 4\n   * @remarks Higher values produce better quality but impact performance\n   */\n  get quality() {\n    return this.blurXFilter.quality;\n  }\n  set quality(value) {\n    this.blurXFilter.quality = this.blurYFilter.quality = value;\n  }\n  /**\n   * Sets the strength of horizontal blur.\n   * Controls the blur intensity along the x-axis independently.\n   * @example\n   * ```ts\n   * // Apply horizontal-only blur\n   * filter.strengthX = 8;\n   * filter.strengthY = 0;\n   *\n   * // Create motion blur effect\n   * filter.strengthX = 16;\n   * filter.strengthY = 2;\n   * ```\n   * @default 8\n   */\n  get strengthX() {\n    return this.blurXFilter.blur;\n  }\n  set strengthX(value) {\n    this.blurXFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the strength of the vertical blur.\n   * Controls the blur intensity along the y-axis independently.\n   * @example\n   * ```ts\n   * // Apply vertical-only blur\n   * filter.strengthX = 0;\n   * filter.strengthY = 8;\n   *\n   * // Create radial blur effect\n   * filter.strengthX = 8;\n   * filter.strengthY = 8;\n   * ```\n   * @default 8\n   */\n  get strengthY() {\n    return this.blurYFilter.blur;\n  }\n  set strengthY(value) {\n    this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strength\n   */\n  get blur() {\n    deprecation(\"8.3.0\", \"BlurFilter.blur is deprecated, please use BlurFilter.strength instead.\");\n    return this.strength;\n  }\n  set blur(value) {\n    deprecation(\"8.3.0\", \"BlurFilter.blur is deprecated, please use BlurFilter.strength instead.\");\n    this.strength = value;\n  }\n  /**\n   * Sets the strength of the blurX property\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strengthX\n   */\n  get blurX() {\n    deprecation(\"8.3.0\", \"BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.\");\n    return this.strengthX;\n  }\n  set blurX(value) {\n    deprecation(\"8.3.0\", \"BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.\");\n    this.strengthX = value;\n  }\n  /**\n   * Sets the strength of the blurY property\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strengthY\n   */\n  get blurY() {\n    deprecation(\"8.3.0\", \"BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.\");\n    return this.strengthY;\n  }\n  set blurY(value) {\n    deprecation(\"8.3.0\", \"BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.\");\n    this.strengthY = value;\n  }\n  /**\n   * If set to true the edge of the target will be clamped\n   * @default false\n   */\n  get repeatEdgePixels() {\n    return this._repeatEdgePixels;\n  }\n  set repeatEdgePixels(value) {\n    this._repeatEdgePixels = value;\n    this.updatePadding();\n  }\n}\n/**\n * Default blur filter options\n * @example\n * ```ts\n * // Set default options for all BlurFilters\n * BlurFilter.defaultOptions = {\n *     strength: 10,       // Default blur strength\n *     quality: 2,        // Default blur quality\n *     kernelSize: 7      // Default kernel size\n * };\n * // Create a filter with these defaults\n * const filter = new BlurFilter(); // Uses default options\n * ```\n * @remarks\n * - These options are used when creating a new BlurFilter without specific parameters\n * - Can be overridden by passing options to the constructor\n * - Useful for setting global defaults for all blur filters in your application\n * @see {@link BlurFilterOptions} For detailed options\n * @see {@link BlurFilter} The filter that uses these options\n */\nBlurFilter.defaultOptions = {\n  /** The strength of the blur filter. */\n  strength: 8,\n  /** The quality of the blur filter. */\n  quality: 4,\n  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n  kernelSize: 5\n};\n\nexport { BlurFilter };\n//# sourceMappingURL=BlurFilter.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './passthrough.frag.mjs';\nimport source from './passthrough.wgsl.mjs';\n\n\"use strict\";\nclass PassthroughFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: { source, entryPoint: \"mainVertex\" },\n      fragment: { source, entryPoint: \"mainFragment\" },\n      name: \"passthrough-filter\"\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"passthrough-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram\n    });\n  }\n}\n\nexport { PassthroughFilter };\n//# sourceMappingURL=PassthroughFilter.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { PassthroughFilter } from './defaults/passthrough/PassthroughFilter.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n    /** The first enabled filter index in the current filter list. */\n    this.firstEnabledIndex = -1;\n    /** The last enabled filter index in the current filter list. */\n    this.lastEnabledIndex = -1;\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();\n    this._setupBindGroupsAndRender(filterToApply, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.orig.width,\n      1 / sprite.texture.orig.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this._passthroughFilter?.destroy(true);\n    this._passthroughFilter = null;\n  }\n  _getPassthroughFilter() {\n    this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());\n    return this._passthroughFilter;\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    const firstEnabled = filterData.firstEnabledIndex;\n    const lastEnabled = filterData.lastEnabledIndex;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (firstEnabled === lastEnabled) {\n      filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      for (let i = firstEnabled; i < lastEnabled; i++) {\n        const filter = filters[i];\n        if (!filter.enabled)\n          continue;\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    let firstEnabledIndex = -1;\n    let lastEnabledIndex = -1;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (!filter.enabled)\n        continue;\n      if (firstEnabledIndex === -1)\n        firstEnabledIndex = i;\n      lastEnabledIndex = i;\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = true;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n    filterData.firstEnabledIndex = firstEnabledIndex;\n    filterData.lastEnabledIndex = lastEnabledIndex;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 0) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      clipToViewport: false,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["FilterEffect","constructor","this","pipe","priority","destroy","i","filters","length","filterArea","_Filter","Shader","options","super","defaultOptions","enabled","_state","State","for2d","blendMode","padding","antialias","resolution","blendRequired","clipToViewport","addResource","apply","filterManager","input","output","clearMode","applyFilter","value","from","gpu","gl","rest","gpuProgram","glProgram","GpuProgram","GlProgram","Filter","vertex","source","_AlphaFilter","entryPoint","fragment","name","alpha","resources","alphaUniforms","UniformGroup","uAlpha","type","uniforms","AlphaFilter","GAUSSIAN_VALUES","fragTemplate","join","generateBlurGlProgram","horizontal","kernelSize","x","halfLength","Math","ceil","template","vertSource","blurLoop","blur","replace","toString","generateBlurVertSource","kernel","fragSource","generateBlurFragSource","_BlurFilterPass","blurStructSource","blurOutSource","blurSamplingSource","kernelValue","blurStruct","blurOut","blurSampling","finalSource","generateBlurProgram","blurUniforms","uStrength","_quality","quality","strength","_uniforms","passes","tempTexture","TexturePool","getSameSizeTexture","flip","flop","blend","shouldClear","renderer","RendererType","WEBGPU","temp","returnTexture","abs","BlurFilterPass","BlurFilter","args","deprecation","v8_0_0","strengthX","strengthY","compatibleRenderers","BOTH","_repeatEdgePixels","blurXFilter","blurYFilter","repeatEdgePixels","xStrength","yStrength","updatePadding","max","Error","blurX","blurY","PassthroughFilter","FilterPipe","_renderer","push","filterEffect","container","instructionSet","renderPipes","batch","break","add","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterData","skip","inputTexture","backTexture","bounds","Bounds","outputRenderSurface","globalFrame","y","width","height","firstEnabledIndex","lastEnabledIndex","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderTarget","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","every","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","offsetY","minX","minY","_calculateGlobalFrame","_setupFilterTextures","generateFilteredTexture","texture","addRect","frame","rectangle","getOptimalTexture","Texture","EMPTY","finishRenderPass","_applyFiltersToTexture","outputTexture","alphaMode","_popFilterData","globalUniforms","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","_resolution","floor","copyToTexture","clear","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","filterToApply","_getPassthroughFilter","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","set","_source","worldTransform","copyTo","Matrix","shared","renderGroup","parentRenderGroup","cacheToLocalTransform","prepend","invert","scale","orig","translate","anchor","_passthroughFilter","uniformBatch","batchUniforms","getUboResource","setResource","style","groups","encoder","draw","geometry","shader","state","topology","WEBGL","getRenderTarget","bind","sourceWidth","sourceHeight","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","resource","isRoot","update","currentIndex","lastIndex","prevFilterData","renderables","getGlobalRenderableBounds","applyMatrix","getFastGlobalBounds","filterFrameTransform","firstEnabled","lastEnabled","t","viewPort","paddingMultiplier","Infinity","min","backBuffer","useBackBuffer","warn","fitBounds","pad","isPositive","index","WebGLSystem","WebGPUSystem","MaskFilter","textureMatrix","TextureMatrix","filterUniforms","uFilterMatrix","uMaskClamp","uClampFrame","uInverse","inverse","uMaskTexture","_textureMatrix","mapCoord","extensions"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}