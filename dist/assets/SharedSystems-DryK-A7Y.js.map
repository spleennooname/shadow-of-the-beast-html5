{"version":3,"file":"SharedSystems-DryK-A7Y.js","sources":["../../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","../../node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","../../node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","../../node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","../../node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","../../node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","../../node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","../../node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","../../node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","../../node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","../../node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","../../node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","../../node_modules/pixi.js/lib/utils/sayHello.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","../../node_modules/pixi.js/lib/utils/data/clean.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"],"sourcesContent":["var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      clipToViewport: false,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher({\n        maxTextures: this.renderer.limits.maxBatchableTextures\n      }));\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (renderSurface.source instanceof CanvasSource) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295,\n        offset: { x: 0, y: 0 }\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { multiplyColors } from './multiplyColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.textureNeedsUpdate)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture, true);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        const scaleMode = renderGroup.textureOptions.scaleMode ?? \"linear\";\n        const texture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        texture._source.style = new TextureStyle({ scaleMode });\n        renderGroup.texture = texture;\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture, true);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    const incoming = Color.shared.setValue(value);\n    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {\n      warn(\n        \"Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.\"\n      );\n    }\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._blendModeStack = [];\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = \"normal\";\n    this._isAdvanced = false;\n  }\n  /**\n   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n   * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n   * @param blendMode - The blend mode to activate.\n   * @param instructionSet - The instruction set being built.\n   */\n  pushBlendMode(renderable, blendMode, instructionSet) {\n    this._blendModeStack.push(blendMode);\n    this.setBlendMode(renderable, blendMode, instructionSet);\n  }\n  /**\n   * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  popBlendMode(instructionSet) {\n    this._blendModeStack.pop();\n    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? \"normal\";\n    this.setBlendMode(null, blendMode, instructionSet);\n  }\n  /**\n   * Ensure a blend mode switch is added to the instruction set when the mode changes.\n   * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n   * rendered within a single filter pass.\n   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n   * @param blendMode - The target blend mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    const isRenderGroup = renderable instanceof RenderGroup;\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced && renderable && !isRenderGroup) {\n        this._renderableList?.push(renderable);\n      }\n      return;\n    }\n    if (this._isAdvanced)\n      this._endAdvancedBlendMode(instructionSet);\n    this._activeBlendMode = blendMode;\n    if (!renderable)\n      return;\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced)\n      this._beginAdvancedBlendMode(renderable, instructionSet);\n  }\n  _beginAdvancedBlendMode(renderable, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    const filterEffect = this._ensureFilterEffect(blendMode);\n    const isRenderGroup = renderable instanceof RenderGroup;\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      filterEffect,\n      renderables: isRenderGroup ? null : [renderable],\n      container: isRenderGroup ? renderable.root : null,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _ensureFilterEffect(blendMode) {\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    return filterEffect;\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._isAdvanced = false;\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   */\n  buildEnd(instructionSet) {\n    if (!this._isAdvanced)\n      return;\n    this._endAdvancedBlendMode(instructionSet);\n  }\n  /** @internal */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Creates an IImage from a display object or texture.\n   * @param options - Options for creating the image, or the target to extract\n   * @returns Promise that resolves with the generated IImage\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const image = await renderer.extract.image(sprite);\n   * document.body.appendChild(image);\n   *\n   * // Advanced usage with options\n   * const image = await renderer.extract.image({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2,\n   *     clearColor: '#ff0000',\n   *     antialias: true\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const image = await renderer.extract.image(texture);\n   * ```\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.base64} For base64 string output\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ImageLike} For the image interface\n   * @category rendering\n   */\n  async image(options) {\n    const image = DOMAdapter.get().createImage();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Converts the target into a base64 encoded string.\n   *\n   * This method works by first creating\n   * a canvas using `Extract.canvas` and then converting it to a base64 string.\n   * @param options - The options for creating the base64 string, or the target to extract\n   * @returns Promise that resolves with the base64 encoded string\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const base64 = await renderer.extract.base64(sprite);\n   * console.log(base64); // data:image/png;base64,...\n   *\n   * // Advanced usage with options\n   * const base64 = await renderer.extract.base64({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2\n   * });\n   * ```\n   * @throws Will throw an error if the platform doesn't support any of:\n   * - ICanvas.toDataURL\n   * - ICanvas.toBlob\n   * - ICanvas.convertToBlob\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @category rendering\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders the target to it and returns it.\n   * This method is useful for creating static images or when you need direct canvas access.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns A Canvas element with the texture rendered on\n   * @example\n   * ```ts\n   * // Basic canvas extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const canvas = renderer.extract.canvas(sprite);\n   * document.body.appendChild(canvas);\n   *\n   * // Extract with custom region\n   * const canvas = renderer.extract.canvas({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const canvas = renderer.extract.canvas({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const canvas = renderer.extract.canvas(texture);\n   *\n   * // Extract with anti-aliasing\n   * const canvas = renderer.extract.canvas({\n   *     target: graphics,\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n   * with integer values between 0 and 255 (inclusive).\n   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n   * @example\n   * ```ts\n   * // Basic pixel extraction\n   * const sprite = new Sprite(texture);\n   * const pixels = renderer.extract.pixels(sprite);\n   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n   *\n   * // Extract with custom region\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     resolution: 2\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For image output\n   * @category rendering\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Creates a texture from a display object or existing texture.\n   *\n   * This is useful for creating\n   * reusable textures from rendered content or making copies of existing textures.\n   * > [!NOTE] The returned texture should be destroyed when no longer needed\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns A new texture containing the extracted content\n   * @example\n   * ```ts\n   * // Basic texture extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const extractedTexture = renderer.extract.texture(sprite);\n   *\n   * // Extract with custom region\n   * const regionTexture = renderer.extract.texture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const hiResTexture = renderer.extract.texture({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Create a new sprite from extracted texture\n   * const newSprite = new Sprite(\n   *     renderer.extract.texture({\n   *         target: graphics,\n   *         antialias: true\n   *     })\n   * );\n   *\n   * // Clean up when done\n   * extractedTexture.destroy(true);\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link Texture} For texture management\n   * @see {@link GenerateTextureSystem} For texture generation\n   * @category rendering\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Extracts and downloads content from the renderer as an image file.\n   * This is a convenient way to save screenshots or export rendered content.\n   * > [!NOTE] The download will use PNG format regardless of the filename extension\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   * @example\n   * ```ts\n   * // Basic download with default filename\n   * const sprite = new Sprite(texture);\n   * renderer.extract.download(sprite); // Downloads as 'image.png'\n   *\n   * // Download with custom filename\n   * renderer.extract.download({\n   *     target: sprite,\n   *     filename: 'screenshot.png'\n   * });\n   *\n   * // Download with custom region\n   * renderer.extract.download({\n   *     target: container,\n   *     filename: 'region.png',\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Download with high resolution and background\n   * renderer.extract.download({\n   *     target: stage,\n   *     filename: 'hd-screenshot.png',\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Download with anti-aliasing\n   * renderer.extract.download({\n   *     target: graphics,\n   *     filename: 'smooth.png',\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractDownloadOptions} For detailed options\n   * @see {@link ExtractSystem.image} For creating images without download\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * The image will be displayed in the browser's console using CSS background images.\n   * @param options - The options for logging the image, or the target to log\n   * @param options.width - The width of the logged image preview in the console (in pixels)\n   * @example\n   * ```ts\n   * // Basic usage\n   * const sprite = new Sprite(texture);\n   * renderer.extract.log(sprite);\n   * ```\n   * @see {@link ExtractSystem.canvas} For getting raw canvas output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   * @advanced\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/**\n * Default options for image extraction.\n * @example\n * ```ts\n * // Customize default options\n * ExtractSystem.defaultImageOptions.format = 'webp';\n * ExtractSystem.defaultImageOptions.quality = 0.8;\n *\n * // Use defaults\n * const image = await renderer.extract.image(sprite);\n * ```\n */\n_ExtractSystem.defaultImageOptions = {\n  format: \"png\",\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  static create(options) {\n    return new RenderTexture({\n      source: new TextureSource(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Creates a texture from a display object that can be used for creating sprites and other textures.\n   * This is particularly useful for optimizing performance when a complex container needs to be reused.\n   * @param options - Generate texture options or a container to convert to texture\n   * @returns A new RenderTexture containing the rendered display object\n   * @example\n   * ```ts\n   * // Basic usage with a container\n   * const container = new Container();\n   * container.addChild(\n   *     new Graphics()\n   *         .circle(0, 0, 50)\n   *         .fill('red')\n   * );\n   *\n   * const texture = renderer.textureGenerator.generateTexture(container);\n   *\n   * // Advanced usage with options\n   * const texture = renderer.textureGenerator.generateTexture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n   *     resolution: 2,                        // High DPI\n   *     clearColor: '#ff0000',               // Red background\n   *     antialias: true                      // Smooth edges\n   * });\n   *\n   * // Create a sprite from the generated texture\n   * const sprite = new Sprite(texture);\n   *\n   * // Clean up when done\n   * texture.destroy(true);\n   * ```\n   * @see {@link GenerateTextureOptions} For detailed texture generation options\n   * @see {@link RenderTexture} For the type of texture created\n   * @category rendering\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n    this._globalUniformDataStack.length = 0;\n    this._uniformsPool.length = 0;\n    this._activeUniforms.length = 0;\n    this._bindGroupPool.length = 0;\n    this._activeBindGroups.length = 0;\n    this._currentGlobalUniformData = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../../utils/data/clean.mjs';\n\n\"use strict\";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n"],"names":["source","MaskFilter","Filter","constructor","options","sprite","rest","textureMatrix","TextureMatrix","texture","filterUniforms","UniformGroup","uFilterMatrix","value","Matrix","type","uMaskClamp","uClampFrame","uAlpha","uInverse","inverse","super","gpuProgram","GpuProgram","from","vertex","entryPoint","fragment","glProgram","GlProgram","name","clipToViewport","resources","uMaskTexture","this","_textureMatrix","uniforms","apply","filterManager","input","output","clearMode","calculateSpriteMatrix","prepend","mapCoord","applyFilter","_BatcherPipe","renderer","adaptor","state","State","for2d","_batchersByInstructionSet","Object","create","_activeBatches","_adaptor","init","getBatcher","_availableBatchers","buildStart","instructionSet","batchers","uid","default","DefaultBatcher","maxTextures","limits","maxBatchableTextures","_activeBatch","i","begin","addToBatch","batchableObject","batcherName","break","batch","add","buildEnd","batches","geometry","indexBuffer","setDataWithSize","indexSize","buffers","attributeBuffer","float32View","attributeSize","upload","batcher","dirty","update","execute","action","shader","start","destroy","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","BatcherPipe","extensions","handleByMap","Batcher","textureBit","header","main","textureBitGl","tempBounds","Bounds","AlphaMaskEffect","FilterEffect","filters","Sprite","Texture","EMPTY","resolution","antialias","AlphaMaskPipe","_activeMaskStage","_renderer","push","mask","maskedContainer","renderPipes","renderPipeId","_maskOptions","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectRenderables","pop","_maskedContainer","instruction","renderMask","filterEffect","BigPool","get","measurable","bounds","getGlobalBounds","ceil","colorTextureSource","renderTarget","colorTexture","filterTexture","TexturePool","getOptimalTexture","width","height","_resolution","globalUniforms","offset","worldColor","worldTransform","tx","minX","ty","minY","maskData","length","RendererType","WEBGL","finishRenderPass","filter","container","returnTexture","return","ColorMaskPipe","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","colorMask","_mask","setMask","StencilMaskPipe","_maskStackHash","_maskHash","WeakMap","_a","effect","blendMode","setBlendMode","has","set","instructionsStart","instructionsLength","instructionSize","renderTargetUid","instructions","maskStackIndex","ensureDepthStencil","stencil","setStencilMode","STENCIL_MODES","RENDERING_MASK_ADD","INVERSE_MASK_ACTIVE","MASK_ACTIVE","RENDERING_MASK_REMOVE","clear","CLEAR","STENCIL","DISABLED","ensureAttributes","extractedData","attributes","attribute","attributeData","format","instance","warn","tempStride","tempStart","j","buffer","getAttributeInfoFromFormat","stride","ensureStartAndStride","GpuStencilModesToPixi","NONE","stencilWriteMask","stencilReadMask","stencilFront","compare","passOp","stencilBack","UboSystem","_syncFunctionHash","_systemCheck","unsafeEvalSupported","Error","ensureUniformGroup","uniformGroup","uniformData","getUniformGroupData","Buffer","data","Float32Array","layout","size","usage","BufferUsage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","map","createUboElements","syncFunction","_generateUboSync","uboElements","generateUboSync","syncUniformGroup","uniformGroupData","dataInt32","updateUniformGroup","isStatic","_dirtyId","synced","uniformParsers","test","a","ubo","uniform","x","red","createUboSyncFunction","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","template","fragmentSrc","join","Function","loopMatrix","col","row","uboSyncFunctionsSTD40","f32","i32","uboSyncFunctionsWGSL","RenderTargetSystem","rootViewPort","Rectangle","viewport","onRenderTargetChange","SystemRunner","projectionMatrix","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","_renderTargetStack","renderableGC","addManagedHash","renderStart","target","clearColor","frame","copyFrom","rootRenderTarget","renderingToScreen","resource","globalThis","HTMLCanvasElement","document","body","contains","isRenderingToScreen","prerender","postrender","bind","renderSurface","getRenderTarget","didChange","gpuRenderTarget","getGpuRenderTarget","pixelWidth","pixelHeight","resizeGpuRenderTarget","y","pm","flipY","sign","identity","d","calculateProjection","isRoot","startRenderPass","emit","ALL","contextChange","currentRenderTargetData","isTexture","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","Math","min","forEach","key","CanvasSource","getCanvasTexture","RenderTarget","TextureSource","colorTextures","once","delete","destroyGpuRenderTarget","initGpuRenderTarget","resetState","BufferResource","EventEmitter","_resourceType","_touched","_resourceId","_bufferResource","destroyed","on","onBufferChange","destroyBuffer","CustomRenderPipe","updateRenderable","destroyRenderable","validateRenderable","addRenderable","isRenderable","render","executeInstructions","renderGroup","tempMatrix","RenderGroupPipe","addRenderGroup","isCachedAsTexture","_addRenderableCacheAsTexture","_addRenderableDirect","_executeCacheAsTexture","_executeDirect","_batchableRenderGroup","batchableRenderGroup","BatchableSprite","renderable","root","transform","relativeGroupTransform","_textureBounds","pushBlendMode","groupBlendMode","popBlendMode","textureNeedsUpdate","worldTransformMatrix","translate","_batcher","updateElement","inverseParentTextureTransform","worldColorAlpha","clearList","list","index","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","updateChildRenderGroups","worldAlpha","renderGroupParent","appendFrom","multiplyColors","groupColor","groupAlpha","localTransform","localColor","localAlpha","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","Number","childrenAtDepth","child","parentRenderGroup","relativeRenderGroupDepth","updateTransformAndChildren","renderGroupChildren","updateFlags","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","children","structureDidChange","groupColorAlpha","localBlendMode","globalDisplayStatus","localDisplayStatus","RenderGroupSystem","originalLocalTransform","_updateCachedRenderGroups","_updateRenderGroups","uniformBatch","renderEnd","closestCacheAsTexture","_parentCacheAsTextureRenderGroup","invalidateMatrices","getLocalBounds","lastTexture","textureOptions","view","scaleMode","_source","style","TextureStyle","runOnRender","childrenRenderablesToUpdate","rebuildRequired","validateRenderables","_buildInstructions","_updateRenderables","didViewUpdate","rendererOrPipes","reset","sortableChildren","sortChildren","collectRenderablesWithEffects","WebGLSystem","WebGPUSystem","CanvasSystem","SpritePipe","gpuSprite","_getGpuSprite","_updateBatchableSprite","checkAndUpdateTexture","_texture","batchableSprite","visualBounds","_gpuData","_initGPUSprite","groupTransform","roundPixels","_roundPixels","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","defaultOptions","background","backgroundColor","backgroundAlpha","setAlpha","shared","setValue","colorRgba","toArray","priority","BackgroundSystem","BLEND_MODE_FILTERS","handle","BlendMode","ref","BlendModePipe","_blendModeStack","_isAdvanced","_filterHash","runners","_activeBlendMode","isRenderGroup","RenderGroup","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","_ensureFilterEffect","renderables","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","image","DOMAdapter","createImage","src","base64","defaultImageOptions","quality","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","link","createElement","filename","href","appendChild","click","removeChild","log","ExtractSystem","RenderTexture","resize","tempRect","noColor","GenerateTextureSystem","textureSourceOptions","Array","isArray","region","copyTo","rectangle","max","updateMipmaps","GlobalUniformSystem","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","currentGlobalUniformData","Point","globalUniformData","bindGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","color32BitToUniform","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","SchedulerSystem","_tasks","_offset","Ticker","system","_update","repeat","func","duration","useOffset","id","performance","now","last","cancel","splice","task","elapsed","remove","saidHello","HelloSystem","hello","context","webGLVersion","getNavigator","userAgent","toLowerCase","indexOf","args","VERSION","console","sayHello","cleanHash","hash","clean","cleanHash2","cleanArray","arr","renderableGCTick","_RenderableGCSystem","_managedRenderables","_managedHashes","_managedArrays","maxUnusedTime","renderableGCMaxUnusedTime","_frequency","renderableGCFrequency","enabled","renderableGCActive","_handler","scheduler","run","_hashHandler","_arrayHandler","array","addManagedArray","_now","gcTick","_updateInstructionGCTick","_lastUsed","_removeRenderable","managedRenderables","currentTick","rp","off","RenderableGCSystem","_TextureGCSystem","count","checkCount","checkCountMax","textureGCCheckCountMax","maxIdle","textureGCAMaxIdle","textureGCMaxIdle","active","textureGCActive","managedTextures","autoGarbageCollect","unload","SharedSystems","ViewSystem","RendererInitHook","SharedRenderPipes"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]}