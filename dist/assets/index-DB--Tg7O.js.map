{"version":3,"mappings":"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","names":["pixiFilters","loadFilters","async","__vitePreload","import","__VITE_PRELOAD__","GAME_CONFIG","BASE_SPRITES","BASE_ASSETS","constructor","this","app","parallaxLayers","character","gameSpeed","crtFilter","bloomFilter","audio","resizeObserver","resizeTimeout","init","PIXI.Application","width","height","backgroundColor","antialias","preference","resizeTo","window","ticker","maxFPS","minFPS","document","body","appendChild","canvas","setupResize","loadAssets","createScene","add","update","loadingEl","getElementById","style","display","resize","ResizeObserver","entries","clearTimeout","setTimeout","observe","addEventListener","screenWidth","innerWidth","screenHeight","innerHeight","scaleX","scaleY","scale","Math","min","stage","set","position","renderer","time","performance","now","assetManifest","aarbon","sky","moon","barriere","erba0","erba1","erba2","erba3","erba4","nuv0","nuv1","nuv2","nuv3","nuv4","montagne","alias","src","Object","length","PIXI.Assets","load","keys","error","loadAudio","Audio","loop","volume","Promise","resolve","reject","once","requiredAssets","asset","get","PIXI.TilingSprite","texture","tilePosition","x","addChild","sprite","speed","PIXI.Sprite","blendMode","filters","BloomFilter","blur","quality","strength","threshold","name","y","forEach","layer","textureHeight","kawaseBlur","KawaseBlurFilter","montagneTexture","barriereTexture","createCharacter","startAudio","setupCRTEffect","playPromise","play","then","catch","removeEventListener","CRTFilter","curvature","lineWidth","lineContrast","verticalLine","noise","noiseSize","seed","random","vignetting","vignettingAlpha","vignettingBlur","alpha","frames","i","rect","PIXI.Rectangle","frame","PIXI.Texture","source","push","PIXI.AnimatedSprite","animationSpeed","autoUpdate","deltaTime","values","textContent","color"],"ignoreList":[],"sources":["../../main.js"],"sourcesContent":["import * as PIXI from 'pixi.js';\n\n/**\n * Dynamically import filters for better code splitting\n */\nlet pixiFilters = null;\nconst loadFilters = async () => {\n    if (!pixiFilters) {\n        pixiFilters = await import('pixi-filters');\n    }\n    return pixiFilters;\n};\n\n/**\n * Shadow of the Beast HTML5 - PIXI.js version\n * Migration from custom PandaJS engine to PIXI.js\n */\n\n\n// Game configuration\nconst GAME_CONFIG = {\n    width: 640,\n    height: 400,\n    backgroundColor: '#000000'\n};\n\n// Asset paths - Vite serves public directory files at root path\nconst BASE_ASSETS = \"./\";\nconst BASE_SPRITES = BASE_ASSETS + \"sprites/1280x800/\";\n\n/**\n * Main Game Application class\n */\nclass ShadowOfTheBeast {\n    constructor() {\n        this.app = null;\n        this.parallaxLayers = {};\n        this.character = null;\n        this.gameSpeed = 200; // Increased base speed for faster scrolling\n        this.crtFilter = null; // CRT scanlines filter\n        this.bloomFilter = null; // Bloom filter for glow effects\n        this.audio = null; // Audio instance\n        this.resizeObserver = null; // ResizeObserver instance\n        this.resizeTimeout = null; // Debounce timeout for resize\n    }\n\n    /**\n     * Initialize the game\n     */\n    async init() {\n        // Create PIXI Application optimized for 60fps with fullscreen capability\n        this.app = new PIXI.Application();\n\n        await this.app.init({\n            width: GAME_CONFIG.width,\n            height: GAME_CONFIG.height,\n            backgroundColor: GAME_CONFIG.backgroundColor,\n            antialias: true,\n            preference: 'webgl2',\n            resizeTo: window // Enable auto-resize to window\n        });\n\n        // Configure ticker for 60fps\n        this.app.ticker.maxFPS = 60;\n        this.app.ticker.minFPS = 30;\n\n        // Add canvas to DOM\n        document.body.appendChild(this.app.canvas);\n\n        // Setup fullscreen resize system\n        this.setupResize();\n\n        // Load assets\n        await this.loadAssets();\n\n        // Create game scene\n        await this.createScene();\n\n        // Start game loop\n        this.app.ticker.add((ticker) => this.update(ticker));\n\n        // Hide loading message\n        const loadingEl = document.getElementById('loading');\n        if (loadingEl) {\n            loadingEl.style.display = 'none';\n        }\n    }\n\n    /**\n     * Setup fullscreen resize system using ResizeObserver\n     */\n    setupResize() {\n        // Calculate scale to fit screen while maintaining aspect ratio\n        this.resize();\n\n        // Use ResizeObserver for better performance than window resize events\n        if (window.ResizeObserver) {\n            this.resizeObserver = new ResizeObserver((entries) => {\n                // Debounce resize calls for performance\n                if (this.resizeTimeout) {\n                    clearTimeout(this.resizeTimeout);\n                }\n                this.resizeTimeout = setTimeout(() => {\n                    this.resize();\n                }, 16); // ~60fps\n            });\n            \n            // Observe document body for size changes\n            this.resizeObserver.observe(document.body);\n        } else {\n            // Fallback to window resize event for older browsers\n            window.addEventListener('resize', () => {\n                this.resize();\n            });\n        }\n    }\n\n    /**\n     * Handle window resize - scale game to fit screen\n     */\n    resize() {\n        const screenWidth = window.innerWidth;\n        const screenHeight = window.innerHeight;\n        \n        // Calculate scale factors\n        const scaleX = screenWidth / GAME_CONFIG.width;\n        const scaleY = screenHeight / GAME_CONFIG.height;\n        \n        // Use the smaller scale to maintain aspect ratio\n        const scale = Math.min(scaleX, scaleY);\n        \n        // Apply scaling to the main stage\n        this.app.stage.scale.set(scale);\n        \n        // Center the game on screen\n        this.app.stage.position.set(\n            (screenWidth - GAME_CONFIG.width * scale) / 2,\n            (screenHeight - GAME_CONFIG.height * scale) / 2\n        );\n        \n        // Update renderer size\n        this.app.renderer.resize(screenWidth, screenHeight);\n        \n        // Update CRT filter time for animation\n        if (this.crtFilter) {\n            this.crtFilter.time = performance.now() * 0.001;\n        }\n    }\n\n    /**\n     * Load all game assets including audio\n     */\n    async loadAssets() {\n        const assetManifest = {\n            'aarbon': BASE_SPRITES + 'aarbonRun@2x.png',\n            'sky': BASE_SPRITES + 'sky@2x.png',\n            'moon': BASE_SPRITES + 'luna@2x.png',\n            'barriere': BASE_SPRITES + 'barriere@2x.png',\n            'erba0': BASE_SPRITES + 'herbe0@2x.png',\n            'erba1': BASE_SPRITES + 'herbe1@2x.png',\n            'erba2': BASE_SPRITES + 'herbe2@2x.png',\n            'erba3': BASE_SPRITES + 'herbe3@2x.png',\n            'erba4': BASE_SPRITES + 'herbe4@2x.png',\n            'nuv0': BASE_SPRITES + 'nuages0@2x.png',\n            'nuv1': BASE_SPRITES + 'nuages1@2x.png',\n            'nuv2': BASE_SPRITES + 'nuages2@2x.png',\n            'nuv3': BASE_SPRITES + 'nuages3@2x.png',\n            'nuv4': BASE_SPRITES + 'nuages4@2x.png',\n            'montagne': BASE_SPRITES + 'montagnes@2x.png'\n        };\n\n        // Validate and add assets to loader\n        for (const [alias, src] of Object.entries(assetManifest)) {\n            if (typeof src === 'string' && src.length > 0) {\n                PIXI.Assets.add({ alias, src });\n            } else {\n                console.warn(`Invalid asset src for ${alias}:`, src);\n            }\n        }\n\n        // Load all assets\n        try {\n            await PIXI.Assets.load(Object.keys(assetManifest));\n            console.log('Assets loaded successfully');\n        } catch (error) {\n            console.error('Error loading assets:', error);\n            throw error;\n        }\n\n        // Load and setup audio separately using HTML5 Audio API\n        await this.loadAudio();\n    }\n\n    /**\n     * Load and setup game audio\n     */\n    async loadAudio() {\n        try {\n            this.audio = new Audio('./audio/sotb.mp3');\n            this.audio.loop = true;\n            this.audio.volume = 0.7;\n            \n            // Wait for audio to be ready\n            await new Promise((resolve, reject) => {\n                this.audio.addEventListener('canplaythrough', resolve, { once: true });\n                this.audio.addEventListener('error', reject, { once: true });\n                this.audio.load();\n            });\n            \n            console.log('Audio loaded successfully');\n        } catch (error) {\n            console.warn('Audio loading failed:', error);\n        }\n    }\n\n    /**\n     * Create the main game scene with parallax layers\n     */\n    async createScene() {\n        // Verify critical assets are loaded\n        const requiredAssets = ['sky', 'moon', 'aarbon', 'montagne', 'barriere'];\n        for (const asset of requiredAssets) {\n            const texture = PIXI.Assets.get(asset);\n            if (!texture) {\n                console.error(`Asset '${asset}' not loaded or not found`);\n                return;\n            }\n        }\n\n        // Sky background - ensure full coverage without Y repeat\n        const sky = new PIXI.TilingSprite({ \n            texture: PIXI.Assets.get('sky'), \n            width: GAME_CONFIG.width * 2, // X repeat for scrolling\n            height: GAME_CONFIG.height * 0.5     // Full height - no Y repeat\n        });\n        sky.tilePosition.x = 0;\n        sky.position.set(-GAME_CONFIG.width * 0.5, 0); // Center the wider sprite\n        this.app.stage.addChild(sky);\n        this.parallaxLayers.sky = { sprite: sky, speed: 60 }; // Increased base speed for continuity\n\n        // Moon with bloom effect\n        const moon = new PIXI.Sprite(PIXI.Assets.get('moon'));\n        moon.position.set(500, 10);\n        moon.blendMode = 'lighten'; // PIXI equivalent of 'lighten'\n        \n        // Create BloomFilter for stage-wide glow effect (loaded dynamically)\n        const filters = await loadFilters();\n        this.bloomFilter = new filters.BloomFilter({\n            blur: 1.5,\n            quality: 4,\n            strength: 1,\n            threshold: 1\n        });\n        \n        this.app.stage.addChild(moon);\n\n        // Cloud layers - INVERTED: top faster, bottom slower (decreasing speed from top to bottom)\n        const cloudLayers = [\n            { name: 'nuv0', y: 0, speed: 160, blur: 0 },      // Top - 360 px/s (fastest, no blur - closest)\n            { name: 'nuv1', y: 42, speed: 60, blur: 0.5 },    // 260 px/s (-100 like grass pattern, slight blur)\n            { name: 'nuv2', y: 102, speed: -20, blur: 1 },    // 180 px/s (-80, medium blur)\n            { name: 'nuv3', y: 140, speed: -80, blur: 1.5 },  // 120 px/s (-60, more blur - distant)\n            { name: 'nuv4', y: 150, speed: -140, blur: 2 }    // Bottom - 60 px/s (slowest, most blur - farthest)\n        ];\n\n        cloudLayers.forEach((layer) => {\n            // Calculate appropriate height based on texture to avoid Y repeats\n            const texture = PIXI.Assets.get(layer.name);\n            const textureHeight = texture.height;\n            \n            const sprite = new PIXI.TilingSprite({\n                texture: texture,\n                width: GAME_CONFIG.width * 2, // Make wider for seamless scrolling\n                height: textureHeight\n            });\n            sprite.position.set(-GAME_CONFIG.width * 0.5, layer.y); // Center wider sprite\n            sprite.tilePosition.x = 0; // Initialize tilePosition\n            \n            // Apply KawaseBlurFilter for depth effect - more blur = more distant\n            if (layer.blur > 0) {\n                const kawaseBlur = new filters.KawaseBlurFilter({\n                    blur: layer.blur,\n                    quality: 3\n                });\n                sprite.filters = [kawaseBlur];\n            }\n            \n            this.app.stage.addChild(sprite);\n\n            this.parallaxLayers[layer.name] = { sprite, speed: this.gameSpeed + layer.speed };\n        });\n\n        // Mountains\n        const montagneTexture = PIXI.Assets.get('montagne');\n        const montagne = new PIXI.TilingSprite({\n            texture: montagneTexture,\n            width: GAME_CONFIG.width * 2, // Make wider for seamless scrolling\n        });\n        montagne.position.set(-GAME_CONFIG.width * 0.5, 194); // Center wider sprite\n        montagne.tilePosition.x = 0; // Initialize tilePosition\n       \n        this.app.stage.addChild(montagne);\n\n        this.parallaxLayers.montagne = { sprite: montagne, speed: this.gameSpeed * 0.6 }; // Mountains - medium speed\n\n        // Grass layers - CORRECT parallax: layers closer to barrier (bottom/higher Y) = faster\n        const grassLayers = [\n            { name: 'erba4', y: 378, speed: this.gameSpeed * 2.5 }, // Closest to barrier (bottom) = fastest (250 px/s)\n            { name: 'erba3', y: 364, speed: this.gameSpeed * 2.0 }, // (200 px/s)\n            { name: 'erba2', y: 350, speed: this.gameSpeed * 1.6 }, // (160 px/s)  \n            { name: 'erba1', y: 344, speed: this.gameSpeed * 1.3 }, // (130 px/s)\n            { name: 'erba0', y: 340, speed: this.gameSpeed * 1.0 }  // Farthest from barrier (top) = slowest (100 px/s)\n        ];\n\n        grassLayers.forEach((layer) => {\n            const texture = PIXI.Assets.get(layer.name);\n            const sprite = new PIXI.TilingSprite({\n                texture: texture,\n                width: GAME_CONFIG.width * 2, // Make wider for seamless scrolling\n                height: texture.height // Use exact texture height to prevent Y repeat\n            });\n            sprite.position.set(-GAME_CONFIG.width * 0.5, layer.y); // Center wider sprite\n            sprite.tilePosition.x = 0; // Initialize tilePosition\n            this.app.stage.addChild(sprite);\n            this.parallaxLayers[layer.name] = { \n                sprite, \n                speed: layer.speed // Use specific speed for each layer\n            };\n        });\n\n        // Barrier\n        const barriereTexture = PIXI.Assets.get('barriere');\n        const barriere = new PIXI.TilingSprite({\n            texture: barriereTexture,\n            width: GAME_CONFIG.width * 2, // Make wider for seamless scrolling\n            height: barriereTexture.height // Use exact texture height to prevent Y repeat\n        });\n        barriere.position.set(-GAME_CONFIG.width * 0.5, 358); // Center wider sprite\n        barriere.tilePosition.x = 0; // Initialize tilePosition\n        this.app.stage.addChild(barriere);\n        this.parallaxLayers.barriere = { sprite: barriere, speed: this.gameSpeed * 1.2 }; // Barrier - fast\n\n        // Character animation\n        this.createCharacter();\n        \n        // Start audio playback\n        this.startAudio();\n        \n        // Apply CRT scanlines filter\n        await this.setupCRTEffect();\n    }\n\n    /**\n     * Start audio playback\n     */\n    startAudio() {\n        if (this.audio) {\n            // Modern browsers require user interaction to play audio\n            // Try to play automatically, fallback to user interaction\n            const playPromise = this.audio.play();\n            \n            if (playPromise !== undefined) {\n                playPromise.then(() => {\n                    console.log('Audio playback started');\n                }).catch(() => {\n                    console.log('Auto-play prevented. Adding click listener for audio start.');\n                    // Add click listener to start audio on first user interaction\n                    const startAudio = () => {\n                        this.audio.play();\n                        document.removeEventListener('click', startAudio);\n                        document.removeEventListener('keydown', startAudio);\n                    };\n                    document.addEventListener('click', startAudio);\n                    document.addEventListener('keydown', startAudio);\n                });\n            }\n        }\n    }\n\n    /**\n     * Setup CRT scanlines effect and bloom filter\n     */\n    async setupCRTEffect() {\n        // Load filters dynamically\n        const filters = await loadFilters();\n        \n        // Create CRT filter from pixi-filters\n        this.crtFilter = new filters.CRTFilter({\n            curvature: 1.0,\n            lineWidth: 3.0,\n            lineContrast: 0.3,\n            verticalLine: false,\n            noise: 0.25,\n            noiseSize: 1.0,\n            seed: Math.random(),\n            vignetting: 0.2,\n            vignettingAlpha: 0.4,\n            vignettingBlur: 0.8,\n            time: 0.5,\n            alpha: 0.1\n        });\n        \n        // Apply both bloom and CRT filters to the entire stage\n        this.app.stage.filters = [this.bloomFilter, this.crtFilter];\n    }\n\n    /**\n     * Create animated character sprite\n     */\n    createCharacter() {\n        const texture = PIXI.Assets.get('aarbon');\n        const frameWidth = 78;\n        const frameHeight = 100;\n        const frames = [];\n\n        // Create animation frames\n        for (let i = 0; i < 6; i++) {\n            const rect = new PIXI.Rectangle(i * frameWidth, 0, frameWidth, frameHeight);\n            const frame = new PIXI.Texture({ source: texture.source, frame: rect });\n            frames.push(frame);\n        }\n\n        // Create animated sprite with PIXI v8 syntax\n        this.character = new PIXI.AnimatedSprite(frames);\n        this.character.position.set(GAME_CONFIG.width / 2 - 50, 250);\n        this.character.animationSpeed = 0.2; // Optimized for 60fps (12fps animation)\n        this.character.loop = true;\n        this.character.autoUpdate = true;\n        this.character.play();\n        this.app.stage.addChild(this.character);\n        \n    }\n\n    /**\n     * Game update loop\n     * @param {Ticker} ticker - PIXI Ticker object\n     */\n    update(ticker) {\n        // Get delta from ticker object (PIXI v8 syntax)\n        // ticker.deltaTime is the ratio between target FPS and actual FPS\n        // For 60fps: deltaTime = 1.0 when running at 60fps, >1.0 when slower, <1.0 when faster\n        const deltaTime = ticker.deltaTime / 60; // Convert to frame-independent time (seconds)\n\n        // Update parallax layers with frame-independent movement\n        Object.values(this.parallaxLayers).forEach(layer => {\n            if (layer.speed > 0) {\n                // Speed is in pixels per second, deltaTime normalizes for consistent movement at any fps\n                layer.sprite.tilePosition.x -= layer.speed * deltaTime;\n            }\n        });\n        \n        // Update CRT filter animation\n        if (this.crtFilter) {\n            this.crtFilter.time = performance.now() * 0.001;\n        }\n    }\n}\n\n// Initialize and start the game\nconst game = new ShadowOfTheBeast();\ngame.init().catch(error => {\n    console.error('Failed to initialize game:', error);\n    const loadingEl = document.getElementById('loading');\n    if (loadingEl) {\n        loadingEl.textContent = 'Error loading game. Please check console for details.';\n        loadingEl.style.color = '#ff6b6b';\n    }\n});"],"file":"assets/index-DB--Tg7O.js"}