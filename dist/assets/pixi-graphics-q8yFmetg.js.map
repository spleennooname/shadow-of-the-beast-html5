{"version":3,"file":"pixi-graphics-q8yFmetg.js","sources":["../../node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/const.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","../../node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs","../../node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","../../node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","../../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","../../node_modules/pixi.js/lib/scene/graphics/init.mjs"],"sourcesContent":["import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation } from '../../../../utils/logging/deprecation.mjs';\nimport { definedProps } from '../../../container/utils/definedProps.mjs';\n\n\"use strict\";\nconst emptyColorStops = [{ offset: 0, color: \"white\" }, { offset: 1, color: \"black\" }];\nconst _FillGradient = class _FillGradient {\n  constructor(...args) {\n    /**\n     * Unique identifier for this gradient instance\n     * @internal\n     */\n    this.uid = uid(\"fillGradient\");\n    /**\n     * Internal tick counter to track changes in the gradient.\n     * This is used to invalidate the gradient when the texture changes.\n     * @internal\n     */\n    this._tick = 0;\n    /** Type of gradient - currently only supports 'linear' */\n    this.type = \"linear\";\n    /** Array of color stops defining the gradient */\n    this.colorStops = [];\n    let options = ensureGradientOptions(args);\n    const defaults = options.type === \"radial\" ? _FillGradient.defaultRadialOptions : _FillGradient.defaultLinearOptions;\n    options = { ...defaults, ...definedProps(options) };\n    this._textureSize = options.textureSize;\n    this._wrapMode = options.wrapMode;\n    if (options.type === \"radial\") {\n      this.center = options.center;\n      this.outerCenter = options.outerCenter ?? this.center;\n      this.innerRadius = options.innerRadius;\n      this.outerRadius = options.outerRadius;\n      this.scale = options.scale;\n      this.rotation = options.rotation;\n    } else {\n      this.start = options.start;\n      this.end = options.end;\n    }\n    this.textureSpace = options.textureSpace;\n    this.type = options.type;\n    options.colorStops.forEach((stop) => {\n      this.addColorStop(stop.offset, stop.color);\n    });\n  }\n  /**\n   * Adds a color stop to the gradient\n   * @param offset - Position of the stop (0-1)\n   * @param color - Color of the stop\n   * @returns This gradient instance for chaining\n   */\n  addColorStop(offset, color) {\n    this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n    return this;\n  }\n  /**\n   * Builds the internal texture and transform for the gradient.\n   * Called automatically when the gradient is first used.\n   * @internal\n   */\n  buildLinearGradient() {\n    if (this.texture)\n      return;\n    let { x: x0, y: y0 } = this.start;\n    let { x: x1, y: y1 } = this.end;\n    let dx = x1 - x0;\n    let dy = y1 - y0;\n    const flip = dx < 0 || dy < 0;\n    if (this._wrapMode === \"clamp-to-edge\") {\n      if (dx < 0) {\n        const temp = x0;\n        x0 = x1;\n        x1 = temp;\n        dx *= -1;\n      }\n      if (dy < 0) {\n        const temp = y0;\n        y0 = y1;\n        y1 = temp;\n        dy *= -1;\n      }\n    }\n    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n    const defaultSize = this._textureSize;\n    const { canvas, context } = getCanvas(defaultSize, 1);\n    const gradient = !flip ? context.createLinearGradient(0, 0, this._textureSize, 0) : context.createLinearGradient(this._textureSize, 0, 0, 0);\n    addColorStops(gradient, colorStops);\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, defaultSize, 1);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressMode: this._wrapMode\n      })\n    });\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    const m = new Matrix();\n    m.scale(dist / defaultSize, 1);\n    m.rotate(angle);\n    m.translate(x0, y0);\n    if (this.textureSpace === \"local\") {\n      m.scale(defaultSize, defaultSize);\n    }\n    this.transform = m;\n  }\n  /**\n   * Builds the internal texture and transform for the gradient.\n   * Called automatically when the gradient is first used.\n   * @internal\n   */\n  buildGradient() {\n    if (!this.texture)\n      this._tick++;\n    if (this.type === \"linear\") {\n      this.buildLinearGradient();\n    } else {\n      this.buildRadialGradient();\n    }\n  }\n  /**\n   * Builds the internal texture and transform for the radial gradient.\n   * Called automatically when the gradient is first used.\n   * @internal\n   */\n  buildRadialGradient() {\n    if (this.texture)\n      return;\n    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n    const defaultSize = this._textureSize;\n    const { canvas, context } = getCanvas(defaultSize, defaultSize);\n    const { x: x0, y: y0 } = this.center;\n    const { x: x1, y: y1 } = this.outerCenter;\n    const r0 = this.innerRadius;\n    const r1 = this.outerRadius;\n    const ox = x1 - r1;\n    const oy = y1 - r1;\n    const scale = defaultSize / (r1 * 2);\n    const cx = (x0 - ox) * scale;\n    const cy = (y0 - oy) * scale;\n    const gradient = context.createRadialGradient(\n      cx,\n      cy,\n      r0 * scale,\n      (x1 - ox) * scale,\n      (y1 - oy) * scale,\n      r1 * scale\n    );\n    addColorStops(gradient, colorStops);\n    context.fillStyle = colorStops[colorStops.length - 1].color;\n    context.fillRect(0, 0, defaultSize, defaultSize);\n    context.fillStyle = gradient;\n    context.translate(cx, cy);\n    context.rotate(this.rotation);\n    context.scale(1, this.scale);\n    context.translate(-cx, -cy);\n    context.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressMode: this._wrapMode\n      })\n    });\n    const m = new Matrix();\n    m.scale(1 / scale, 1 / scale);\n    m.translate(ox, oy);\n    if (this.textureSpace === \"local\") {\n      m.scale(defaultSize, defaultSize);\n    }\n    this.transform = m;\n  }\n  /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n  destroy() {\n    this.texture?.destroy(true);\n    this.texture = null;\n    this.transform = null;\n    this.colorStops = [];\n    this.start = null;\n    this.end = null;\n    this.center = null;\n    this.outerCenter = null;\n  }\n  /**\n   * Returns a unique key for this gradient instance.\n   * This key is used for caching and texture management.\n   * @returns {string} Unique key for the gradient\n   */\n  get styleKey() {\n    return `fill-gradient-${this.uid}-${this._tick}`;\n  }\n};\n/** Default options for creating a gradient fill */\n_FillGradient.defaultLinearOptions = {\n  start: { x: 0, y: 0 },\n  end: { x: 0, y: 1 },\n  colorStops: [],\n  textureSpace: \"local\",\n  type: \"linear\",\n  textureSize: 256,\n  wrapMode: \"clamp-to-edge\"\n};\n/** Default options for creating a radial gradient fill */\n_FillGradient.defaultRadialOptions = {\n  center: { x: 0.5, y: 0.5 },\n  innerRadius: 0,\n  outerRadius: 0.5,\n  colorStops: [],\n  scale: 1,\n  textureSpace: \"local\",\n  type: \"radial\",\n  textureSize: 256,\n  wrapMode: \"clamp-to-edge\"\n};\nlet FillGradient = _FillGradient;\nfunction addColorStops(gradient, colorStops) {\n  for (let i = 0; i < colorStops.length; i++) {\n    const stop = colorStops[i];\n    gradient.addColorStop(stop.offset, stop.color);\n  }\n}\nfunction getCanvas(width, height) {\n  const canvas = DOMAdapter.get().createCanvas(width, height);\n  const context = canvas.getContext(\"2d\");\n  return { canvas, context };\n}\nfunction ensureGradientOptions(args) {\n  let options = args[0] ?? {};\n  if (typeof options === \"number\" || args[1]) {\n    deprecation(\"8.5.2\", `use options object instead`);\n    options = {\n      type: \"linear\",\n      start: { x: args[0], y: args[1] },\n      end: { x: args[2], y: args[3] },\n      textureSpace: args[4],\n      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize\n    };\n  }\n  return options;\n}\n\nexport { FillGradient };\n//# sourceMappingURL=FillGradient.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /**\n     * unique id for this fill pattern\n     * @internal\n     */\n    this.uid = uid(\"fillPattern\");\n    /**\n     * Internal tick counter to track changes in the pattern.\n     * This is used to invalidate the pattern when the texture or transform changes.\n     * @internal\n     */\n    this._tick = 0;\n    /** The transform matrix applied to the pattern */\n    this.transform = new Matrix();\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  /**\n   * Sets the transform for the pattern\n   * @param transform - The transform matrix to apply to the pattern.\n   * If not provided, the pattern will use the default transform.\n   */\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._tick++;\n  }\n  /** Internal texture used to render the gradient */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this._texture === value)\n      return;\n    this._texture = value;\n    this._tick++;\n  }\n  /**\n   * Returns a unique key for this instance.\n   * This key is used for caching.\n   * @returns {string} Unique key for the instance\n   */\n  get styleKey() {\n    return `fill-pattern-${this.uid}-${this._tick}`;\n  }\n  /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n  destroy() {\n    this.texture.destroy(true);\n    this.texture = null;\n  }\n}\n\nexport { FillPattern };\n//# sourceMappingURL=FillPattern.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors.mjs';\n\n\"use strict\";\nconst identityMatrix = new Matrix();\nclass BatchableGraphics {\n  constructor() {\n    this.packAsQuad = false;\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    this.applyTransform = true;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n  }\n  get uvs() {\n    return this.geometryData.uvs;\n  }\n  get positions() {\n    return this.geometryData.vertices;\n  }\n  get indices() {\n    return this.geometryData.indices;\n  }\n  get blendMode() {\n    if (this.renderable && this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  get color() {\n    const rgb = this.baseColor;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    const renderable = this.renderable;\n    if (renderable) {\n      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);\n    }\n    return bgr + (this.alpha * 255 << 24);\n  }\n  get transform() {\n    return this.renderable?.groupTransform || identityMatrix;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.attributeOffset = this.attributeOffset;\n    gpuBuffer.attributeSize = this.attributeSize;\n    gpuBuffer.baseColor = this.baseColor;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n    gpuBuffer.topology = this.topology;\n  }\n  reset() {\n    this.applyTransform = true;\n    this.renderable = null;\n    this.topology = \"triangle-list\";\n  }\n  destroy() {\n    this.renderable = null;\n    this.texture = null;\n    this.geometryData = null;\n    this._batcher = null;\n    this._batch = null;\n  }\n}\n\nexport { BatchableGraphics };\n//# sourceMappingURL=BatchableGraphics.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildCircle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"circle\"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      rx = ry = circle.radius;\n      if (rx <= 0) {\n        return false;\n      }\n      x = circle.x;\n      y = circle.y;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      if (rx <= 0 || ry <= 0) {\n        return false;\n      }\n      x = ellipse.x;\n      y = ellipse.y;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (dx < 0 || dy < 0) {\n      return false;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return false;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return true;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: \"ellipse\" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: \"roundedRectangle\" } };\n\nexport { buildCircle, buildEllipse, buildRoundedRectangle };\n//# sourceMappingURL=buildCircle.mjs.map\n","\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexport { closePointEps, curveEps };\n//# sourceMappingURL=const.mjs.map\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexport { buildLine };\n//# sourceMappingURL=buildLine.mjs.map\n","import { earcut } from '../../../../utils/utils.mjs';\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexport { triangulateWithHoles };\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles.mjs';\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"polygon\"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexport { buildPolygon };\n//# sourceMappingURL=buildPolygon.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildRectangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"rectangle\"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width > 0 && height > 0)) {\n      return false;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildRectangle };\n//# sourceMappingURL=buildRectangle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildTriangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"triangle\"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return true;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildTriangle };\n//# sourceMappingURL=buildTriangle.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\n\n\"use strict\";\nconst tempTextureMatrix = new Matrix();\nconst tempRect = new Rectangle();\nfunction generateTextureMatrix(out, style, shape, matrix) {\n  const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();\n  if (style.textureSpace === \"local\") {\n    const bounds = shape.getBounds(tempRect);\n    if (style.width) {\n      bounds.pad(style.width);\n    }\n    const { x: tx, y: ty } = bounds;\n    const sx = 1 / bounds.width;\n    const sy = 1 / bounds.height;\n    const mTx = -tx * sx;\n    const mTy = -ty * sy;\n    const a1 = textureMatrix.a;\n    const b1 = textureMatrix.b;\n    const c1 = textureMatrix.c;\n    const d1 = textureMatrix.d;\n    textureMatrix.a *= sx;\n    textureMatrix.b *= sx;\n    textureMatrix.c *= sy;\n    textureMatrix.d *= sy;\n    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;\n    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;\n  } else {\n    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n  }\n  const sourceStyle = style.texture.source.style;\n  if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === \"clamp-to-edge\") {\n    sourceStyle.addressMode = \"repeat\";\n    sourceStyle.update();\n  }\n  if (matrix) {\n    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n  }\n  return textureMatrix;\n}\n\nexport { generateTextureMatrix };\n//# sourceMappingURL=generateTextureFillMatrix.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { generateTextureMatrix } from './generateTextureFillMatrix.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\n\"use strict\";\nconst shapeBuilders = {};\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n      }\n      if (hole) {\n        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n      }\n      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  if (!build.build(rect, points)) {\n    return;\n  }\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const texture = data.image;\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    if (!build.build(shape, points)) {\n      return;\n    }\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    let topology = \"triangle-list\";\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (holes) {\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(holes);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      if (!lineStyle.pixelLine) {\n        buildLine(points, lineStyle, false, close, vertices, indices);\n      } else {\n        buildPixelLine(points, close, vertices, indices);\n        topology = \"line-list\";\n      }\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = generateTextureMatrix(tempTextureMatrix, style, shape, matrix);\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    graphicsBatch.topology = topology;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(holePrimitives) {\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    if (holeBuilder.build(holePrimitive, holePoints)) {\n      holeArrays.push(holePoints);\n    }\n  }\n  return holeArrays;\n}\n\nexport { buildContextBatches, shapeBuilders };\n//# sourceMappingURL=buildContextBatches.mjs.map\n","import { closePointEps } from '../const.mjs';\n\n\"use strict\";\nfunction buildPixelLine(points, closed, vertices, indices) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const fx = points[0];\n  const fy = points[1];\n  const lx = points[points.length - 2];\n  const ly = points[points.length - 1];\n  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;\n  const verts = vertices;\n  const length = points.length / 2;\n  const indexStart = verts.length / 2;\n  for (let i = 0; i < length; i++) {\n    verts.push(points[i * 2]);\n    verts.push(points[i * 2 + 1]);\n  }\n  for (let i = 0; i < length - 1; i++) {\n    indices.push(indexStart + i, indexStart + i + 1);\n  }\n  if (closePath) {\n    indices.push(indexStart + length - 1, indexStart);\n  }\n}\n\nexport { buildPixelLine };\n//# sourceMappingURL=buildPixelLine.mjs.map\n","\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexport { getOrientationOfPoints };\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.instructions = new InstructionSet();\n  }\n  init(maxTextures) {\n    this.batcher = new DefaultBatcher({\n      maxTextures\n    });\n    this.instructions.reset();\n  }\n  /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */\n  get geometry() {\n    deprecation(v8_3_4, \"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.\");\n    return this.batcher.geometry;\n  }\n  destroy() {\n    this.batcher.destroy();\n    this.instructions.destroy();\n    this.batcher = null;\n    this.instructions = null;\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor(renderer) {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuContextHash\");\n    renderer.renderableGC.addManagedHash(this, \"_graphicsDataContextHash\");\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  /**\n   * Returns the render data for a given GraphicsContext.\n   * @param context - The GraphicsContext to get the render data for.\n   * @internal\n   */\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  /**\n   * Updates the GPU context for a given GraphicsContext.\n   * If the context is dirty, it will rebuild the batches and geometry data.\n   * @param context - The GraphicsContext to update.\n   * @returns The updated GpuGraphicsContext.\n   * @internal\n   */\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      } else {\n        gpuContext.isBatchable = true;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  /**\n   * Returns the GpuGraphicsContext for a given GraphicsContext.\n   * If it does not exist, it will initialize a new one.\n   * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n   * @returns The GpuGraphicsContext for the given GraphicsContext.\n   * @internal\n   */\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData, {\n      maxTextures: this._renderer.limits.maxBatchableTextures\n    });\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = graphicsData.batcher;\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = batcher.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(\n        batch.textures.textures,\n        batch.textures.count,\n        this._renderer.limits.maxBatchableTextures\n      );\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n","\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexport { buildArc };\n//# sourceMappingURL=buildArc.mjs.map\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexport { buildArcToSvg };\n//# sourceMappingURL=buildArcToSvg.mjs.map\n","import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n    this.signed = graphicsPath2D.checkForHoles;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    const shapePrimitives = this.shapePrimitives;\n    const start = shapePrimitives.length;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    if (path.checkForHoles && shapePrimitives.length - start > 1) {\n      let mainShape = null;\n      for (let i = start; i < shapePrimitives.length; i++) {\n        const shapePrimitive = shapePrimitives[i];\n        if (shapePrimitive.shape.type === \"polygon\") {\n          const polygon = shapePrimitive.shape;\n          const mainPolygon = mainShape?.shape;\n          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {\n            mainShape.holes || (mainShape.holes = []);\n            mainShape.holes.push(shapePrimitive);\n            shapePrimitives.copyWithin(i, i + 1);\n            shapePrimitives.length--;\n            i--;\n          } else {\n            mainShape = shapePrimitive;\n          }\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = startAngle - i * delta;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n","import { buildArc } from './buildArc.mjs';\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexport { buildArcTo };\n//# sourceMappingURL=buildArcTo.mjs.map\n","\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { parseSVGPath } from '../svg/parseSVGPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   * @param signed\n   */\n  constructor(instructions, signed = false) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    this.checkForHoles = signed;\n    if (typeof instructions === \"string\") {\n      parseSVGPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius || (innerRadius = radius / 2);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    newGraphicsPath2D.checkForHoles = this.checkForHoles;\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction parseSVGPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          // First control point\n          data[3],\n          data[4],\n          // Second control point\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          // First control point\n          lastX + data[3],\n          lastY + data[4],\n          // Second control point\n          lastX + data[5],\n          lastY + data[6]\n          // End point\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          // Control point\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          // Control point\n          lastX + data[3],\n          lastY + data[4]\n          // End point\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          // Control point\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          // Control point\n          lastX + data[3],\n          lastY + data[4]\n          // End point\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          // rx\n          data[2],\n          // ry\n          data[3],\n          // x-axis-rotation\n          data[4],\n          // large-arc-flag\n          data[5],\n          // sweep-flag\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          // rx\n          data[2],\n          // ry\n          data[3],\n          // x-axis-rotation\n          data[4],\n          // large-arc-flag\n          data[5],\n          // sweep-flag\n          lastX,\n          lastY\n          // End point\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexport { parseSVGPath };\n//# sourceMappingURL=parseSVGPath.mjs.map\n","\"use strict\";\nfunction parseSVGFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\n\nexport { parseSVGFloatAttribute };\n//# sourceMappingURL=parseSVGFloatAttribute.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute.mjs';\n\n\"use strict\";\nfunction parseSVGDefinitions(svg, session) {\n  const definitions = svg.querySelectorAll(\"defs\");\n  for (let i = 0; i < definitions.length; i++) {\n    const definition = definitions[i];\n    for (let j = 0; j < definition.children.length; j++) {\n      const child = definition.children[j];\n      switch (child.nodeName.toLowerCase()) {\n        case \"lineargradient\":\n          session.defs[child.id] = parseLinearGradient(child);\n          break;\n        case \"radialgradient\":\n          session.defs[child.id] = parseRadialGradient(child);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n}\nfunction parseLinearGradient(child) {\n  const x0 = parseSVGFloatAttribute(child, \"x1\", 0);\n  const y0 = parseSVGFloatAttribute(child, \"y1\", 0);\n  const x1 = parseSVGFloatAttribute(child, \"x2\", 1);\n  const y1 = parseSVGFloatAttribute(child, \"y2\", 0);\n  const gradientUnit = child.getAttribute(\"gradientUnits\") || \"objectBoundingBox\";\n  const gradient = new FillGradient(\n    x0,\n    y0,\n    x1,\n    y1,\n    gradientUnit === \"objectBoundingBox\" ? \"local\" : \"global\"\n  );\n  for (let k = 0; k < child.children.length; k++) {\n    const stop = child.children[k];\n    const offset = parseSVGFloatAttribute(stop, \"offset\", 0);\n    const color = Color.shared.setValue(stop.getAttribute(\"stop-color\")).toNumber();\n    gradient.addColorStop(offset, color);\n  }\n  return gradient;\n}\nfunction parseRadialGradient(_child) {\n  warn(\"[SVG Parser] Radial gradients are not yet supported\");\n  return new FillGradient(0, 0, 1, 0);\n}\n\nexport { parseSVGDefinitions };\n//# sourceMappingURL=parseSVGDefinitions.mjs.map\n","\"use strict\";\nfunction extractSvgUrlId(url) {\n  const match = url.match(/url\\s*\\(\\s*['\"]?\\s*#([^'\"\\s)]+)\\s*['\"]?\\s*\\)/i);\n  return match ? match[1] : \"\";\n}\n\nexport { extractSvgUrlId };\n//# sourceMappingURL=extractSvgUrlId.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { extractSvgUrlId } from './utils/extractSvgUrlId.mjs';\n\n\"use strict\";\nconst styleAttributes = {\n  // Fill properties\n  fill: { type: \"paint\", default: 0 },\n  // Fill color/gradient\n  \"fill-opacity\": { type: \"number\", default: 1 },\n  // Fill transparency\n  // Stroke properties\n  stroke: { type: \"paint\", default: 0 },\n  // Stroke color/gradient\n  \"stroke-width\": { type: \"number\", default: 1 },\n  // Width of stroke\n  \"stroke-opacity\": { type: \"number\", default: 1 },\n  // Stroke transparency\n  \"stroke-linecap\": { type: \"string\", default: \"butt\" },\n  // End cap style: butt, round, square\n  \"stroke-linejoin\": { type: \"string\", default: \"miter\" },\n  // Join style: miter, round, bevel\n  \"stroke-miterlimit\": { type: \"number\", default: 10 },\n  // Limit on miter join sharpness\n  \"stroke-dasharray\": { type: \"string\", default: \"none\" },\n  // Dash pattern\n  \"stroke-dashoffset\": { type: \"number\", default: 0 },\n  // Offset for dash pattern\n  // Global properties\n  opacity: { type: \"number\", default: 1 }\n  // Overall opacity\n};\nfunction parseSVGStyle(svg, session) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  const result = {\n    strokeStyle,\n    fillStyle,\n    useFill: false,\n    useStroke: false\n  };\n  for (const key in styleAttributes) {\n    const attribute = svg.getAttribute(key);\n    if (attribute) {\n      parseAttribute(session, result, key, attribute.trim());\n    }\n  }\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i].trim();\n      const [key, value] = stylePart.split(\":\");\n      if (styleAttributes[key]) {\n        parseAttribute(session, result, key, value.trim());\n      }\n    }\n  }\n  return {\n    strokeStyle: result.useStroke ? strokeStyle : null,\n    fillStyle: result.useFill ? fillStyle : null,\n    useFill: result.useFill,\n    useStroke: result.useStroke\n  };\n}\nfunction parseAttribute(session, result, id, value) {\n  switch (id) {\n    case \"stroke\":\n      if (value !== \"none\") {\n        if (value.startsWith(\"url(\")) {\n          const id2 = extractSvgUrlId(value);\n          result.strokeStyle.fill = session.defs[id2];\n        } else {\n          result.strokeStyle.color = Color.shared.setValue(value).toNumber();\n        }\n        result.useStroke = true;\n      }\n      break;\n    case \"stroke-width\":\n      result.strokeStyle.width = Number(value);\n      break;\n    case \"fill\":\n      if (value !== \"none\") {\n        if (value.startsWith(\"url(\")) {\n          const id2 = extractSvgUrlId(value);\n          result.fillStyle.fill = session.defs[id2];\n        } else {\n          result.fillStyle.color = Color.shared.setValue(value).toNumber();\n        }\n        result.useFill = true;\n      }\n      break;\n    case \"fill-opacity\":\n      result.fillStyle.alpha = Number(value);\n      break;\n    case \"stroke-opacity\":\n      result.strokeStyle.alpha = Number(value);\n      break;\n    case \"opacity\":\n      result.fillStyle.alpha = Number(value);\n      result.strokeStyle.alpha = Number(value);\n      break;\n  }\n}\n\nexport { parseSVGStyle, styleAttributes };\n//# sourceMappingURL=parseSVGStyle.mjs.map\n","import { GraphicsPath } from '../../path/GraphicsPath.mjs';\n\n\"use strict\";\nfunction extractSubpaths(pathData) {\n  const parts = pathData.split(/(?=[Mm])/);\n  const subpaths = parts.filter((part) => part.trim().length > 0);\n  return subpaths;\n}\nfunction calculatePathArea(pathData) {\n  const coords = pathData.match(/[-+]?[0-9]*\\.?[0-9]+/g);\n  if (!coords || coords.length < 4)\n    return 0;\n  const numbers = coords.map(Number);\n  const xs = [];\n  const ys = [];\n  for (let i = 0; i < numbers.length; i += 2) {\n    if (i + 1 < numbers.length) {\n      xs.push(numbers[i]);\n      ys.push(numbers[i + 1]);\n    }\n  }\n  if (xs.length === 0 || ys.length === 0)\n    return 0;\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const area = (maxX - minX) * (maxY - minY);\n  return area;\n}\nfunction appendSVGPath(pathData, graphicsPath) {\n  const tempPath = new GraphicsPath(pathData, false);\n  for (const instruction of tempPath.instructions) {\n    graphicsPath.instructions.push(instruction);\n  }\n}\n\nexport { appendSVGPath, calculatePathArea, extractSubpaths };\n//# sourceMappingURL=pathOperations.mjs.map\n","import { warn } from '../../../../utils/logging/warn.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\nimport { parseSVGDefinitions } from './parseSVGDefinitions.mjs';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute.mjs';\nimport { parseSVGStyle } from './parseSVGStyle.mjs';\nimport { checkForNestedPattern } from './utils/fillOperations.mjs';\nimport { extractSubpaths, calculatePathArea, appendSVGPath } from './utils/pathOperations.mjs';\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    defs: {},\n    path: new GraphicsPath()\n  };\n  parseSVGDefinitions(svg, session);\n  const children = svg.children;\n  const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (child.nodeName.toLowerCase() === \"defs\")\n      continue;\n    renderChildren(child, session, fillStyle, strokeStyle);\n  }\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  const noStyle = !fillStyle && !strokeStyle;\n  if (noStyle) {\n    fillStyle = { color: 0 };\n  }\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\": {\n      d = svg.getAttribute(\"d\");\n      const fillRule = svg.getAttribute(\"fill-rule\");\n      const subpaths = extractSubpaths(d);\n      const hasExplicitEvenodd = fillRule === \"evenodd\";\n      const hasMultipleSubpaths = subpaths.length > 1;\n      const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;\n      if (shouldProcessHoles) {\n        const subpathsWithArea = subpaths.map((subpath) => ({\n          path: subpath,\n          area: calculatePathArea(subpath)\n        }));\n        subpathsWithArea.sort((a, b) => b.area - a.area);\n        const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);\n        if (useMultipleHolesApproach) {\n          for (let i = 0; i < subpathsWithArea.length; i++) {\n            const subpath = subpathsWithArea[i];\n            const isMainShape = i === 0;\n            session.context.beginPath();\n            const newPath = new GraphicsPath(void 0, true);\n            appendSVGPath(subpath.path, newPath);\n            session.context.path(newPath);\n            if (isMainShape) {\n              if (fillStyle)\n                session.context.fill(fillStyle);\n              if (strokeStyle)\n                session.context.stroke(strokeStyle);\n            } else {\n              session.context.cut();\n            }\n          }\n        } else {\n          for (let i = 0; i < subpathsWithArea.length; i++) {\n            const subpath = subpathsWithArea[i];\n            const isHole = i % 2 === 1;\n            session.context.beginPath();\n            const newPath = new GraphicsPath(void 0, true);\n            appendSVGPath(subpath.path, newPath);\n            session.context.path(newPath);\n            if (isHole) {\n              session.context.cut();\n            } else {\n              if (fillStyle)\n                session.context.fill(fillStyle);\n              if (strokeStyle)\n                session.context.stroke(strokeStyle);\n            }\n          }\n        }\n      } else {\n        const useEvenoddForGraphicsPath = fillRule ? fillRule === \"evenodd\" : true;\n        graphicsPath = new GraphicsPath(d, useEvenoddForGraphicsPath);\n        session.context.path(graphicsPath);\n        if (fillStyle)\n          session.context.fill(fillStyle);\n        if (strokeStyle)\n          session.context.stroke(strokeStyle);\n      }\n      break;\n    }\n    case \"circle\":\n      cx = parseSVGFloatAttribute(svg, \"cx\", 0);\n      cy = parseSVGFloatAttribute(svg, \"cy\", 0);\n      r = parseSVGFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"rect\":\n      x = parseSVGFloatAttribute(svg, \"x\", 0);\n      y = parseSVGFloatAttribute(svg, \"y\", 0);\n      width = parseSVGFloatAttribute(svg, \"width\", 0);\n      height = parseSVGFloatAttribute(svg, \"height\", 0);\n      rx = parseSVGFloatAttribute(svg, \"rx\", 0);\n      ry = parseSVGFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"ellipse\":\n      cx = parseSVGFloatAttribute(svg, \"cx\", 0);\n      cy = parseSVGFloatAttribute(svg, \"cy\", 0);\n      rx = parseSVGFloatAttribute(svg, \"rx\", 0);\n      ry = parseSVGFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"line\":\n      x1 = parseSVGFloatAttribute(svg, \"x1\", 0);\n      y1 = parseSVGFloatAttribute(svg, \"y1\", 0);\n      x2 = parseSVGFloatAttribute(svg, \"x2\", 0);\n      y2 = parseSVGFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill(fillStyle);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke(strokeStyle);\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  if (noStyle) {\n    fillStyle = null;\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\n\nexport { SVGParser };\n//# sourceMappingURL=SVGParser.mjs.map\n","\"use strict\";\nfunction checkForNestedPattern(subpathsWithArea) {\n  if (subpathsWithArea.length <= 2) {\n    return true;\n  }\n  const areas = subpathsWithArea.map((s) => s.area).sort((a, b) => b - a);\n  const [largestArea, secondArea] = areas;\n  const smallestArea = areas[areas.length - 1];\n  const largestToSecondRatio = largestArea / secondArea;\n  const secondToSmallestRatio = secondArea / smallestArea;\n  if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {\n    return false;\n  }\n  return true;\n}\nfunction getFillInstructionData(context, index = 0) {\n  const instruction = context.instructions[index];\n  if (!instruction || instruction.action !== \"fill\") {\n    throw new Error(`Expected fill instruction at index ${index}, got ${instruction?.action || \"undefined\"}`);\n  }\n  return instruction.data;\n}\n\nexport { checkForNestedPattern, getFillInstructionData };\n//# sourceMappingURL=fillOperations.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\n\"use strict\";\nfunction isColorLike(value) {\n  return Color.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof FillPattern;\n}\nfunction isFillGradient(value) {\n  return value instanceof FillGradient;\n}\nfunction isTexture(value) {\n  return value instanceof Texture;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = Color.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = Texture.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleTexture(fill, value, defaultStyle) {\n  fill.texture = value;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  fill.textureSpace = value.textureSpace;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isTexture(value)) {\n    return handleTexture(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    pixelLine,\n    ...fill\n  };\n}\n\nexport { toFillStyle, toStrokeStyle };\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle.mjs';\n\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /**\n     * unique id for this graphics context\n     * @internal\n     */\n    this.uid = uid(\"graphicsContext\");\n    /**\n     * Indicates whether content is updated and have to be re-rendered.\n     * @internal\n     */\n    this.dirty = true;\n    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n    this.batchMode = \"auto\";\n    /** @internal */\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = toFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = toStrokeStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = toFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    this._boundsDirty = true;\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const alignment = data.style.alignment;\n        const outerPadding = data.style.width * (1 - alignment);\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - outerPadding,\n          _bounds.minY - outerPadding,\n          _bounds.maxX + outerPadding,\n          _bounds.maxY + outerPadding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          const strokeStyle = style;\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * context.destroy();\n   * context.destroy(true);\n   * context.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.fill && \"uid\" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.fill && \"uid\" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null,\n  /** Whether coordinates are 'global' or 'local' */\n  textureSpace: \"local\"\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null,\n  /** Whether coordinates are 'global' or 'local' */\n  textureSpace: \"local\",\n  /** If the stroke is a pixel line. */\n  pixelLine: false\n};\nlet GraphicsContext = _GraphicsContext;\n\nexport { GraphicsContext };\n//# sourceMappingURL=GraphicsContext.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * Creates a new Graphics object.\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.didViewUpdate = true;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The underlying graphics context used for drawing operations.\n   * Controls how shapes and paths are rendered.\n   * @example\n   * ```ts\n   * // Create a shared context\n   * const sharedContext = new GraphicsContext();\n   *\n   * // Create graphics objects sharing the same context\n   * const graphics1 = new Graphics();\n   * const graphics2 = new Graphics();\n   *\n   * // Assign shared context\n   * graphics1.context = sharedContext;\n   * graphics2.context = sharedContext;\n   *\n   * // Both graphics will show the same shapes\n   * sharedContext\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @see {@link GraphicsContext} For drawing operations\n   * @see {@link GraphicsOptions} For context configuration\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphics object.\n   * Returns the boundaries after all graphical operations but before any transforms.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Get bounds information\n   * const bounds = graphics.bounds;\n   * console.log(bounds.width);  // 100\n   * console.log(bounds.height); // 100\n   * ```\n   * @readonly\n   * @see {@link Bounds} For bounds operations\n   * @see {@link Container#getBounds} For transformed bounds\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * Returns true if the point lies within the Graphics object's rendered area.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Check point intersection\n   * if (graphics.containsPoint({ x: 50, y: 50 })) {\n   *     console.log('Point is inside rectangle!');\n   * }\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is inside the Graphics object\n   * @see {@link Graphics#bounds} For bounding box checks\n   * @see {@link PointData} For point data structure\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @example\n   * ```ts\n   * // Destroy the graphics and its context\n   * graphics.destroy();\n   * graphics.destroy(true);\n   * graphics.destroy({ context: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context.\n   * The fill style can be a color, gradient, pattern, or a complex style object.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics\n   *     .setFillStyle({ color: 0xff0000 }) // Red fill\n   *     .rect(0, 0, 100, 100)\n   *     .fill();\n   *\n   * // Gradient fill\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setFillStyle(gradient)\n   *     .circle(100, 100, 50)\n   *     .fill();\n   *\n   * // Pattern fill\n   * const pattern = new FillPattern(texture);\n   * graphics\n   *     .setFillStyle({\n   *         fill: pattern,\n   *         alpha: 0.5\n   *     })\n   *     .rect(0, 0, 200, 200)\n   *     .fill();\n   * ```\n   * @param {FillInput} args - The fill style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link FillStyle} For fill style options\n   * @see {@link FillGradient} For gradient fills\n   * @see {@link FillPattern} For pattern fills\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context.\n   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color stroke\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 2,\n   *         color: 0x000000\n   *     })\n   *     .rect(0, 0, 100, 100)\n   *     .stroke();\n   *\n   * // Complex stroke style\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 4,\n   *         color: 0xff0000,\n   *         alpha: 0.5,\n   *         join: 'round',\n   *         cap: 'round',\n   *         alignment: 0.5\n   *     })\n   *     .circle(100, 100, 50)\n   *     .stroke();\n   *\n   * // Gradient stroke\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 10,\n   *         fill: gradient\n   *     })\n   *     .poly([0,0, 100,50, 0,100])\n   *     .stroke();\n   * ```\n   * @param {StrokeInput} args - The stroke style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link FillPattern} For pattern strokes\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style or specified style.\n   * Outlines the shape using the stroke settings.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Stroke with direct color\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .stroke({\n   *         width: 2,\n   *         color: 0xff0000\n   *     }); // 2px red stroke\n   *\n   * // Fill with texture\n   * graphics\n   *    .rect(0, 0, 100, 100)\n   *    .stroke(myTexture); // Fill with texture\n   *\n   * // Stroke with gradient\n   * const gradient = new FillGradient({\n   *     end: { x: 1, y: 0 },\n   *     colorStops: [\n   *         { offset: 0, color: 0xff0000 },\n   *         { offset: 0.5, color: 0x00ff00 },\n   *         { offset: 1, color: 0x0000ff },\n   *     ],\n   * });\n   *\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .stroke({\n   *         width: 4,\n   *         fill: gradient,\n   *         alignment: 0.5,\n   *         join: 'round'\n   *     });\n   * ```\n   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n   * - A stroke style object with width, color, etc.\n   * - A gradient\n   * - A pattern\n   * If omitted, uses current stroke style.\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link setStrokeStyle} For setting default stroke style\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   * graphics\n   *     .circle(150, 150, 50)\n   *     .fill({ color: 0x00ff00 })\n   *     .beginPath() // Starts a new path\n   *     .circle(250, 150, 50)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for chaining\n   * @see {@link Graphics#moveTo} For starting a new subpath\n   * @see {@link Graphics#closePath} For closing the current path\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path.\n   *\n   * If a hole is not completely in a shape, it will fail to cut correctly.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw outer circle\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *     .circle(100, 100, 25) // Inner circle\n   *     .cut() // Cuts out the inner circle from the outer circle\n   * ```\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start point.\n   *\n   * This is useful for completing shapes and ensuring they are properly closed for fills.\n   * @example\n   * ```ts\n   * // Create a triangle with closed path\n   * const graphics = new Graphics();\n   * graphics\n   *     .moveTo(50, 50)\n   *     .lineTo(100, 100)\n   *     .lineTo(0, 100)\n   *     .closePath()\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path\n   * @see {@link Graphics#fill} For filling closed paths\n   * @see {@link Graphics#stroke} For stroking paths\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /**\n   * Saves the current graphics state onto a stack. The state includes:\n   * - Current transformation matrix\n   * - Current fill style\n   * - Current stroke style\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Save state before complex operations\n   * graphics.save();\n   *\n   * // Create transformed and styled shape\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4)\n   *     .setFillStyle({\n   *         color: 0xff0000,\n   *         alpha: 0.5\n   *     })\n   *     .rect(-25, -25, 50, 50)\n   *     .fill();\n   *\n   * // Restore to original state\n   * graphics.restore();\n   *\n   * // Continue drawing with previous state\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .fill();\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#restore} For restoring the saved state\n   * @see {@link Graphics#setTransform} For setting transformations\n   */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * This matrix represents all accumulated transformations including translate, scale, and rotate.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply some transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4);\n   *\n   * // Get the current transform matrix\n   * const matrix = graphics.getTransform();\n   * console.log(matrix.tx, matrix.ty); // 100, 100\n   *\n   * // Use the matrix for other operations\n   * graphics\n   *     .setTransform(matrix)\n   *     .circle(0, 0, 50)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @returns The current transformation matrix.\n   * @see {@link Graphics#setTransform} For setting the transform matrix\n   * @see {@link Matrix} For matrix operations\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .scaleTransform(2, 2)\n   *     .circle(0, 0, 25)\n   *     .fill({ color: 0xff0000 });\n   * // Reset transform to default state\n   * graphics\n   *     .resetTransform()\n   *     .circle(50, 50, 25) // Will draw at actual coordinates\n   *     .fill({ color: 0x00ff00 });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#getTransform} For getting the current transform\n   * @see {@link Graphics#setTransform} For setting a specific transform\n   * @see {@link Graphics#save} For saving the current transform state\n   * @see {@link Graphics#restore} For restoring a previous transform state\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it.\n   * This includes clearing the current path, fill style, stroke style, and transformations.\n   *\n   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n   * > Instead, they are intended to be used for static or semi-static graphics that\n   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw some shapes\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 })\n   *     .rect(200, 100, 100, 50)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Clear all graphics\n   * graphics.clear();\n   *\n   * // Start fresh with new shapes\n   * graphics\n   *     .circle(150, 150, 30)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n   * @see {@link Graphics#save} For saving the current state\n   * @see {@link Graphics#restore} For restoring a previous state\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * Gets or sets the current fill style for the graphics context. The fill style determines\n   * how shapes are filled when using the fill() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics.fillStyle = {\n   *     color: 0xff0000,  // Red\n   *     alpha: 1\n   * };\n   *\n   * // Using gradients\n   * const gradient = new FillGradient({\n   *     end: { x: 0, y: 1 }, // Vertical gradient\n   *     stops: [\n   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n   *     ]\n   * });\n   *\n   * graphics.fillStyle = {\n   *     fill: gradient,\n   *     alpha: 0.8\n   * };\n   *\n   * // Using patterns\n   * graphics.fillStyle = {\n   *     texture: myTexture,\n   *     alpha: 1,\n   *     matrix: new Matrix()\n   *         .scale(0.5, 0.5)\n   *         .rotate(Math.PI / 4)\n   * };\n   * ```\n   * @type {ConvertedFillStyle}\n   * @see {@link FillStyle} For all available fill style options\n   * @see {@link FillGradient} For creating gradient fills\n   * @see {@link Graphics#fill} For applying the fill to paths\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * Gets or sets the current stroke style for the graphics context. The stroke style determines\n   * how paths are outlined when using the stroke() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic stroke style\n   * graphics.strokeStyle = {\n   *     width: 2,\n   *     color: 0xff0000,\n   *     alpha: 1\n   * };\n   *\n   * // Using with gradients\n   * const gradient = new FillGradient({\n   *   end: { x: 0, y: 1 },\n   *   stops: [\n   *       { offset: 0, color: 0xff0000, alpha: 1 },\n   *       { offset: 1, color: 0x0000ff, alpha: 1 }\n   *   ]\n   * });\n   *\n   * graphics.strokeStyle = {\n   *     width: 4,\n   *     fill: gradient,\n   *     alignment: 0.5,\n   *     join: 'round',\n   *     cap: 'round'\n   * };\n   *\n   * // Complex stroke settings\n   * graphics.strokeStyle = {\n   *     width: 6,\n   *     color: 0x00ff00,\n   *     alpha: 0.5,\n   *     join: 'miter',\n   *     miterLimit: 10,\n   * };\n   * ```\n   * @see {@link StrokeStyle} For all available stroke style options\n   * @see {@link Graphics#stroke} For applying the stroke to paths\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object that copies the current graphics content.\n   * The clone can either share the same context (shallow clone) or have its own independent\n   * context (deep clone).\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Create original graphics content\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Create a shallow clone (shared context)\n   * const shallowClone = graphics.clone();\n   *\n   * // Changes to original affect the clone\n   * graphics\n   *     .circle(200, 100, 30)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Create a deep clone (independent context)\n   * const deepClone = graphics.clone(true);\n   *\n   * // Modify deep clone independently\n   * deepClone\n   *     .translateTransform(100, 100)\n   *     .circle(0, 0, 40)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @param deep - Whether to create a deep clone of the graphics object.\n   *              If false (default), the context will be shared between objects.\n   *              If true, creates an independent copy of the context.\n   * @returns A new Graphics instance with either shared or copied context\n   * @see {@link Graphics#context} For accessing the underlying graphics context\n   * @see {@link GraphicsContext} For understanding the shared context behavior\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlGraphicsAdaptor {\n  contextChange(renderer) {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const maxTextures = renderer.limits.maxBatchableTextures;\n    const glProgram = compileHighShaderGlProgram({\n      name: \"graphics\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        localUniformBitGl,\n        roundPixelsBitGl\n      ]\n    });\n    this.shader = new Shader({\n      glProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    shader.groups[0] = renderer.globalUniforms.bindGroup;\n    renderer.state.set(graphicsPipe.state);\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(batcher.geometry, shader.glProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.size) {\n        for (let j = 0; j < batch.textures.count; j++) {\n          renderer.texture.bind(batch.textures.textures[j], j);\n        }\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n      }\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGlGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GlGraphicsAdaptor };\n//# sourceMappingURL=GlGraphicsAdaptor.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  constructor() {\n    this._maxTextures = 0;\n  }\n  contextChange(renderer) {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this._maxTextures = renderer.limits.maxBatchableTextures;\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(this._maxTextures),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(\n          batcher.geometry,\n          shader.gpuProgram,\n          graphicsPipe.state,\n          batch.topology\n        );\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(\n          textureBatch.textures,\n          textureBatch.count,\n          this._maxTextures\n        );\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n"],"names":["emptyColorStops","offset","color","_FillGradient","constructor","args","this","uid","_tick","type","colorStops","options","deprecation","start","x","y","end","textureSpace","textureSize","FillGradient","defaultLinearOptions","ensureGradientOptions","defaultRadialOptions","definedProps","_textureSize","_wrapMode","wrapMode","center","outerCenter","innerRadius","outerRadius","scale","rotation","forEach","stop","addColorStop","push","Color","shared","setValue","toHexa","buildLinearGradient","texture","x0","y0","x1","y1","dx","dy","flip","temp","length","defaultSize","canvas","context","getCanvas","gradient","createLinearGradient","addColorStops","fillStyle","fillRect","Texture","source","ImageSource","resource","addressMode","dist","Math","sqrt","angle","atan2","m","Matrix","rotate","translate","transform","buildGradient","buildRadialGradient","r0","r1","ox","oy","cx","cy","createRadialGradient","destroy","styleKey","i","width","height","DOMAdapter","get","createCanvas","getContext","repetitionMap","repeat","addressModeU","addressModeV","FillPattern","repetition","frame","style","setTransform","copyFrom","invert","_texture","value","identityMatrix","BatchableGraphics","packAsQuad","batcherName","topology","applyTransform","roundPixels","_batcher","_batch","uvs","geometryData","positions","vertices","indices","blendMode","renderable","groupBlendMode","rgb","baseColor","bgr","multiplyHexColors","groupColor","alpha","groupAlpha","groupTransform","copyTo","gpuBuffer","indexOffset","indexSize","attributeOffset","attributeSize","reset","buildCircle","extension","ExtensionType","ShapeBuilder","name","build","shape","points","rx","ry","circle","radius","ellipse","halfWidth","halfHeight","roundedRect","max","min","n","ceil","j1","j2","j3","j4","x2","y22","a","PI","x02","cos","y02","sin","x12","x22","y12","y2","triangulate","verticesStride","verticesOffset","indicesOffset","centerX","centerY","count","centerIndex","buildEllipse","buildRoundedRectangle","closePointEps","square","nx","ny","innerWeight","outerWeight","clockwise","verts","exx","eyy","eix","eiy","eox","eoy","round","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","startAngle","angleDiff","absAngleDiff","abs","segCount","angleInc","triangulateWithHoles","holes","triangles","earcut","index","emptyArray","buildPolygon","buildRectangle","rectData","verticesIndex","buildTriangle","x3","y3","tempTextureMatrix","tempRect","Rectangle","shapeBuilders","extensions","handleByMap","add","addTextureToGeometryData","data","batches","rectangle","rect","dw","dh","matrix","vertOffset","transformVertices","image","textureUvs","graphicsBatch","BigPool","addShapePathToGeometryData","shapePath","isStroke","shapePrimitives","close","closePath","lineStyle","pixelLine","closed","eps","fx","fy","lx","ly","indexStart","buildPixelLine","flipAlignment","alignment","orientation","area","getOrientationOfPoints","firstPoint","Point","lastPoint","closedShape","closedPath","slice","pop","set","midPointX","midPointY","unshift","indexCount","widthSquared","miterLimitSquared","miterLimit","perpX","perpY","perp1x","perp1y","cap","dx0","dy0","dx1","dy1","dot","cross","join","c1","c2","px","py","pDist","imx","imy","omx","omy","insideWeight","curveEps","buildLine","holeIndices","otherPoints","holePrimitives","holeArrays","k","holePrimitive","holePoints","getHoleArrays","uvsOffset","WHITE","textureMatrix","out","identity","bounds","getBounds","pad","tx","ty","mTx","mTy","a1","b1","b","c","d1","d","sourceStyle","fill","update","append","generateTextureMatrix","buildUvs","buildSimpleUvs","GpuGraphicsContext","GraphicsContextRenderData","instructions","InstructionSet","init","maxTextures","batcher","DefaultBatcher","geometry","v8_3_4","_GraphicsContextSystem","renderer","_gpuContextHash","_graphicsDataContextHash","Object","create","_renderer","renderableGC","addManagedHash","defaultOptions","bezierSmoothness","getContextRenderData","_initContextRenderData","updateGpuContext","gpuContext","_initContext","dirty","_cleanGraphicsContextData","instruction","action","path","hole","buildContextBatches","batchMode","customShader","isBatchable","getGpuContext","graphicsData","limits","maxBatchableTextures","vertexSize","ensureAttributeBuffer","ensureIndexBuffer","begin","batch","finish","indexBuffer","setDataWithSize","buffers","attributeBuffer","float32View","drawBatches","bindGroup","getTextureBatchBindGroup","textures","on","onGraphicsContextDestroy","off","return","WebGLSystem","WebGPUSystem","CanvasSystem","GraphicsContextSystem","FLT_EPSILON","buildAdaptiveBezier","sX","sY","cp1x","cp1y","cp2x","cp2y","eX","eY","smoothness","distanceTolerance","recursive","x4","y4","level","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d2","d3","buildAdaptiveQuadratic","buildArc","steps","floor","pow","f","t","TAU","ang1","ang2","mapToEllipse","cosPhi","sinPhi","out2","xp","yp","approxUnitArc","tan","vectorAngle","ux","uy","vx","vy","acos","buildArcToSvg","xAxisRotation","largeArcFlag","sweepFlag","pxp","pyp","lambda","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","vx2","vy2","getArcCenter","ratio","segments","lastX","lastY","outCurvePoint","curve","tempRectangle","ShapePath","graphicsPath2D","_currentPoly","_bounds","Bounds","_graphicsPath2D","signed","checkForHoles","moveTo","startPoly","lineTo","_ensurePoly","fromX","fromY","arc","endAngle","counterclockwise","arcTo","a2","b2","mm","dd","cc","tt","k1","k2","qx","qy","buildArcTo","arcToSvg","bezierCurveTo","currentPoly","quadraticCurveTo","smoothing","endPoly","addPath","isIdentity","clone","mainShape","shapePrimitive","polygon","mainPolygon","containsPolygon","copyWithin","w","h","drawShape","Circle","poly","Polygon","regularPoly","sides","delta","roundPoly","corner","sideLength","internalAngle","roundShape","useQuadratic","g","distance","p1","p2","pointLerp","numPoints","thisPoint","pRadius","nextPoint","lastEdgeLength","nextEdgeLength","roundedShapeQuadraticCurve","vecFrom","p","pp","len","sharpCorner","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","cRadius","lenOut","cX","cY","roundedShapeArc","filletRect","fillet","maxFillet","inset","right","bottom","dir","size","chamferRect","chamfer","splice","radiusX","radiusY","Ellipse","roundRect","RoundedRectangle","lastShape","tempX","buildPath","clear","boundsRect","addRect","GraphicsPath","_dirty","svgPath","commands","parse","subpaths","currentSubPath","command","bezierCurveToShort","quadraticCurveToShort","startX","startY","warn","parseSVGPath","_shapePath","last","getLastPoint","currentX","currentY","cpx1","cpy1","star","r","deep","newGraphicsPath2D","cpx2","cpy2","adjustTransform","lastInstruction","currentMatrix","prepend","parseSVGFloatAttribute","svg","id","defaultValue","getAttribute","Number","parseLinearGradient","child","gradientUnit","children","toNumber","parseRadialGradient","_child","extractSvgUrlId","url","match","styleAttributes","default","stroke","opacity","parseSVGStyle","session","strokeStyle","result","useFill","useStroke","key","attribute","parseAttribute","trim","styleParts","split","stylePart","startsWith","id2","defs","calculatePathArea","pathData","coords","numbers","map","xs","ys","minX","maxX","minY","appendSVGPath","graphicsPath","tempPath","SVGParser","graphicsContext","div","document","createElement","innerHTML","querySelector","definitions","querySelectorAll","definition","j","nodeName","toLowerCase","parseSVGDefinitions","renderChildren","f1","s1","noStyle","pointsString","fillRule","filter","part","hasExplicitEvenodd","hasMultipleSubpaths","subpathsWithArea","subpath","sort","useMultipleHolesApproach","areas","s","largestArea","secondArea","smallestArea","checkForNestedPattern","isMainShape","beginPath","newPath","cut","isHole","parseInt","isFillPattern","isFillGradient","handleFillPattern","defaultStyle","handleFillGradient","toFillStyle","objectStyle","isColorLike","handleColorLike","isTexture","handleTexture","handleFillObject","toStrokeStyle","rest","tmpPoint","tempMatrix","_GraphicsContext","EventEmitter","super","arguments","_activePath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","defaultStrokeStyle","_stateStack","_boundsDirty","setFillStyle","setStrokeStyle","tint","onUpdate","v8_0_0","_initNextPathLocation","holePath","transformedX","transformedY","cpx","cpy","restore","state","save","getTransform","resetTransform","emit","addBounds","addFrame","outerPadding","maxY","containsPoint","point","hasHit","shapes","transformedPoint","applyInverse","contains","strokeContains","holeShapes","removeAllListeners","destroyTextureSource","textureSource","GraphicsContext","Graphics","ViewContainer","label","renderPipeId","_context","_ownedContext","onViewUpdate","didViewUpdate","allowChildren","updateBounds","_callContextMethod","method","rotateTransform","scaleTransform","translateTransform","beginFill","endFill","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","GlGraphicsAdaptor","contextChange","uniforms","UniformGroup","uColor","Float32Array","uTransformMatrix","uRound","glProgram","compileHighShaderGlProgram","bits","colorBitGl","generateTextureBatchBitGl","localUniformBitGl","roundPixelsBitGl","shader","Shader","resources","localUniforms","batchSamplers","getBatchSamplersUniformGroup","execute","graphicsPipe","contextSystem","groups","globalUniforms","bind","instructionSize","draw","color32BitToUniform","abgr","WebGLPipesAdaptor","GpuGraphicsAdaptor","_maxTextures","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","localUniformBitGroup2","roundPixelsBit","encoder","setGeometry","globalUniformsBindGroup","setBindGroup","localBindGroup","renderPipes","uniformBatch","getUniformBindGroup","setPipelineFromGeometryProgramAndState","gpuBindGroup","textureBatch","getBindGroup","renderPassEncoder","drawIndexed","WebGPUPipesAdaptor","GraphicsGpuData","batched","GraphicsPipe","adaptor","State","for2d","_adaptor","runners","validateRenderable","graphics","wasBatched","_gpuData","addRenderable","instructionSet","_rebuild","_addToBatcher","break","updateRenderable","_getGpuDataForRenderable","updateElement","isRenderable","_roundPixels","groupColorAlpha","gpuData","_updateBatchesForRenderable","batchPipe","addToBatch","_initGpuDataForRenderable","batchClone","WebGLPipes","WebGPUPipes","CanvasPipes"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]}