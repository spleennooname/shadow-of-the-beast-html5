{"version":3,"file":"pixi-sprites-NGNZT2X3.js","sources":["../../node_modules/pixi.js/lib/scene/sprite/Sprite.mjs","../../node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs","../../node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs","../../node_modules/pixi.js/lib/spritesheet/init.mjs","../../node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs","../../node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","../../node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","../../node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","../../node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","../../node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","../../node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { deprecation } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\n\"use strict\";\nclass Sprite extends ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"sprite\";\n    /** @internal */\n    this.batched = true;\n    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Creates a new sprite based on a source texture, image, video, or canvas element.\n   * This is a convenience method that automatically creates and manages textures.\n   * @example\n   * ```ts\n   * // Create from path or URL\n   * const sprite = Sprite.from('assets/image.png');\n   *\n   * // Create from existing texture\n   * const sprite = Sprite.from(texture);\n   *\n   * // Create from canvas\n   * const canvas = document.createElement('canvas');\n   * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n   * ```\n   * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n   * or any valid texture source (canvas, video, etc.)\n   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n   * @returns A new sprite based on the source\n   * @see {@link Texture.from} For texture creation details\n   * @see {@link Assets} For asset loading and management\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /**\n   * The texture that is displayed by the sprite. When changed, automatically updates\n   * the sprite dimensions and manages texture event listeners.\n   * @example\n   * ```ts\n   * // Create sprite with texture\n   * const sprite = new Sprite({\n   *     texture: Texture.from('sprite.png')\n   * });\n   *\n   * // Update texture\n   * sprite.texture = Texture.from('newSprite.png');\n   *\n   * // Use texture from spritesheet\n   * const sheet = await Assets.load('spritesheet.json');\n   * sprite.texture = sheet.textures['frame1.png'];\n   *\n   * // Reset to empty texture\n   * sprite.texture = Texture.EMPTY;\n   * ```\n   * @see {@link Texture} For texture creation and management\n   * @see {@link Assets} For asset loading\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The bounds of the sprite, taking into account the texture's trim area.\n   * @example\n   * ```ts\n   * const texture = new Texture({\n   *     source: new TextureSource({ width: 300, height: 300 }),\n   *     frame: new Rectangle(196, 66, 58, 56),\n   *     trim: new Rectangle(4, 4, 58, 56),\n   *     orig: new Rectangle(0, 0, 64, 64),\n   *     rotate: 2,\n   * });\n   * const sprite = new Sprite(texture);\n   * const visualBounds = sprite.visualBounds;\n   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n   */\n  get visualBounds() {\n    updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n    return this._visualBounds;\n  }\n  /**\n   * @deprecated\n   * @ignore\n   */\n  get sourceBounds() {\n    deprecation(\"8.6.1\", \"Sprite.sourceBounds is deprecated, use visualBounds instead.\");\n    return this.visualBounds;\n  }\n  /** @private */\n  updateBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const bounds = this._bounds;\n    const { width, height } = texture.orig;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * sprite.destroy();\n   * sprite.destroy(true);\n   * sprite.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._visualBounds = null;\n    this._bounds = null;\n    this._anchor = null;\n    this._gpuData = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * - The default is `(0,0)`, this means the sprite's origin is the top left.\n   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * ```ts\n   * // Center the anchor point\n   * sprite.anchor = 0.5; // Sets both x and y to 0.5\n   * sprite.position.set(400, 300); // Sprite will be centered at this position\n   *\n   * // Set specific x/y anchor points\n   * sprite.anchor = {\n   *     x: 1, // Right edge\n   *     y: 0  // Top edge\n   * };\n   *\n   * // Using individual coordinates\n   * sprite.anchor.set(0.5, 1); // Center-bottom\n   *\n   * // For rotation around center\n   * sprite.anchor.set(0.5);\n   * sprite.rotation = Math.PI / 4; // 45 degrees around center\n   *\n   * // For scaling from center\n   * sprite.anchor.set(0.5);\n   * sprite.scale.set(2); // Scales from center point\n   * ```\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n   * @example\n   * ```ts\n   * // Set width directly\n   * sprite.width = 200;\n   * console.log(sprite.scale.x); // Scale adjusted to match width\n   *\n   * // Set width while preserving aspect ratio\n   * const ratio = sprite.height / sprite.width;\n   * sprite.width = 300;\n   * sprite.height = 300 * ratio;\n   *\n   * // For better performance when setting both width and height\n   * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n   *\n   * // Reset to original texture size\n   * sprite.width = sprite.texture.orig.width;\n   * ```\n   */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /**\n   * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n   * @example\n   * ```ts\n   * // Set height directly\n   * sprite.height = 150;\n   * console.log(sprite.scale.y); // Scale adjusted to match height\n   *\n   * // Set height while preserving aspect ratio\n   * const ratio = sprite.width / sprite.height;\n   * sprite.height = 200;\n   * sprite.width = 200 * ratio;\n   *\n   * // For better performance when setting both width and height\n   * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n   *\n   * // Reset to original texture size\n   * sprite.height = sprite.texture.orig.height;\n   * ```\n   */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n   * This is faster than getting width and height separately as it only calculates the bounds once.\n   * @example\n   * ```ts\n   * // Basic size retrieval\n   * const sprite = new Sprite(Texture.from('sprite.png'));\n   * const size = sprite.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * sprite.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in, to avoid allocating a new object\n   * @returns The size of the Sprite\n   * @see {@link Sprite#width} For getting just the width\n   * @see {@link Sprite#height} For getting just the height\n   * @see {@link Sprite#setSize} For setting both width and height\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting width and height separately as it only recalculates bounds once.\n   * @example\n   * ```ts\n   * // Basic size setting\n   * const sprite = new Sprite(Texture.from('sprite.png'));\n   * sprite.setSize(100, 200); // Width: 100, Height: 200\n   *\n   * // Set uniform size\n   * sprite.setSize(100); // Sets both width and height to 100\n   *\n   * // Set size with object\n   * sprite.setSize({\n   *     width: 200,\n   *     height: 300\n   * });\n   *\n   * // Reset to texture size\n   * sprite.setSize(\n   *     sprite.texture.orig.width,\n   *     sprite.texture.orig.height\n   * );\n   * ```\n   * @param value - This can be either a number or a {@link Size} object\n   * @param height - The height to set. Defaults to the value of `width` if not provided\n   * @see {@link Sprite#width} For setting width only\n   * @see {@link Sprite#height} For setting height only\n   * @see {@link Sprite#texture} For the source dimensions\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\nexport { Sprite };\n//# sourceMappingURL=Sprite.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  constructor(optionsOrTexture, arg1) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    let options = optionsOrTexture;\n    if (optionsOrTexture?.source instanceof TextureSource) {\n      options = {\n        texture: optionsOrTexture,\n        data: arg1\n      };\n    }\n    const { texture, data, cachePrefix = \"\" } = options;\n    this.cachePrefix = cachePrefix;\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/**\n * The maximum number of Textures to build per process.\n * @advanced\n */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser.mjs';\nimport { Resolver } from '../assets/resolver/Resolver.mjs';\nimport { copySearchParams } from '../assets/utils/copySearchParams.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { path } from '../utils/path.mjs';\nimport { Spritesheet } from './Spritesheet.mjs';\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[`${asset.cachePrefix}${key}`] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: ExtensionType.ResolveParser,\n      name: \"resolveSpritesheet\"\n    },\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    /** used for deprecation purposes */\n    name: \"spritesheetLoader\",\n    id: \"spritesheet\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: \"spritesheetLoader\"\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename,\n        // if user need to use custom filename (not from jsonFile.meta.image)\n        textureOptions,\n        // if user need to set texture options on texture\n        cachePrefix\n        // if user need to use custom cache prefix\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([{ src: imagePath, data: textureOptions }]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet({\n        texture: texture.source,\n        data: asset,\n        cachePrefix\n      });\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              textureOptions,\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexport { spritesheetAsset };\n//# sourceMappingURL=spritesheetAsset.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { spritesheetAsset } from './spritesheetAsset.mjs';\n\n\"use strict\";\nextensions.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n","import { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { UPDATE_PRIORITY } from '../../ticker/const.mjs';\nimport { Ticker } from '../../ticker/Ticker.mjs';\nimport { Sprite } from '../sprite/Sprite.mjs';\n\n\"use strict\";\nclass AnimatedSprite extends Sprite {\n  constructor(...args) {\n    let options = args[0];\n    if (Array.isArray(args[0])) {\n      options = {\n        textures: args[0],\n        autoUpdate: args[1]\n      };\n    }\n    const {\n      animationSpeed = 1,\n      autoPlay = false,\n      autoUpdate = true,\n      loop = true,\n      onComplete = null,\n      onFrameChange = null,\n      onLoop = null,\n      textures,\n      updateAnchor = false,\n      ...rest\n    } = options;\n    const [firstFrame] = textures;\n    super({\n      ...rest,\n      texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture\n    });\n    this._textures = null;\n    this._durations = null;\n    this._autoUpdate = autoUpdate;\n    this._isConnectedToTicker = false;\n    this.animationSpeed = animationSpeed;\n    this.loop = loop;\n    this.updateAnchor = updateAnchor;\n    this.onComplete = onComplete;\n    this.onFrameChange = onFrameChange;\n    this.onLoop = onLoop;\n    this._currentTime = 0;\n    this._playing = false;\n    this._previousFrame = null;\n    this.textures = textures;\n    if (autoPlay) {\n      this.play();\n    }\n  }\n  /**\n   * Stops the animation playback and freezes the current frame.\n   * Does not reset the current frame or animation progress.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *         Texture.from('walk3.png')\n   *     ],\n   *     autoPlay: true\n   * });\n   *\n   * // Stop at current frame\n   * sprite.stop();\n   *\n   * // Stop at specific frame\n   * sprite.gotoAndStop(1); // Stops at second frame\n   *\n   * // Stop and reset\n   * sprite.stop();\n   * sprite.currentFrame = 0;\n   *\n   * // Stop with completion check\n   * if (sprite.playing) {\n   *     sprite.stop();\n   *     sprite.onComplete?.();\n   * }\n   * ```\n   * @see {@link AnimatedSprite#play} For starting playback\n   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame\n   * @see {@link AnimatedSprite#playing} For checking play state\n   */\n  stop() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  /**\n   * Starts or resumes the animation playback.\n   * If the animation was previously stopped, it will continue from where it left off.\n   * @example\n   * ```ts\n   * // Basic playback\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *     ],\n   *     autoPlay: false\n   * });\n   * sprite.play();\n   *\n   * // Play after stopping\n   * sprite.stop();\n   * sprite.currentFrame = 0; // Reset to start\n   * sprite.play(); // Play from beginning\n   *\n   * // Play with auto-update disabled\n   * sprite.autoUpdate = false;\n   * sprite.play();\n   * app.ticker.add(() => {\n   *     sprite.update(app.ticker); // Manual updates\n   * });\n   * ```\n   * @see {@link AnimatedSprite#stop} For stopping playback\n   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame\n   * @see {@link AnimatedSprite#playing} For checking play state\n   */\n  play() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  }\n  /**\n   * Stops the AnimatedSprite and sets it to a specific frame.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *         Texture.from('walk3.png'),\n   *     ]\n   * });\n   *\n   * // Go to specific frames\n   * sprite.gotoAndStop(0);  // First frame\n   * sprite.gotoAndStop(2);  // Third frame\n   *\n   * // Jump to last frame\n   * sprite.gotoAndStop(sprite.totalFrames - 1);\n   * ```\n   * @param frameNumber - Frame index to stop at (0-based)\n   * @throws {Error} If frameNumber is out of bounds\n   * @see {@link AnimatedSprite#gotoAndPlay} For going to a frame and playing\n   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame\n   * @see {@link AnimatedSprite#totalFrames} For total number of frames\n   */\n  gotoAndStop(frameNumber) {\n    this.stop();\n    this.currentFrame = frameNumber;\n  }\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite from that point.\n   * Combines frame navigation and playback start in one operation.\n   * @example\n   * ```ts\n   * // Start from specific frame\n   * sprite.gotoAndPlay(1); // Starts playing from second frame\n   * ```\n   * @param frameNumber - Frame index to start playing from (0-based)\n   * @throws {Error} If frameNumber is out of bounds\n   * @see {@link AnimatedSprite#gotoAndStop} For going to a frame without playing\n   * @see {@link AnimatedSprite#play} For playing from current frame\n   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame\n   */\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber;\n    this.play();\n  }\n  /**\n   * Updates the object transform for rendering. This method handles animation timing, frame updates,\n   * and manages looping behavior.\n   * @example\n   * ```ts\n   * // Create an animated sprite with manual updates\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('frame1.png'),\n   *         Texture.from('frame2.png'),\n   *         Texture.from('frame3.png')\n   *     ],\n   *     autoUpdate: false // Disable automatic updates\n   * });\n   *\n   * // Manual update with app ticker\n   * app.ticker.add((ticker) => {\n   *     sprite.update(ticker);\n   * });\n   * ```\n   * @param ticker - The ticker to use for updating the animation timing\n   * @see {@link AnimatedSprite#autoUpdate} For controlling automatic updates\n   * @see {@link AnimatedSprite#animationSpeed} For controlling animation speed\n   * @see {@link Ticker} For timing system details\n   */\n  update(ticker) {\n    if (!this._playing) {\n      return;\n    }\n    const deltaTime = ticker.deltaTime;\n    const elapsed = this.animationSpeed * deltaTime;\n    const previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this._updateTexture();\n    }\n  }\n  /** Updates the displayed texture to match the current frame index. */\n  _updateTexture() {\n    const currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this.texture = this._textures[currentFrame];\n    if (this.updateAnchor && this.texture.defaultAnchor) {\n      this.anchor.copyFrom(this.texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  }\n  /**\n   * Stops the AnimatedSprite and destroys it.\n   * This method stops the animation playback, removes it from the ticker,\n   * and cleans up any resources associated with the sprite.\n   * @param options - Options for destroying the sprite, such as whether to remove from parent\n   * @example\n   * ```ts\n   * // Destroy the sprite when done\n   * sprite.destroy();\n   * // Or with options\n   * sprite.destroy({ children: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options = false) {\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._textures.forEach((texture) => {\n        if (this.texture !== texture) {\n          texture.destroy(destroyTextureSource);\n        }\n      });\n    }\n    this._textures = [];\n    this._durations = null;\n    this.stop();\n    super.destroy(options);\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   * Uses texture frames from the cache to create an animation sequence.\n   * @example\n   * ```ts\n   * // Create from frame IDs\n   * const frameIds = [\n   *     'walk_001.png',\n   *     'walk_002.png',\n   *     'walk_003.png'\n   * ];\n   *\n   * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);\n   * walkingAnimation.play();\n   * ```\n   * @param frames - The array of frame ids to use for the animation\n   * @returns A new animated sprite using the frames\n   * @see {@link Texture.from} For texture creation from frames\n   * @see {@link Spritesheet} For loading spritesheets\n   */\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i) {\n      textures.push(Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image urls.\n   * Each image will be used as a frame in the animation.\n   * @example\n   * ```ts\n   * // Create from image URLs\n   * const images = [\n   *     'assets/walk1.png',\n   *     'assets/walk2.png',\n   *     'assets/walk3.png'\n   * ];\n   *\n   * const walkingSprite = AnimatedSprite.fromImages(images);\n   * walkingSprite.play();\n   * ```\n   * @param images - The array of image urls to use as frames\n   * @returns A new animated sprite using the images as frames\n   * @see {@link Assets} For asset loading and management\n   * @see {@link Texture.from} For texture creation from images\n   */\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i) {\n      textures.push(Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * The total number of frames in the AnimatedSprite. This is the same as number of textures\n   * assigned to the AnimatedSprite.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('frame1.png'),\n   *         Texture.from('frame2.png'),\n   *         Texture.from('frame3.png')\n   *     ]\n   * });\n   *\n   * // Get total frames\n   * console.log(sprite.totalFrames); // Outputs: 3\n   *\n   * // Use with frame navigation\n   * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame\n   * ```\n   * @readonly\n   * @see {@link AnimatedSprite#currentFrame} For the current frame index\n   * @see {@link AnimatedSprite#textures} For the array of textures\n   * @returns {number} The total number of frames\n   */\n  get totalFrames() {\n    return this._textures.length;\n  }\n  /**\n   * The array of textures or frame objects used for the animation sequence.\n   * Can be set to either an array of Textures or an array of FrameObjects with custom timing.\n   * @example\n   * ```ts\n   * // Update textures at runtime\n   * sprite.textures = [\n   *     Texture.from('run1.png'),\n   *     Texture.from('run2.png')\n   * ];\n   *\n   * // Use custom frame timing\n   * sprite.textures = [\n   *     { texture: Texture.from('explosion1.png'), time: 100 },\n   *     { texture: Texture.from('explosion2.png'), time: 200 },\n   *     { texture: Texture.from('explosion3.png'), time: 300 }\n   * ];\n   *\n   * // Use with spritesheet\n   * const sheet = await Assets.load('animations.json');\n   * sprite.textures = sheet.animations['walk'];\n   * ```\n   * @type {AnimatedSpriteFrames}\n   * @see {@link FrameObject} For frame timing options\n   * @see {@link Spritesheet} For loading from spritesheets\n   */\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n      for (let i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n        this._durations.push(value[i].time);\n      }\n    }\n    this._previousFrame = null;\n    this.gotoAndStop(0);\n    this._updateTexture();\n  }\n  /**\n   * Gets or sets the current frame index of the animation.\n   * When setting, the value will be clamped between 0 and totalFrames - 1.\n   * @example\n   * ```ts\n   * // Create an animated sprite\n   * const sprite = new AnimatedSprite({\n   *     textures: [\n   *         Texture.from('walk1.png'),\n   *         Texture.from('walk2.png'),\n   *         Texture.from('walk3.png')\n   *     ]\n   * });\n   *\n   * // Get current frame\n   * console.log(sprite.currentFrame); // 0\n   *\n   * // Set specific frame\n   * sprite.currentFrame = 1; // Show second frame\n   *\n   * // Use with frame callbacks\n   * sprite.onFrameChange = (frame) => {\n   *     console.log(`Now showing frame: ${frame}`);\n   * };\n   * sprite.currentFrame = 2;\n   * ```\n   * @throws {Error} If attempting to set a frame index out of bounds\n   * @see {@link AnimatedSprite#totalFrames} For the total number of frames\n   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame\n   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame\n   */\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n    return currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1) {\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    }\n    const previousFrame = this.currentFrame;\n    this._currentTime = value;\n    if (previousFrame !== this.currentFrame) {\n      this._updateTexture();\n    }\n  }\n  /**\n   * Indicates if the AnimatedSprite is currently playing.\n   * This is a read-only property that reflects the current playback state.\n   * @example\n   * ```ts\n   * // Check if animation is playing\n   * console.log('Playing:', sprite.playing); // true\n   *\n   * // Use with play control\n   * if (!sprite.playing) {\n   *     sprite.play();\n   * }\n   * ```\n   * @readonly\n   * @returns {boolean} True if the animation is currently playing\n   * @see {@link AnimatedSprite#play} For starting playback\n   * @see {@link AnimatedSprite#stop} For stopping playback\n   * @see {@link AnimatedSprite#loop} For controlling looping behavior\n   */\n  get playing() {\n    return this._playing;\n  }\n  /**\n   * Controls whether the animation automatically updates using the shared ticker.\n   * When enabled, the animation will update on each frame. When disabled, you must\n   * manually call update() to advance the animation.\n   * @example\n   * ```ts\n   * // Create sprite with auto-update disabled\n   * const sprite = new AnimatedSprite({\n   *     textures: [],\n   *     autoUpdate: false\n   * });\n   *\n   * // Manual update with app ticker\n   * app.ticker.add((ticker) => {\n   *     sprite.update(ticker);\n   * });\n   *\n   * // Enable auto-update later\n   * sprite.autoUpdate = true;\n   * ```\n   * @default true\n   * @see {@link AnimatedSprite#update} For manual animation updates\n   * @see {@link Ticker} For the timing system\n   */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n}\n\nexport { AnimatedSprite };\n//# sourceMappingURL=AnimatedSprite.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { Transform } from '../../utils/misc/Transform.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\n\"use strict\";\nconst _TilingSprite = class _TilingSprite extends ViewContainer {\n  constructor(...args) {\n    let options = args[0] || {};\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    if (args.length > 1) {\n      deprecation(v8_0_0, \"use new TilingSprite({ texture, width:100, height:100 }) instead\");\n      options.width = args[1];\n      options.height = args[2];\n    }\n    options = { ..._TilingSprite.defaultOptions, ...options };\n    const {\n      texture,\n      anchor,\n      tilePosition,\n      tileScale,\n      tileRotation,\n      width,\n      height,\n      applyAnchorToTexture,\n      roundPixels,\n      ...rest\n    } = options ?? {};\n    super({\n      label: \"TilingSprite\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"tilingSprite\";\n    /** @advanced */\n    this.batched = true;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    this.applyAnchorToTexture = applyAnchorToTexture;\n    this.texture = texture;\n    this._width = width ?? texture.width;\n    this._height = height ?? texture.height;\n    this._tileTransform = new Transform({\n      observer: {\n        _onUpdate: () => this.onViewUpdate()\n      }\n    });\n    if (anchor)\n      this.anchor = anchor;\n    this.tilePosition = tilePosition;\n    this.tileScale = tileScale;\n    this.tileRotation = tileRotation;\n    this.roundPixels = roundPixels ?? false;\n  }\n  /**\n   * Creates a new tiling sprite based on a source texture or image path.\n   * This is a convenience method that automatically creates and manages textures.\n   * @example\n   * ```ts\n   * // Create a new tiling sprite from an image path\n   * const pattern = TilingSprite.from('pattern.png');\n   * pattern.width = 300; // Set the width of the tiling area\n   * pattern.height = 200; // Set the height of the tiling area\n   *\n   * // Create from options\n   * const texture = Texture.from('pattern.png');\n   * const pattern = TilingSprite.from(texture, {\n   *     width: 300,\n   *     height: 200,\n   *     tileScale: { x: 0.5, y: 0.5 }\n   * });\n   * ```\n   * @param source - The source to create the sprite from. Can be a path to an image or a texture\n   * @param options - Additional options for the tiling sprite\n   * @returns A new tiling sprite based on the source\n   * @see {@link Texture.from} For texture creation details\n   * @see {@link Assets} For asset loading and management\n   */\n  static from(source, options = {}) {\n    if (typeof source === \"string\") {\n      return new _TilingSprite({\n        texture: Cache.get(source),\n        ...options\n      });\n    }\n    return new _TilingSprite({\n      texture: source,\n      ...options\n    });\n  }\n  /**\n   * @see {@link TilingSpriteOptions.applyAnchorToTexture}\n   * @deprecated since 8.0.0\n   * @advanced\n   */\n  get uvRespectAnchor() {\n    deprecation(v8_0_0, \"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead\");\n    return this.applyAnchorToTexture;\n  }\n  /** @advanced */\n  set uvRespectAnchor(value) {\n    deprecation(v8_0_0, \"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead\");\n    this.applyAnchorToTexture = value;\n  }\n  /**\n   * Changes frame clamping in corresponding textureMatrix\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   * @default 0.5\n   * @type {number}\n   * @advanced\n   */\n  get clampMargin() {\n    return this._texture.textureMatrix.clampMargin;\n  }\n  /** @advanced */\n  set clampMargin(value) {\n    this._texture.textureMatrix.clampMargin = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * - The default is `(0,0)`, this means the sprite's origin is the top left.\n   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * ```ts\n   * // Center the anchor point\n   * sprite.anchor = 0.5; // Sets both x and y to 0.5\n   * sprite.position.set(400, 300); // Sprite will be centered at this position\n   *\n   * // Set specific x/y anchor points\n   * sprite.anchor = {\n   *     x: 1, // Right edge\n   *     y: 0  // Top edge\n   * };\n   *\n   * // Using individual coordinates\n   * sprite.anchor.set(0.5, 1); // Center-bottom\n   *\n   * // For rotation around center\n   * sprite.anchor.set(0.5);\n   * sprite.rotation = Math.PI / 4; // 45 degrees around center\n   *\n   * // For scaling from center\n   * sprite.anchor.set(0.5);\n   * sprite.scale.set(2); // Scales from center point\n   * ```\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   * The offset of the tiling texture.\n   * Used to scroll or position the repeated pattern.\n   * @example\n   * ```ts\n   * // Offset the tiling pattern by 100 pixels in both x and y directions\n   * tilingSprite.tilePosition = { x: 100, y: 100 };\n   * ```\n   * @default {x: 0, y: 0}\n   */\n  get tilePosition() {\n    return this._tileTransform.position;\n  }\n  set tilePosition(value) {\n    this._tileTransform.position.copyFrom(value);\n  }\n  /**\n   * Scale of the tiling texture.\n   * Affects the size of each repeated instance of the texture.\n   * @example\n   * ```ts\n   * // Scale the texture by 1.5 in both x and y directions\n   * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n   * ```\n   * @default {x: 1, y: 1}\n   */\n  get tileScale() {\n    return this._tileTransform.scale;\n  }\n  set tileScale(value) {\n    typeof value === \"number\" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n  }\n  set tileRotation(value) {\n    this._tileTransform.rotation = value;\n  }\n  /**\n   * Rotation of the tiling texture in radians.\n   * This controls the rotation applied to the texture before tiling.\n   * @example\n   * ```ts\n   * // Rotate the texture by 45 degrees (in radians)\n   * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n   * ```\n   * @default 0\n   */\n  get tileRotation() {\n    return this._tileTransform.rotation;\n  }\n  /**\n   * The transform object that controls the tiling texture's position, scale, and rotation.\n   * This transform is independent of the sprite's own transform properties.\n   * @example\n   * ```ts\n   * // Access transform properties directly\n   * sprite.tileTransform.position.set(100, 50);\n   * sprite.tileTransform.scale.set(2);\n   * sprite.tileTransform.rotation = Math.PI / 4;\n   *\n   * // Create smooth scrolling animation\n   * app.ticker.add(() => {\n   *     sprite.tileTransform.position.x += 1;\n   *     sprite.tileTransform.rotation += 0.01;\n   * });\n   *\n   * // Reset transform\n   * sprite.tileTransform.position.set(0);\n   * sprite.tileTransform.scale.set(1);\n   * sprite.tileTransform.rotation = 0;\n   * ```\n   * @returns {Transform} The transform object for the tiling texture\n   * @see {@link Transform} For transform operations\n   * @see {@link TilingSprite#tilePosition} For position control\n   * @see {@link TilingSprite#tileScale} For scale control\n   * @see {@link TilingSprite#tileRotation} For rotation control\n   * @advanced\n   */\n  get tileTransform() {\n    return this._tileTransform;\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The texture to use for tiling.\n   * This is the image that will be repeated across the sprite.\n   * @example\n   * ```ts\n   * // Use a texture from the asset cache\n   * tilingSprite.texture = Texture.from('assets/pattern.png');\n   * ```\n   * @default Texture.WHITE\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.\n   * @example\n   * ```ts\n   * // Create a tiling sprite\n   * const sprite = new TilingSprite({\n   *     texture: Texture.from('pattern.png'),\n   *     width: 500,\n   *     height: 300\n   * });\n   *\n   * // Adjust width dynamically\n   * sprite.width = 800; // Expands tiling area\n   *\n   * // Update on resize\n   * window.addEventListener('resize', () => {\n   *     sprite.width = app.screen.width;\n   * });\n   * ```\n   * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n   * @see {@link TilingSprite#height} For setting height\n   */\n  set width(value) {\n    this._width = value;\n    this.onViewUpdate();\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    this._height = value;\n    this.onViewUpdate();\n  }\n  /**\n   * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.\n   * @example\n   * ```ts\n   * // Create a tiling sprite\n   * const sprite = new TilingSprite({\n   *     texture: Texture.from('pattern.png'),\n   *     width: 500,\n   *     height: 300\n   * });\n   *\n   * // Adjust width dynamically\n   * sprite.height = 800; // Expands tiling area\n   *\n   * // Update on resize\n   * window.addEventListener('resize', () => {\n   *     sprite.height = app.screen.height;\n   * });\n   * ```\n   * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n   * @see {@link TilingSprite#width} For setting width\n   */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Sets the size of the TilingSprite to the specified width and height.\n   * This is faster than setting width and height separately as it only triggers one update.\n   * @example\n   * ```ts\n   * // Set specific dimensions\n   * sprite.setSize(300, 200); // Width: 300, Height: 200\n   *\n   * // Set uniform size (square)\n   * sprite.setSize(400); // Width: 400, Height: 400\n   *\n   * // Set size using object\n   * sprite.setSize({\n   *     width: 500,\n   *     height: 300\n   * });\n   * ```\n   * @param value - This can be either a number for uniform sizing or a Size object with width/height properties\n   * @param height - The height to set. Defaults to the value of `width` if not provided\n   * @see {@link TilingSprite#width} For setting width only\n   * @see {@link TilingSprite#height} For setting height only\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    }\n    this._width = value;\n    this._height = height ?? value;\n    this.onViewUpdate();\n  }\n  /**\n   * Retrieves the size of the TilingSprite as a {@link Size} object.\n   * This method is more efficient than getting width and height separately as it only allocates one object.\n   * @example\n   * ```ts\n   * // Get basic size\n   * const size = sprite.getSize();\n   * console.log(`Size: ${size.width}x${size.height}`);\n   *\n   * // Reuse existing size object\n   * const reuseSize = { width: 0, height: 0 };\n   * sprite.getSize(reuseSize);\n   * ```\n   * @param out - Optional object to store the size in, to avoid allocating a new object\n   * @returns The size of the TilingSprite\n   * @see {@link TilingSprite#width} For getting just the width\n   * @see {@link TilingSprite#height} For getting just the height\n   * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = this._width;\n    out.height = this._height;\n    return out;\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const width = this._width;\n    const height = this._height;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Checks if the object contains the given point in local coordinates.\n   * Takes into account the anchor offset when determining boundaries.\n   * @example\n   * ```ts\n   * // Create a tiling sprite\n   * const sprite = new TilingSprite({\n   *     texture: Texture.from('pattern.png'),\n   *     width: 200,\n   *     height: 100,\n   *     anchor: 0.5 // Center anchor\n   * });\n   *\n   * // Basic point check\n   * const contains = sprite.containsPoint({ x: 50, y: 25 });\n   * console.log('Point is inside:', contains);\n   *\n   * // Check with different anchors\n   * sprite.anchor.set(0); // Top-left anchor\n   * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is within the sprite's bounds\n   * @see {@link TilingSprite#toLocal} For converting global coordinates to local\n   * @see {@link TilingSprite#anchor} For understanding boundary calculations\n   */\n  containsPoint(point) {\n    const width = this._width;\n    const height = this._height;\n    const x1 = -width * this._anchor._x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this._anchor._y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @example\n   * tilingSprite.destroy();\n   * tilingSprite.destroy(true);\n   * tilingSprite.destroy({ texture: true, textureSource: true });\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this._anchor = null;\n    this._tileTransform = null;\n    this._bounds = null;\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n  }\n};\n/**\n * Default options used when creating a TilingSprite instance.\n * These values are used as fallbacks when specific options are not provided.\n * @example\n * ```ts\n * // Override default options globally\n * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');\n * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };\n *\n * // Create sprite using default options\n * const sprite = new TilingSprite();\n * // Will use defaultPattern.png and scale 2x\n * ```\n * @type {TilingSpriteOptions}\n * @see {@link TilingSpriteOptions} For all available options\n * @see {@link TilingSprite.from} For creating sprites with custom options\n * @see {@link Texture.EMPTY} For the default empty texture\n */\n_TilingSprite.defaultOptions = {\n  /** The texture to use for the sprite. */\n  texture: Texture.EMPTY,\n  /** The anchor point of the sprite */\n  anchor: { x: 0, y: 0 },\n  /** The offset of the image that is being tiled. */\n  tilePosition: { x: 0, y: 0 },\n  /** Scaling of the image that is being tiled. */\n  tileScale: { x: 1, y: 1 },\n  /** The rotation of the image that is being tiled. */\n  tileRotation: 0,\n  /**\n   * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n   * local space.\n   *\n   * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n   * this, the top-left corner always gets the (0, 0) texture coordinate.\n   * @default false\n   */\n  applyAnchorToTexture: false\n};\nlet TilingSprite = _TilingSprite;\n\nexport { TilingSprite };\n//# sourceMappingURL=TilingSprite.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpriteGpuData, NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.default2d;\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpriteGpuData, TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["Sprite","ViewContainer","constructor","options","Texture","EMPTY","texture","anchor","roundPixels","width","height","rest","super","label","this","renderPipeId","batched","_visualBounds","minX","maxX","minY","maxY","_anchor","ObservablePoint","_onUpdate","onViewUpdate","defaultAnchor","allowChildren","from","source","skipCache","value","currentTexture","_texture","dynamic","off","on","_width","_setWidth","orig","_height","_setHeight","visualBounds","updateQuadBounds","sourceBounds","deprecation","updateBounds","bounds","_bounds","_x","_y","destroy","destroyTextureSource","textureSource","_gpuData","set","copyFrom","Math","abs","scale","x","y","getSize","out","setSize","_Spritesheet","optionsOrTexture","arg1","linkedSheets","TextureSource","data","cachePrefix","textures","animations","metaResolution","parseFloat","meta","resolution","_resolution","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","parse","Promise","resolve","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","trimmed","Rectangle","floor","w","h","rotated","spriteSourceSize","rotate","defaultBorders","borders","toString","animName","frameName","push","callback","call","setTimeout","destroyBase","Spritesheet","validImages","getCacheableAssets","asset","ignoreMultiPack","forEach","key","basePath","path","dirname","item","out2","related_multi_packs","assign","spritesheetAsset","extension","ExtensionType","Asset","cache","test","resolver","type","ResolveParser","name","split","pop","format","includes","Resolver","RETINA_PREFIX","exec","src","loader","id","LoadParser","priority","LoaderParserPriority","Normal","async","extname","toLowerCase","imageTexture","imageFilename","textureOptions","lastIndexOf","imagePath","copySearchParams","image","load","spritesheet","multiPacks","Array","isArray","promises","itemUrl","res","all","concat","filter","sp","unload","_resolvedAsset","_sourceOrigin","extensions","add","AnimatedSprite","args","autoUpdate","animationSpeed","autoPlay","loop","onComplete","onFrameChange","onLoop","updateAnchor","firstFrame","_textures","_durations","_autoUpdate","_isConnectedToTicker","_currentTime","_playing","_previousFrame","play","stop","Ticker","shared","remove","update","UPDATE_PRIORITY","HIGH","gotoAndStop","frameNumber","currentFrame","gotoAndPlay","ticker","deltaTime","elapsed","previousFrame","lag","sign","_updateTexture","fromFrames","fromImages","images","totalFrames","time","Error","playing","_TilingSprite","v8_0_0","defaultOptions","tilePosition","tileScale","tileRotation","applyAnchorToTexture","_tileTransform","Transform","observer","Cache","get","uvRespectAnchor","clampMargin","textureMatrix","position","rotation","tileTransform","containsPoint","point","x1","y1","TilingSprite","BatchableSprite","batcherName","topology","attributeSize","indexSize","packAsQuad","_attributeStart","_batcher","_batch","blendMode","renderable","groupBlendMode","color","groupColorAlpha","reset","SpritePipe","renderer","_renderer","addRenderable","sprite","instructionSet","gpuSprite","_getGpuSprite","didViewUpdate","_updateBatchableSprite","renderPipes","batch","addToBatch","updateRenderable","updateElement","validateRenderable","checkAndUpdateTexture","batchableSprite","uid","_initGPUSprite","transform","groupTransform","_roundPixels","WebGLPipes","WebGPUPipes","CanvasPipes","_NineSliceGeometry","PlaneGeometry","verticesX","verticesY","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updateUvs","updatePositions","p","positions","scaleW","scaleH","min","anchorOffsetX","anchorOffsetY","getBuffer","uvs","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","BatchableMesh","geometry","NineSliceSpritePipe","setTexture","gpuData","batchableMesh","tilingBit","vertex","header","main","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","compileHighShaderGpuProgram","bits","localUniformBit","roundPixelsBit","compileHighShaderGlProgram","localUniformBitGl","roundPixelsBitGl","tilingUniforms","UniformGroup","uMapCoord","Matrix","uClampFrame","Float32Array","uClampOffset","uTextureTransform","uSizeAnchor","resources","localUniforms","uTransformMatrix","uColor","uRound","uTexture","uSampler","style","updateUniforms","matrix","anchorX","anchorY","textureWidth","textureHeight","uniforms","a","b","c","d","tx","ty","invert","mapCoord","sharedQuad","MeshGeometry","indices","Uint32Array","TilingSpriteGpuData","canBatch","slice","shader","TilingSpritePipe","_state","State","default2d","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","tilingSprite","batcher","_updateBatchableMesh","break","execute","groups","globalUniforms","bindGroup","color32BitToUniform","getAdjustedBlendModeBlend","_source","encoder","draw","state","_initTilingSpriteData","renderableData","addressMode","array","stride","offset","index","size","applyMatrix","setUvs","setPositions","_nonPowOf2wrapping","RendererType","WEBGL","context","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo"],"mappings":"gXAOA,MAAMA,UAAeC,EAInB,WAAAC,CAAYC,EAAUC,EAAQC,OACxBF,aAAmBC,IACrBD,EAAU,CAAEG,QAASH,IAEvB,MAAMG,QAAEA,EAAUF,EAAQC,MAAAE,OAAOA,EAAAC,YAAQA,QAAaC,EAAAC,OAAOA,KAAWC,GAASR,EACjFS,MAAM,CACJC,MAAO,YACJF,IAGLG,KAAKC,aAAe,SAEpBD,KAAKE,SAAU,EACfF,KAAKG,cAAgB,CAAEC,KAAM,EAAGC,KAAM,EAAGC,KAAM,EAAGC,KAAM,GACxDP,KAAKQ,QAAU,IAAIC,EACjB,CACEC,UAAW,KACTV,KAAKW,kBAIPlB,EACFO,KAAKP,OAASA,EACLD,EAAQoB,gBACjBZ,KAAKP,OAASD,EAAQoB,eAExBZ,KAAKR,QAAUA,EACfQ,KAAKa,eAAgB,EACrBb,KAAKN,YAAcA,IAAe,OACpB,IAAVC,IACFK,KAAKL,MAAQA,QACA,IAAXC,IACFI,KAAKJ,OAASA,EAClB,CAuBA,WAAOkB,CAAKC,EAAQC,GAAY,GAC9B,OACS,IAAI9B,EADT6B,aAAkBzB,EACFyB,EAEFzB,EAAQwB,KAAKC,EAAQC,GACzC,CACA,WAAIxB,CAAQyB,GACVA,IAAUA,EAAQ3B,EAAQC,OAC1B,MAAM2B,EAAiBlB,KAAKmB,SACxBD,IAAmBD,IAEnBC,GAAkBA,EAAeE,SACnCF,EAAeG,IAAI,SAAUrB,KAAKW,aAAcX,MAC9CiB,EAAMG,SACRH,EAAMK,GAAG,SAAUtB,KAAKW,aAAcX,MACxCA,KAAKmB,SAAWF,EACZjB,KAAKuB,QACPvB,KAAKwB,UAAUxB,KAAKuB,OAAQvB,KAAKmB,SAASM,KAAK9B,OAE7CK,KAAK0B,SACP1B,KAAK2B,WAAW3B,KAAK0B,QAAS1B,KAAKmB,SAASM,KAAK7B,QAEnDI,KAAKW,eACP,CAwBA,WAAInB,GACF,OAAOQ,KAAKmB,QACd,CAgBA,gBAAIS,GAEF,OADAC,EAAiB7B,KAAKG,cAAeH,KAAKQ,QAASR,KAAKmB,UACjDnB,KAAKG,aACd,CAKA,gBAAI2B,GAEF,OADAC,EAAY,QAAS,gEACd/B,KAAK4B,YACd,CAEA,YAAAI,GACE,MAAMvC,EAASO,KAAKQ,QACdhB,EAAUQ,KAAKmB,SACfc,EAASjC,KAAKkC,SACdvC,MAAEA,EAAAC,OAAOA,GAAWJ,EAAQiC,KAClCQ,EAAO7B,MAAQX,EAAO0C,GAAKxC,EAC3BsC,EAAO5B,KAAO4B,EAAO7B,KAAOT,EAC5BsC,EAAO3B,MAAQb,EAAO2C,GAAKxC,EAC3BqC,EAAO1B,KAAO0B,EAAO3B,KAAOV,CAC9B,CAUA,OAAAyC,CAAQhD,GAAU,GAChBS,MAAMuC,QAAQhD,GAEd,GAD0C,kBAAZA,EAAwBA,EAAUA,GAASG,QACrD,CAClB,MAAM8C,EAA0C,kBAAZjD,EAAwBA,EAAUA,GAASkD,cAC/EvC,KAAKmB,SAASkB,QAAQC,EACxB,CACAtC,KAAKmB,SAAW,KAChBnB,KAAKG,cAAgB,KACrBH,KAAKkC,QAAU,KACflC,KAAKQ,QAAU,KACfR,KAAKwC,SAAW,IAClB,CAkCA,UAAI/C,GACF,OAAOO,KAAKQ,OACd,CACA,UAAIf,CAAOwB,GACQ,iBAAVA,EAAqBjB,KAAKQ,QAAQiC,IAAIxB,GAASjB,KAAKQ,QAAQkC,SAASzB,EAC9E,CAqBA,SAAItB,GACF,OAAOgD,KAAKC,IAAI5C,KAAK6C,MAAMC,GAAK9C,KAAKmB,SAASM,KAAK9B,KACrD,CACA,SAAIA,CAAMsB,GACRjB,KAAKwB,UAAUP,EAAOjB,KAAKmB,SAASM,KAAK9B,OACzCK,KAAKuB,OAASN,CAChB,CAqBA,UAAIrB,GACF,OAAO+C,KAAKC,IAAI5C,KAAK6C,MAAME,GAAK/C,KAAKmB,SAASM,KAAK7B,MACrD,CACA,UAAIA,CAAOqB,GACTjB,KAAK2B,WAAWV,EAAOjB,KAAKmB,SAASM,KAAK7B,QAC1CI,KAAK0B,QAAUT,CACjB,CAqBA,OAAA+B,CAAQC,GAIN,OAHAA,IAAQA,EAAM,IACdA,EAAItD,MAAQgD,KAAKC,IAAI5C,KAAK6C,MAAMC,GAAK9C,KAAKmB,SAASM,KAAK9B,MACxDsD,EAAIrD,OAAS+C,KAAKC,IAAI5C,KAAK6C,MAAME,GAAK/C,KAAKmB,SAASM,KAAK7B,OAClDqD,CACT,CA+BA,OAAAC,CAAQjC,EAAOrB,GACQ,iBAAVqB,GACTrB,EAASqB,EAAMrB,QAAUqB,EAAMtB,MAC/BsB,EAAQA,EAAMtB,OAEdC,IAAWA,EAASqB,QAEZ,IAAVA,GAAoBjB,KAAKwB,UAAUP,EAAOjB,KAAKmB,SAASM,KAAK9B,YAClD,IAAXC,GAAqBI,KAAK2B,WAAW/B,EAAQI,KAAKmB,SAASM,KAAK7B,OAClE,EC1UF,MAAMuD,EAAe,MAAMA,EACzB,WAAA/D,CAAYgE,EAAkBC,GAE5BrD,KAAKsD,aAAe,GACpB,IAAIjE,EAAU+D,EACVA,GAAkBrC,kBAAkBwC,IACtClE,EAAU,CACRG,QAAS4D,EACTI,KAAMH,IAGV,MAAM7D,QAAEA,EAAAgE,KAASA,EAAAC,YAAMA,EAAc,IAAOpE,EAC5CW,KAAKyD,YAAcA,EACnBzD,KAAKmB,SAAW3B,aAAmBF,EAAUE,EAAU,KACvDQ,KAAKuC,cAAgB/C,EAAQuB,OAC7Bf,KAAK0D,SAAW,CAAA,EAChB1D,KAAK2D,WAAa,CAAA,EAClB3D,KAAKwD,KAAOA,EACZ,MAAMI,EAAiBC,WAAWL,EAAKM,KAAKjB,OACxCe,GACF5D,KAAK+D,WAAaH,EAClBpE,EAAQuB,OAAOgD,WAAa/D,KAAK+D,YAEjC/D,KAAK+D,WAAavE,EAAQuB,OAAOiD,YAEnChE,KAAKiE,QAAUjE,KAAKwD,KAAKU,OACzBlE,KAAKmE,WAAaC,OAAOC,KAAKrE,KAAKiE,SACnCjE,KAAKsE,YAAc,EACnBtE,KAAKuE,UAAY,IACnB,CAKA,KAAAC,GACE,OAAO,IAAIC,QAASC,IAClB1E,KAAKuE,UAAYG,EACjB1E,KAAKsE,YAAc,EACftE,KAAKmE,WAAWQ,QAAUxB,EAAayB,YACzC5E,KAAK6E,eAAe,GACpB7E,KAAK8E,qBACL9E,KAAK+E,kBAEL/E,KAAKgF,cAGX,CAKA,cAAAH,CAAeI,GACb,IAAIC,EAAaD,EACjB,MAAME,EAAYhC,EAAayB,WAC/B,KAAOM,EAAaD,EAAoBE,GAAaD,EAAalF,KAAKmE,WAAWQ,QAAQ,CACxF,MAAMS,EAAIpF,KAAKmE,WAAWe,GACpB1B,EAAOxD,KAAKiE,QAAQmB,GACpBC,EAAO7B,EAAK8B,MAClB,GAAID,EAAM,CACR,IAAIC,EAAQ,KACRC,EAAO,KACX,MAAMC,GAA8B,IAAjBhC,EAAKiC,SAAqBjC,EAAKgC,WAAahC,EAAKgC,WAAahC,EAAK8B,MAChF7D,EAAO,IAAIiE,EACf,EACA,EACA/C,KAAKgD,MAAMH,EAAWI,GAAK5F,KAAK+D,WAChCpB,KAAKgD,MAAMH,EAAWK,GAAK7F,KAAK+D,YAGhCuB,EADE9B,EAAKsC,QACC,IAAIJ,EACV/C,KAAKgD,MAAMN,EAAKvC,GAAK9C,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKtC,GAAK/C,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKQ,GAAK7F,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKO,GAAK5F,KAAK+D,YAGpB,IAAI2B,EACV/C,KAAKgD,MAAMN,EAAKvC,GAAK9C,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKtC,GAAK/C,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKO,GAAK5F,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKQ,GAAK7F,KAAK+D,aAGT,IAAjBP,EAAKiC,SAAqBjC,EAAKuC,mBACjCR,EAAO,IAAIG,EACT/C,KAAKgD,MAAMnC,EAAKuC,iBAAiBjD,GAAK9C,KAAK+D,WAC3CpB,KAAKgD,MAAMnC,EAAKuC,iBAAiBhD,GAAK/C,KAAK+D,WAC3CpB,KAAKgD,MAAMN,EAAKO,GAAK5F,KAAK+D,WAC1BpB,KAAKgD,MAAMN,EAAKQ,GAAK7F,KAAK+D,aAG9B/D,KAAK0D,SAAS0B,GAAK,IAAI9F,EAAQ,CAC7ByB,OAAQf,KAAKuC,cACb+C,QACA7D,OACA8D,OACAS,OAAQxC,EAAKsC,QAAU,EAAI,EAC3BlF,cAAe4C,EAAK/D,OACpBwG,eAAgBzC,EAAK0C,QACrBnG,MAAOqF,EAAEe,YAEb,CACAjB,GACF,CACF,CAEA,kBAAAJ,GACE,MAAMnB,EAAa3D,KAAKwD,KAAKG,YAAc,CAAA,EAC3C,IAAA,MAAWyC,KAAYzC,EAAY,CACjC3D,KAAK2D,WAAWyC,GAAY,GAC5B,IAAA,IAAShB,EAAI,EAAGA,EAAIzB,EAAWyC,GAAUzB,OAAQS,IAAK,CACpD,MAAMiB,EAAY1C,EAAWyC,GAAUhB,GACvCpF,KAAK2D,WAAWyC,GAAUE,KAAKtG,KAAK0D,SAAS2C,GAC/C,CACF,CACF,CAEA,cAAAtB,GACE,MAAMwB,EAAWvG,KAAKuE,UACtBvE,KAAKuE,UAAY,KACjBvE,KAAKsE,YAAc,EACnBiC,EAASC,KAAKxG,KAAMA,KAAK0D,SAC3B,CAEA,UAAAsB,GACEhF,KAAK6E,eAAe7E,KAAKsE,YAAcnB,EAAayB,YACpD5E,KAAKsE,cACLmC,WAAW,KACLzG,KAAKsE,YAAcnB,EAAayB,WAAa5E,KAAKmE,WAAWQ,OAC/D3E,KAAKgF,cAELhF,KAAK8E,qBACL9E,KAAK+E,mBAEN,EACL,CAKA,OAAA1C,CAAQqE,GAAc,GACpB,IAAA,MAAWtB,KAAKpF,KAAK0D,SACnB1D,KAAK0D,SAAS0B,GAAG/C,UAEnBrC,KAAKiE,QAAU,KACfjE,KAAKmE,WAAa,KAClBnE,KAAKwD,KAAO,KACZxD,KAAK0D,SAAW,KACZgD,IACF1G,KAAKmB,UAAUkB,UACfrC,KAAKuC,cAAcF,WAErBrC,KAAKmB,SAAW,KAChBnB,KAAKuC,cAAgB,KACrBvC,KAAKsD,aAAe,EACtB,GAMFH,EAAayB,WAAa,IAC1B,IAAI+B,EAAcxD,EC9JlB,MAAMyD,EAAc,CAClB,MACA,MACA,OACA,OACA,OACA,QACA,OACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,QAEF,SAASC,EAAmBxC,EAAMyC,EAAOC,GACvC,MAAM9D,EAAM,CAAA,EAOZ,GANAoB,EAAK2C,QAASC,IACZhE,EAAIgE,GAAOH,IAEb1C,OAAOC,KAAKyC,EAAMpD,UAAUsD,QAASC,IACnChE,EAAI,GAAG6D,EAAMrD,cAAcwD,KAASH,EAAMpD,SAASuD,MAEhDF,EAAiB,CACpB,MAAMG,EAAWC,EAAKC,QAAQ/C,EAAK,IACnCyC,EAAMxD,aAAa0D,QAAQ,CAACK,EAAMjC,KAChC,MAAMkC,EAAOT,EAAmB,CAAC,GAAGK,KAAYJ,EAAMtD,KAAKM,KAAKyD,oBAAoBnC,MAAOiC,GAAM,GACjGjD,OAAOoD,OAAOvE,EAAKqE,IAEvB,CACA,OAAOrE,CACT,CACA,MAAMwE,EAAmB,CACvBC,UAAWC,EAAcC,MAEzBC,MAAO,CACLC,KAAOhB,GAAUA,aAAiBH,EAClCE,mBAAoB,CAACxC,EAAMyC,IAAUD,EAAmBxC,EAAMyC,GAAO,IAGvEiB,SAAU,CACRL,UAAW,CACTM,KAAML,EAAcM,cACpBC,KAAM,sBAERJ,KAAO7G,IACL,MACMkH,EADUlH,EAAMkH,MAAM,KAAK,GACXA,MAAM,KACtBT,EAAYS,EAAMC,MAClBC,EAASF,EAAMC,MACrB,MAAqB,SAAdV,GAAwBd,EAAY0B,SAASD,IAEtD7D,MAAQvD,IACN,MAAMkH,EAAQlH,EAAMkH,MAAM,KAC1B,MAAO,CACLpE,WAAYF,WAAW0E,EAASC,cAAcC,KAAKxH,KAAS,IAAM,KAClEoH,OAAQF,EAAMA,EAAMxD,OAAS,GAC7B+D,IAAKzH,KAUX0H,OAAQ,CAENT,KAAM,oBACNU,GAAI,cACJlB,UAAW,CACTM,KAAML,EAAckB,WACpBC,SAAUC,EAAqBC,OAC/Bd,KAAM,qBAERe,UAAM,MAAUnC,EAAOzH,IAC8B,UAA5C8H,EAAK+B,QAAQ7J,EAAQqJ,KAAKS,iBAA+BrC,EAAM5C,OAExE,WAAMM,CAAMsC,EAAOzH,EAASsJ,GAC1B,MACEnJ,QAAS4J,EAAAC,cAETA,EAAAC,eAEAA,EAAA7F,YAEAA,GAEEpE,GAASmE,MAAQ,CAAA,EACrB,IAIIhE,EAJA0H,EAAWC,EAAKC,QAAQ/H,EAAQqJ,KAKpC,GAJIxB,GAAYA,EAASqC,YAAY,OAASrC,EAASvC,OAAS,IAC9DuC,GAAY,KAGVkC,aAAwB9J,EAC1BE,EAAU4J,MACL,CACL,MAAMI,EAAYC,EAAiBvC,GAAYmC,GAAiBvC,EAAMhD,KAAK4F,OAAQrK,EAAQqJ,KAE3FlJ,SADqBmJ,EAAOgB,KAAK,CAAC,CAAEjB,IAAKc,EAAWhG,KAAM8F,MACzCE,EACnB,CACA,MAAMI,EAAc,IAAIjD,EAAY,CAClCnH,QAASA,EAAQuB,OACjByC,KAAMsD,EACNrD,sBAEImG,EAAYpF,QAClB,MAAMqF,EAAa/C,GAAOhD,MAAMyD,oBAChC,GAAIuC,MAAMC,QAAQF,GAAa,CAC7B,MAAMG,EAAW,GACjB,IAAA,MAAW3C,KAAQwC,EAAY,CAC7B,GAAoB,iBAATxC,EACT,SAEF,IAAI4C,EAAU/C,EAAWG,EACrBhI,EAAQmE,MAAMuD,kBAGlBkD,EAAUR,EAAiBQ,EAAS5K,EAAQqJ,KAC5CsB,EAAS1D,KAAKqC,EAAOgB,KAAK,CACxBjB,IAAKuB,EACLzG,KAAM,CACJ8F,iBACAvC,iBAAiB,MAGvB,CACA,MAAMmD,QAAYzF,QAAQ0F,IAAIH,GAC9BJ,EAAYtG,aAAe4G,EAC3BA,EAAIlD,QAASK,IACXA,EAAK/D,aAAe,CAACsG,GAAaQ,OAAOR,EAAYtG,aAAa+G,OAAQC,GAAOA,IAAOjD,KAE5F,CACA,OAAOuC,CACT,EACA,YAAMW,CAAOX,EAAaY,EAAgB7B,SAClCA,EAAO4B,OAAOX,EAAYrH,cAAckI,eAC9Cb,EAAYvH,SAAQ,EACtB,ICnJJqI,EAAWC,IAAIlD,GCEf,MAAMmD,UAAuB1L,EAC3B,WAAAE,IAAeyL,GACb,IAAIxL,EAAUwL,EAAK,GACff,MAAMC,QAAQc,EAAK,MACrBxL,EAAU,CACRqE,SAAUmH,EAAK,GACfC,WAAYD,EAAK,KAGrB,MAAME,eACJA,EAAiB,EAAAC,SACjBA,GAAW,EAAAF,WACXA,GAAa,EAAAG,KACbA,GAAO,EAAAC,WACPA,EAAa,KAAAC,cACbA,EAAgB,KAAAC,OAChBA,EAAS,KAAA1H,SACTA,EAAA2H,aACAA,GAAe,KACZxL,GACDR,GACGiM,GAAc5H,EACrB5D,MAAM,IACDD,EACHL,QAAS8L,aAAsBhM,EAAUgM,EAAaA,EAAW9L,UAEnEQ,KAAKuL,UAAY,KACjBvL,KAAKwL,WAAa,KAClBxL,KAAKyL,YAAcX,EACnB9K,KAAK0L,sBAAuB,EAC5B1L,KAAK+K,eAAiBA,EACtB/K,KAAKiL,KAAOA,EACZjL,KAAKqL,aAAeA,EACpBrL,KAAKkL,WAAaA,EAClBlL,KAAKmL,cAAgBA,EACrBnL,KAAKoL,OAASA,EACdpL,KAAK2L,aAAe,EACpB3L,KAAK4L,UAAW,EAChB5L,KAAK6L,eAAiB,KACtB7L,KAAK0D,SAAWA,EACZsH,GACFhL,KAAK8L,MAET,CAoCA,IAAAC,GACO/L,KAAK4L,WAGV5L,KAAK4L,UAAW,EACZ5L,KAAKyL,aAAezL,KAAK0L,uBAC3BM,EAAOC,OAAOC,OAAOlM,KAAKmM,OAAQnM,MAClCA,KAAK0L,sBAAuB,GAEhC,CAgCA,IAAAI,GACM9L,KAAK4L,WAGT5L,KAAK4L,UAAW,EACZ5L,KAAKyL,cAAgBzL,KAAK0L,uBAC5BM,EAAOC,OAAOtB,IAAI3K,KAAKmM,OAAQnM,KAAMoM,EAAgBC,MACrDrM,KAAK0L,sBAAuB,GAEhC,CA2BA,WAAAY,CAAYC,GACVvM,KAAK+L,OACL/L,KAAKwM,aAAeD,CACtB,CAeA,WAAAE,CAAYF,GACVvM,KAAKwM,aAAeD,EACpBvM,KAAK8L,MACP,CA0BA,MAAAK,CAAOO,GACL,IAAK1M,KAAK4L,SACR,OAEF,MAAMe,EAAYD,EAAOC,UACnBC,EAAU5M,KAAK+K,eAAiB4B,EAChCE,EAAgB7M,KAAKwM,aAC3B,GAAwB,OAApBxM,KAAKwL,WAAqB,CAC5B,IAAIsB,EAAM9M,KAAK2L,aAAe,EAAI3L,KAAKwL,WAAWxL,KAAKwM,cAEvD,IADAM,GAAOF,EAAU,GAAK,IACfE,EAAM,GACX9M,KAAK2L,eACLmB,GAAO9M,KAAKwL,WAAWxL,KAAKwM,cAE9B,MAAMO,EAAOpK,KAAKoK,KAAK/M,KAAK+K,eAAiB4B,GAE7C,IADA3M,KAAK2L,aAAehJ,KAAKgD,MAAM3F,KAAK2L,cAC7BmB,GAAO9M,KAAKwL,WAAWxL,KAAKwM,eACjCM,GAAO9M,KAAKwL,WAAWxL,KAAKwM,cAAgBO,EAC5C/M,KAAK2L,cAAgBoB,EAEvB/M,KAAK2L,cAAgBmB,EAAM9M,KAAKwL,WAAWxL,KAAKwM,aAClD,MACExM,KAAK2L,cAAgBiB,EAEnB5M,KAAK2L,aAAe,IAAM3L,KAAKiL,MACjCjL,KAAKsM,YAAY,GACbtM,KAAKkL,YACPlL,KAAKkL,cAEElL,KAAK2L,cAAgB3L,KAAKuL,UAAU5G,SAAW3E,KAAKiL,MAC7DjL,KAAKsM,YAAYtM,KAAKuL,UAAU5G,OAAS,GACrC3E,KAAKkL,YACPlL,KAAKkL,cAEE2B,IAAkB7M,KAAKwM,eAC5BxM,KAAKiL,MAAQjL,KAAKoL,SAChBpL,KAAK+K,eAAiB,GAAK/K,KAAKwM,aAAeK,GAAiB7M,KAAK+K,eAAiB,GAAK/K,KAAKwM,aAAeK,IACjH7M,KAAKoL,SAGTpL,KAAKgN,iBAET,CAEA,cAAAA,GACE,MAAMR,EAAexM,KAAKwM,aACtBxM,KAAK6L,iBAAmBW,IAG5BxM,KAAK6L,eAAiBW,EACtBxM,KAAKR,QAAUQ,KAAKuL,UAAUiB,GAC1BxM,KAAKqL,cAAgBrL,KAAKR,QAAQoB,eACpCZ,KAAKP,OAAOiD,SAAS1C,KAAKR,QAAQoB,eAEhCZ,KAAKmL,eACPnL,KAAKmL,cAAcnL,KAAKwM,cAE5B,CAcA,OAAAnK,CAAQhD,GAAU,GAEhB,GAD0C,kBAAZA,EAAwBA,EAAUA,GAASG,QACrD,CAClB,MAAM8C,EAA0C,kBAAZjD,EAAwBA,EAAUA,GAASkD,cAC/EvC,KAAKuL,UAAUvE,QAASxH,IAClBQ,KAAKR,UAAYA,GACnBA,EAAQ6C,QAAQC,IAGtB,CACAtC,KAAKuL,UAAY,GACjBvL,KAAKwL,WAAa,KAClBxL,KAAK+L,OACLjM,MAAMuC,QAAQhD,GACdW,KAAKkL,WAAa,KAClBlL,KAAKmL,cAAgB,KACrBnL,KAAKoL,OAAS,IAChB,CAqBA,iBAAO6B,CAAW/I,GAChB,MAAMR,EAAW,GACjB,IAAA,IAAS0B,EAAI,EAAGA,EAAIlB,EAAOS,SAAUS,EACnC1B,EAAS4C,KAAKhH,EAAQwB,KAAKoD,EAAOkB,KAEpC,OAAO,IAAIwF,EAAelH,EAC5B,CAqBA,iBAAOwJ,CAAWC,GAChB,MAAMzJ,EAAW,GACjB,IAAA,IAAS0B,EAAI,EAAGA,EAAI+H,EAAOxI,SAAUS,EACnC1B,EAAS4C,KAAKhH,EAAQwB,KAAKqM,EAAO/H,KAEpC,OAAO,IAAIwF,EAAelH,EAC5B,CA0BA,eAAI0J,GACF,OAAOpN,KAAKuL,UAAU5G,MACxB,CA2BA,YAAIjB,GACF,OAAO1D,KAAKuL,SACd,CACA,YAAI7H,CAASzC,GACX,GAAIA,EAAM,aAAc3B,EACtBU,KAAKuL,UAAYtK,EACjBjB,KAAKwL,WAAa,SACb,CACLxL,KAAKuL,UAAY,GACjBvL,KAAKwL,WAAa,GAClB,IAAA,IAASpG,EAAI,EAAGA,EAAInE,EAAM0D,OAAQS,IAChCpF,KAAKuL,UAAUjF,KAAKrF,EAAMmE,GAAG5F,SAC7BQ,KAAKwL,WAAWlF,KAAKrF,EAAMmE,GAAGiI,KAElC,CACArN,KAAK6L,eAAiB,KACtB7L,KAAKsM,YAAY,GACjBtM,KAAKgN,gBACP,CAgCA,gBAAIR,GACF,IAAIA,EAAe7J,KAAKgD,MAAM3F,KAAK2L,cAAgB3L,KAAKuL,UAAU5G,OAIlE,OAHI6H,EAAe,IACjBA,GAAgBxM,KAAKuL,UAAU5G,QAE1B6H,CACT,CACA,gBAAIA,CAAavL,GACf,GAAIA,EAAQ,GAAKA,EAAQjB,KAAKoN,YAAc,EAC1C,MAAM,IAAIE,MAAM,+CAA+CrM,+CAAmDjB,KAAKoN,gBAEzH,MAAMP,EAAgB7M,KAAKwM,aAC3BxM,KAAK2L,aAAe1K,EAChB4L,IAAkB7M,KAAKwM,cACzBxM,KAAKgN,gBAET,CAoBA,WAAIO,GACF,OAAOvN,KAAK4L,QACd,CAyBA,cAAId,GACF,OAAO9K,KAAKyL,WACd,CACA,cAAIX,CAAW7J,GACTA,IAAUjB,KAAKyL,cACjBzL,KAAKyL,YAAcxK,GACdjB,KAAKyL,aAAezL,KAAK0L,sBAC5BM,EAAOC,OAAOC,OAAOlM,KAAKmM,OAAQnM,MAClCA,KAAK0L,sBAAuB,GACnB1L,KAAKyL,cAAgBzL,KAAK0L,sBAAwB1L,KAAK4L,WAChEI,EAAOC,OAAOtB,IAAI3K,KAAKmM,OAAQnM,MAC/BA,KAAK0L,sBAAuB,GAGlC,EC7gBF,MAAM8B,EAAgB,MAAMA,UAAsBrO,EAChD,WAAAC,IAAeyL,GACb,IAAIxL,EAAUwL,EAAK,IAAM,CAAA,EACrBxL,aAAmBC,IACrBD,EAAU,CAAEG,QAASH,IAEnBwL,EAAKlG,OAAS,IAChB5C,EAAY0L,EAAQ,oEACpBpO,EAAQM,MAAQkL,EAAK,GACrBxL,EAAQO,OAASiL,EAAK,IAExBxL,EAAU,IAAKmO,EAAcE,kBAAmBrO,GAChD,MAAMG,QACJA,EAAAC,OACAA,EAAAkO,aACAA,EAAAC,UACAA,EAAAC,aACAA,EAAAlO,MACAA,EAAAC,OACAA,EAAAkO,qBACAA,EAAApO,YACAA,KACGG,GACDR,GAAW,CAAA,EACfS,MAAM,CACJC,MAAO,kBACJF,IAGLG,KAAKC,aAAe,eAEpBD,KAAKE,SAAU,EACfF,KAAKa,eAAgB,EACrBb,KAAKQ,QAAU,IAAIC,EACjB,CACEC,UAAW,KACTV,KAAKW,kBAIXX,KAAK8N,qBAAuBA,EAC5B9N,KAAKR,QAAUA,EACfQ,KAAKuB,OAAS5B,GAASH,EAAQG,MAC/BK,KAAK0B,QAAU9B,GAAUJ,EAAQI,OACjCI,KAAK+N,eAAiB,IAAIC,EAAU,CAClCC,SAAU,CACRvN,UAAW,IAAMV,KAAKW,kBAGtBlB,IACFO,KAAKP,OAASA,GAChBO,KAAK2N,aAAeA,EACpB3N,KAAK4N,UAAYA,EACjB5N,KAAK6N,aAAeA,EACpB7N,KAAKN,YAAcA,IAAe,CACpC,CAyBA,WAAOoB,CAAKC,EAAQ1B,EAAU,IAC5B,OACS,IAAImO,EADS,iBAAXzM,EACgB,CACvBvB,QAAS0O,EAAMC,IAAIpN,MAChB1B,GAGkB,CACvBG,QAASuB,KACN1B,GAEP,CAMA,mBAAI+O,GAEF,OADArM,EAAY0L,EAAQ,0EACbzN,KAAK8N,oBACd,CAEA,mBAAIM,CAAgBnN,GAClBc,EAAY0L,EAAQ,0EACpBzN,KAAK8N,qBAAuB7M,CAC9B,CAQA,eAAIoN,GACF,OAAOrO,KAAKmB,SAASmN,cAAcD,WACrC,CAEA,eAAIA,CAAYpN,GACdjB,KAAKmB,SAASmN,cAAcD,YAAcpN,CAC5C,CAkCA,UAAIxB,GACF,OAAOO,KAAKQ,OACd,CACA,UAAIf,CAAOwB,GACQ,iBAAVA,EAAqBjB,KAAKQ,QAAQiC,IAAIxB,GAASjB,KAAKQ,QAAQkC,SAASzB,EAC9E,CAWA,gBAAI0M,GACF,OAAO3N,KAAK+N,eAAeQ,QAC7B,CACA,gBAAIZ,CAAa1M,GACfjB,KAAK+N,eAAeQ,SAAS7L,SAASzB,EACxC,CAWA,aAAI2M,GACF,OAAO5N,KAAK+N,eAAelL,KAC7B,CACA,aAAI+K,CAAU3M,GACK,iBAAVA,EAAqBjB,KAAK+N,eAAelL,MAAMJ,IAAIxB,GAASjB,KAAK+N,eAAelL,MAAMH,SAASzB,EACxG,CACA,gBAAI4M,CAAa5M,GACfjB,KAAK+N,eAAeS,SAAWvN,CACjC,CAWA,gBAAI4M,GACF,OAAO7N,KAAK+N,eAAeS,QAC7B,CA6BA,iBAAIC,GACF,OAAOzO,KAAK+N,cACd,CACA,WAAIvO,CAAQyB,GACVA,IAAUA,EAAQ3B,EAAQC,OAC1B,MAAM2B,EAAiBlB,KAAKmB,SACxBD,IAAmBD,IAEnBC,GAAkBA,EAAeE,SACnCF,EAAeG,IAAI,SAAUrB,KAAKW,aAAcX,MAC9CiB,EAAMG,SACRH,EAAMK,GAAG,SAAUtB,KAAKW,aAAcX,MACxCA,KAAKmB,SAAWF,EAChBjB,KAAKW,eACP,CAWA,WAAInB,GACF,OAAOQ,KAAKmB,QACd,CAuBA,SAAIxB,CAAMsB,GACRjB,KAAKuB,OAASN,EACdjB,KAAKW,cACP,CACA,SAAIhB,GACF,OAAOK,KAAKuB,MACd,CACA,UAAI3B,CAAOqB,GACTjB,KAAK0B,QAAUT,EACfjB,KAAKW,cACP,CAuBA,UAAIf,GACF,OAAOI,KAAK0B,OACd,CAuBA,OAAAwB,CAAQjC,EAAOrB,GACQ,iBAAVqB,IACTrB,EAASqB,EAAMrB,QAAUqB,EAAMtB,MAC/BsB,EAAQA,EAAMtB,OAEhBK,KAAKuB,OAASN,EACdjB,KAAK0B,QAAU9B,GAAUqB,EACzBjB,KAAKW,cACP,CAoBA,OAAAqC,CAAQC,GAIN,OAHAA,IAAQA,EAAM,IACdA,EAAItD,MAAQK,KAAKuB,OACjB0B,EAAIrD,OAASI,KAAK0B,QACXuB,CACT,CAEA,YAAAjB,GACE,MAAMC,EAASjC,KAAKkC,QACdzC,EAASO,KAAKQ,QACdb,EAAQK,KAAKuB,OACb3B,EAASI,KAAK0B,QACpBO,EAAO7B,MAAQX,EAAO0C,GAAKxC,EAC3BsC,EAAO5B,KAAO4B,EAAO7B,KAAOT,EAC5BsC,EAAO3B,MAAQb,EAAO2C,GAAKxC,EAC3BqC,EAAO1B,KAAO0B,EAAO3B,KAAOV,CAC9B,CA2BA,aAAA8O,CAAcC,GACZ,MAAMhP,EAAQK,KAAKuB,OACb3B,EAASI,KAAK0B,QACdkN,GAAMjP,EAAQK,KAAKQ,QAAQ2B,GACjC,IAAI0M,EAAK,EACT,OAAIF,EAAM7L,GAAK8L,GAAMD,EAAM7L,GAAK8L,EAAKjP,IACnCkP,GAAMjP,EAASI,KAAKQ,QAAQ4B,GACxBuM,EAAM5L,GAAK8L,GAAMF,EAAM5L,GAAK8L,EAAKjP,EAIzC,CAUA,OAAAyC,CAAQhD,GAAU,GAChBS,MAAMuC,QAAQhD,GACdW,KAAKQ,QAAU,KACfR,KAAK+N,eAAiB,KACtB/N,KAAKkC,QAAU,KAEf,GAD0C,kBAAZ7C,EAAwBA,EAAUA,GAASG,QACrD,CAClB,MAAM8C,EAA0C,kBAAZjD,EAAwBA,EAAUA,GAASkD,cAC/EvC,KAAKmB,SAASkB,QAAQC,EACxB,CACAtC,KAAKmB,SAAW,IAClB,GAoBFqM,EAAcE,eAAiB,CAE7BlO,QAASF,EAAQC,MAEjBE,OAAQ,CAAEqD,EAAG,EAAGC,EAAG,GAEnB4K,aAAc,CAAE7K,EAAG,EAAGC,EAAG,GAEzB6K,UAAW,CAAE9K,EAAG,EAAGC,EAAG,GAEtB8K,aAAc,EASdC,sBAAsB,GAErB,IAACgB,EAAetB,EC9enB,MAAMuB,EACJ,WAAA3P,GACEY,KAAKgP,YAAc,UACnBhP,KAAKiP,SAAW,gBAEhBjP,KAAKkP,cAAgB,EACrBlP,KAAKmP,UAAY,EACjBnP,KAAKoP,YAAa,EAClBpP,KAAKN,YAAc,EACnBM,KAAKqP,gBAAkB,EAEvBrP,KAAKsP,SAAW,KAChBtP,KAAKuP,OAAS,IAChB,CACA,aAAIC,GACF,OAAOxP,KAAKyP,WAAWC,cACzB,CACA,SAAIC,GACF,OAAO3P,KAAKyP,WAAWG,eACzB,CACA,KAAAC,GACE7P,KAAKyP,WAAa,KAClBzP,KAAKR,QAAU,KACfQ,KAAKsP,SAAW,KAChBtP,KAAKuP,OAAS,KACdvP,KAAKiC,OAAS,IAChB,CACA,OAAAI,GACA,ECzBF,MAAMyN,EACJ,WAAA1Q,CAAY2Q,GACV/P,KAAKgQ,UAAYD,CACnB,CACA,aAAAE,CAAcC,EAAQC,GACpB,MAAMC,EAAYpQ,KAAKqQ,cAAcH,GACjCA,EAAOI,eACTtQ,KAAKuQ,uBAAuBL,EAAQE,GACtCpQ,KAAKgQ,UAAUQ,YAAYC,MAAMC,WAAWN,EAAWD,EACzD,CACA,gBAAAQ,CAAiBT,GACf,MAAME,EAAYpQ,KAAKqQ,cAAcH,GACjCA,EAAOI,eACTtQ,KAAKuQ,uBAAuBL,EAAQE,GACtCA,EAAUd,SAASsB,cAAcR,EACnC,CACA,kBAAAS,CAAmBX,GACjB,MAAME,EAAYpQ,KAAKqQ,cAAcH,GACrC,OAAQE,EAAUd,SAASwB,sBACzBV,EACAF,EAAO/O,SAEX,CACA,sBAAAoP,CAAuBL,EAAQa,GAC7BA,EAAgB9O,OAASiO,EAAOtO,aAChCmP,EAAgBvR,QAAU0Q,EAAO/O,QACnC,CACA,aAAAkP,CAAcH,GACZ,OAAOA,EAAO1N,SAASxC,KAAKgQ,UAAUgB,MAAQhR,KAAKiR,eAAef,EACpE,CACA,cAAAe,CAAef,GACb,MAAMa,EAAkB,IAAIhC,EAO5B,OANAgC,EAAgBtB,WAAaS,EAC7Ba,EAAgBG,UAAYhB,EAAOiB,eACnCJ,EAAgBvR,QAAU0Q,EAAO/O,SACjC4P,EAAgB9O,OAASiO,EAAOtO,aAChCmP,EAAgBrR,YAAcM,KAAKgQ,UAAUoB,aAAelB,EAAOkB,aACnElB,EAAO1N,SAASxC,KAAKgQ,UAAUgB,KAAOD,EAC/BA,CACT,CACA,OAAA1O,GACErC,KAAKgQ,UAAY,IACnB,EAGFF,EAAWpI,UAAY,CACrBM,KAAM,CACJL,EAAc0J,WACd1J,EAAc2J,YACd3J,EAAc4J,aAEhBrJ,KAAM,UCpDR,MAAMsJ,EAAqB,MAAMA,UAA2BC,EAC1D,WAAArS,CAAYC,EAAU,IAEpBS,MAAM,CACJH,OAFFN,EAAU,IAAKmS,EAAmB9D,kBAAmBrO,IAEpCM,MACfC,OAAQP,EAAQO,OAChB8R,UAAW,EACXC,UAAW,IAEb3R,KAAKmM,OAAO9M,EACd,CAKA,MAAA8M,CAAO9M,GACLW,KAAKL,MAAQN,EAAQM,OAASK,KAAKL,MACnCK,KAAKJ,OAASP,EAAQO,QAAUI,KAAKJ,OACrCI,KAAK4R,eAAiBvS,EAAQwS,eAAiB7R,KAAK4R,eACpD5R,KAAK8R,gBAAkBzS,EAAQ0S,gBAAkB/R,KAAK8R,gBACtD9R,KAAKgS,WAAa3S,EAAQ4S,WAAajS,KAAKgS,WAC5ChS,KAAKkS,YAAc7S,EAAQ8S,YAAcnS,KAAKkS,YAC9ClS,KAAKoS,WAAa/S,EAAQgT,WAAarS,KAAKoS,WAC5CpS,KAAKsS,cAAgBjT,EAAQkT,cAAgBvS,KAAKsS,cAClDtS,KAAKwS,SAAWnT,EAAQI,QAAQqD,EAChC9C,KAAKyS,SAAWpT,EAAQI,QAAQsD,EAChC/C,KAAK0S,YACL1S,KAAK2S,iBACP,CAEA,eAAAA,GACE,MAAMC,EAAI5S,KAAK6S,WACTlT,MACJA,EAAAC,OACAA,EAAAoS,WACAA,EAAAE,YACAA,EAAAE,WACAA,EAAAE,cACAA,EAAAE,SACAA,EAAAC,SACAA,GACEzS,KACE4F,EAAIoM,EAAaE,EACjBY,EAASnT,EAAQiG,EAAI,EAAIjG,EAAQiG,EACjCC,EAAIuM,EAAaE,EACjBS,EAASnT,EAASiG,EAAI,EAAIjG,EAASiG,EACnChD,EAAQF,KAAKqQ,IAAIF,EAAQC,GACzBE,EAAgBT,EAAW7S,EAC3BuT,EAAgBT,EAAW7S,EACjCgT,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,KAAOK,EAC/BL,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMZ,EAAanP,EAAQoQ,EACpDL,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMjT,EAAQuS,EAAcrP,EAAQoQ,EAC7DL,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMjT,EAAQsT,EACvCL,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMM,EAC7BN,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMR,EAAavP,EAAQqQ,EACpDN,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMhT,EAAS0S,EAAgBzP,EAAQqQ,EACjEN,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMhT,EAASsT,EACzClT,KAAKmT,UAAU,aAAahH,QAC9B,CAEA,SAAAuG,GACE,MAAMU,EAAMpT,KAAKoT,IACjBA,EAAI,GAAKA,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAM,EACtCA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAK,EACpCA,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EACvCA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EACxC,MAAMC,EAAO,EAAIrT,KAAK4R,eAChB0B,EAAO,EAAItT,KAAK8R,gBACtBsB,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMC,EAAOrT,KAAKgS,WACnDoB,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAME,EAAOtT,KAAKoS,WACnDgB,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAAIC,EAAOrT,KAAKkS,YACvDkB,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAAIE,EAAOtT,KAAKsS,cACxDtS,KAAKmT,UAAU,OAAOhH,QACxB,GAGFqF,EAAmB9D,eAAiB,CAElC/N,MAAO,IAEPC,OAAQ,IAERqS,UAAW,GAEXI,UAAW,GAEXF,WAAY,GAEZI,aAAc,GAEdV,cAAe,IAEfE,eAAgB,KAElB,IAAIwB,EAAoB/B,EC5FxB,MAAMgC,UAA+BC,EACnC,WAAArU,GACEU,QACAE,KAAK0T,SAAW,IAAIH,CACtB,CACA,OAAAlR,GACErC,KAAK0T,SAASrR,SAChB,EAEF,MAAMsR,EACJ,WAAAvU,CAAY2Q,GACV/P,KAAKgQ,UAAYD,CACnB,CACA,aAAAE,CAAcC,EAAQC,GACpB,MAAMC,EAAYpQ,KAAKqQ,cAAcH,GACjCA,EAAOI,eACTtQ,KAAKuQ,uBAAuBL,EAAQE,GACtCpQ,KAAKgQ,UAAUQ,YAAYC,MAAMC,WAAWN,EAAWD,EACzD,CACA,gBAAAQ,CAAiBT,GACf,MAAME,EAAYpQ,KAAKqQ,cAAcH,GACjCA,EAAOI,eACTtQ,KAAKuQ,uBAAuBL,EAAQE,GACtCA,EAAUd,SAASsB,cAAcR,EACnC,CACA,kBAAAS,CAAmBX,GACjB,MAAME,EAAYpQ,KAAKqQ,cAAcH,GACrC,OAAQE,EAAUd,SAASwB,sBACzBV,EACAF,EAAO/O,SAEX,CACA,sBAAAoP,CAAuBL,EAAQa,GAC7BA,EAAgB2C,SAASvH,OAAO+D,GAChCa,EAAgB6C,WAAW1D,EAAO/O,SACpC,CACA,aAAAkP,CAAcH,GACZ,OAAOA,EAAO1N,SAASxC,KAAKgQ,UAAUgB,MAAQhR,KAAKiR,eAAef,EACpE,CACA,cAAAe,CAAef,GACb,MAAM2D,EAAU3D,EAAO1N,SAASxC,KAAKgQ,UAAUgB,KAAO,IAAIwC,EACpDM,EAAgBD,EAQtB,OAPAC,EAAcrE,WAAaS,EAC3B4D,EAAc5C,UAAYhB,EAAOiB,eACjC2C,EAActU,QAAU0Q,EAAO/O,SAC/B2S,EAAcpU,YAAcM,KAAKgQ,UAAUoB,aAAelB,EAAOkB,aAC5DlB,EAAOI,eACVtQ,KAAKuQ,uBAAuBL,EAAQ4D,GAE/BD,CACT,CACA,OAAAxR,GACErC,KAAKgQ,UAAY,IACnB,EAGF2D,EAAoBjM,UAAY,CAC9BM,KAAM,CACJL,EAAc0J,WACd1J,EAAc2J,YACd3J,EAAc4J,aAEhBrJ,KAAM,mBClER,MAAM6L,EAAY,CAChB7L,KAAM,aACN8L,OAAQ,CACNC,OAEE,geAcFC,KAEE,6LAOJC,SAAU,CACRF,OAEE,geAcFC,KAEE,ihBAmBAE,EAAc,CAClBlM,KAAM,aACN8L,OAAQ,CACNC,OAEE,mGAMFC,KAEE,iJAOJC,SAAU,CACRF,OAEE,0KAOFC,KAEE,uVCzFN,IAAIG,EACAC,EACJ,MAAMC,UAA2BC,EAC/B,WAAApV,GACEiV,IAAeA,EAAaI,EAA4B,CACtDvM,KAAM,uBACNwM,KAAM,CACJC,EACAZ,EACAa,MAGJN,IAAcA,EAAYO,EAA2B,CACnD3M,KAAM,uBACNwM,KAAM,CACJI,EACAV,EACAW,MAGJ,MAAMC,EAAiB,IAAIC,EAAa,CACtCC,UAAW,CAAEjU,MAAO,IAAIkU,EAAUnN,KAAM,eACxCoN,YAAa,CAAEnU,MAAO,IAAIoU,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKrN,KAAM,aAC5DsN,aAAc,CAAErU,MAAO,IAAIoU,aAAa,CAAC,EAAG,IAAKrN,KAAM,aACvDuN,kBAAmB,CAAEtU,MAAO,IAAIkU,EAAUnN,KAAM,eAChDwN,YAAa,CAAEvU,MAAO,IAAIoU,aAAa,CAAC,IAAK,IAAK,GAAK,KAAOrN,KAAM,eAEtElI,MAAM,CACJwU,YACAD,aACAoB,UAAW,CACTC,cAAe,IAAIT,EAAa,CAC9BU,iBAAkB,CAAE1U,MAAO,IAAIkU,EAAUnN,KAAM,eAC/C4N,OAAQ,CAAE3U,MAAO,IAAIoU,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKrN,KAAM,aACvD6N,OAAQ,CAAE5U,MAAO,EAAG+G,KAAM,SAE5BgN,iBACAc,SAAUxW,EAAQC,MAAMwB,OACxBgV,SAAUzW,EAAQC,MAAMwB,OAAOiV,QAGrC,CACA,cAAAC,CAAetW,EAAOC,EAAQsW,EAAQC,EAASC,EAAS5W,GACtD,MAAMwV,EAAiBhV,KAAKyV,UAAUT,eAChCqB,EAAe7W,EAAQG,MACvB2W,EAAgB9W,EAAQI,OACxB0O,EAAgB9O,EAAQ8O,cACxBiH,EAAoBP,EAAeuB,SAAShB,kBAClDA,EAAkB9S,IAChByT,EAAOM,EAAIH,EAAe1W,EAC1BuW,EAAOO,EAAIJ,EAAezW,EAC1BsW,EAAOQ,EAAIJ,EAAgB3W,EAC3BuW,EAAOS,EAAIL,EAAgB1W,EAC3BsW,EAAOU,GAAKjX,EACZuW,EAAOW,GAAKjX,GAEd2V,EAAkBuB,SAClB9B,EAAeuB,SAASrB,UAAY5G,EAAcyI,SAClD/B,EAAeuB,SAASnB,YAAc9G,EAAc8G,YACpDJ,EAAeuB,SAASjB,aAAehH,EAAcgH,aACrDN,EAAeuB,SAAShB,kBAAoBA,EAC5CP,EAAeuB,SAASf,YAAY,GAAK7V,EACzCqV,EAAeuB,SAASf,YAAY,GAAK5V,EACzCoV,EAAeuB,SAASf,YAAY,GAAKW,EACzCnB,EAAeuB,SAASf,YAAY,GAAKY,EACrC5W,IACFQ,KAAKyV,UAAUK,SAAWtW,EAAQuB,OAClCf,KAAKyV,UAAUM,SAAWvW,EAAQuB,OAAOiV,MAE7C,EClEF,MAAMgB,GAAa,ICVnB,cAA2BC,EACzB,WAAA7X,GACEU,MAAM,CACJ+S,UAAW,IAAIwC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAClDjC,IAAK,IAAIiC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC5C6B,QAAS,IAAIC,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,KAE7C,GDIF,MAAMC,GACJ,WAAAhY,GACEY,KAAKqX,UAAW,EAChBrX,KAAK0T,SAAW,IAAIuD,EAAa,CAC/BC,QAASF,GAAWE,QAAQI,QAC5BzE,UAAWmE,GAAWnE,UAAUyE,QAChClE,IAAK4D,GAAW5D,IAAIkE,SAExB,CACA,OAAAjV,GACErC,KAAK0T,SAASrR,UACdrC,KAAKuX,QAAQlV,SACf,EAEF,MAAMmV,GACJ,WAAApY,CAAY2Q,GACV/P,KAAKyX,OAASC,EAAMC,UACpB3X,KAAKgQ,UAAYD,CACnB,CACA,kBAAAc,CAAmBpB,GACjB,MAAMmI,EAAmB5X,KAAK6X,qBAAqBpI,GAC7CqI,EAAaF,EAAiBP,SACpCrX,KAAK+X,gBAAgBtI,GACrB,MAAM4H,EAAWO,EAAiBP,SAClC,GAAIA,GAAYA,IAAaS,EAAY,CACvC,MAAMhE,cAAEA,GAAkB8D,EAC1B,OAAQ9D,EAAcxE,SAASwB,sBAC7BgD,EACArE,EAAWjQ,QAEf,CACA,OAAOsY,IAAeT,CACxB,CACA,aAAApH,CAAc+H,EAAc7H,GAC1B,MAAM8H,EAAUjY,KAAKgQ,UAAUQ,YAAYC,MAC3CzQ,KAAK+X,gBAAgBC,GACrB,MAAMJ,EAAmB5X,KAAK6X,qBAAqBG,IAC7CtE,SAAEA,EAAA2D,SAAUA,GAAaO,EAC/B,GAAIP,EAAU,CACZO,EAAiB9D,gBAAkB8D,EAAiB9D,cAAgB,IAAIL,GACxE,MAAMK,EAAgB8D,EAAiB9D,cACnCkE,EAAa1H,gBACftQ,KAAKkY,qBAAqBF,GAC1BlE,EAAcJ,SAAWA,EACzBI,EAAcrE,WAAauI,EAC3BlE,EAAc5C,UAAY8G,EAAa7G,eACvC2C,EAAcF,WAAWoE,EAAa7W,WAExC2S,EAAcpU,YAAcM,KAAKgQ,UAAUoB,aAAe4G,EAAa5G,aACvE6G,EAAQvH,WAAWoD,EAAe3D,EACpC,MACE8H,EAAQE,MAAMhI,GACdyH,EAAiBL,SAAWK,EAAiBL,OAAS,IAAIhD,GAC1DvU,KAAK2Q,iBAAiBqH,GACtB7H,EAAexF,IAAIqN,EAEvB,CACA,OAAAI,CAAQJ,GACN,MAAMT,OAAEA,GAAWvX,KAAK6X,qBAAqBG,GAC7CT,EAAOc,OAAO,GAAKrY,KAAKgQ,UAAUsI,eAAeC,UACjD,MAAM7C,EAAgB6B,EAAO9B,UAAUC,cAAca,SACrDb,EAAcC,iBAAmBqC,EAAa7G,eAC9CuE,EAAcG,OAAS7V,KAAKgQ,UAAUoB,aAAe4G,EAAa5G,aAClEoH,EACER,EAAapI,gBACb8F,EAAcE,OACd,GAEF5V,KAAKyX,OAAOjI,UAAYiJ,EAA0BT,EAAatI,eAAgBsI,EAAaxY,QAAQkZ,SACpG1Y,KAAKgQ,UAAU2I,QAAQC,KAAK,CAC1BlF,SAAUsD,GACVO,SACAsB,MAAO7Y,KAAKyX,QAEhB,CACA,gBAAA9G,CAAiBqH,GACf,MAAMJ,EAAmB5X,KAAK6X,qBAAqBG,IAC7CX,SAAEA,GAAaO,EACrB,GAAIP,EAAU,CACZ,MAAMvD,cAAEA,GAAkB8D,EACtBI,EAAa1H,eACftQ,KAAKkY,qBAAqBF,GAC5BlE,EAAcxE,SAASsB,cAAckD,EACvC,MAAA,GAAWkE,EAAa1H,cAAe,CACrC,MAAMiH,OAAEA,GAAWK,EACnBL,EAAOtB,eACL+B,EAAarY,MACbqY,EAAapY,OACboY,EAAajK,eAAemI,OAC5B8B,EAAavY,OAAOqD,EACpBkV,EAAavY,OAAOsD,EACpBiV,EAAaxY,QAEjB,CACF,CACA,oBAAAqY,CAAqBpI,GACnB,OAAOA,EAAWjN,SAASxC,KAAKgQ,UAAUgB,MAAQhR,KAAK8Y,sBAAsBrJ,EAC/E,CACA,qBAAAqJ,CAAsBd,GACpB,MAAMnE,EAAU,IAAIuD,GAGpB,OAFAvD,EAAQpE,WAAauI,EACrBA,EAAaxV,SAASxC,KAAKgQ,UAAUgB,KAAO6C,EACrCA,CACT,CACA,oBAAAqE,CAAqBF,GACnB,MAAMe,EAAiB/Y,KAAK6X,qBAAqBG,IAC3CtE,SAAEA,GAAaqF,EACf/C,EAAQgC,EAAaxY,QAAQuB,OAAOiV,MAChB,WAAtBA,EAAMgD,cACRhD,EAAMgD,YAAc,SACpBhD,EAAM7J,UExHZ,SAAgB6L,EAAc5E,GAC5B,MAAM5T,EAAUwY,EAAaxY,QACvBG,EAAQH,EAAQ8F,MAAM3F,MACtBC,EAASJ,EAAQ8F,MAAM1F,OAC7B,IAAIuW,EAAU,EACVC,EAAU,EACV4B,EAAalK,uBACfqI,EAAU6B,EAAavY,OAAOqD,EAC9BsT,EAAU4B,EAAavY,OAAOsD,GAEhCqQ,EAAI,GAAKA,EAAI,IAAM+C,EACnB/C,EAAI,GAAKA,EAAI,GAAK,EAAI+C,EACtB/C,EAAI,GAAKA,EAAI,IAAMgD,EACnBhD,EAAI,GAAKA,EAAI,GAAK,EAAIgD,EACtB,MAAM9H,EAAgB6G,EAAOlJ,OAC7BqC,EAAc5L,SAASsV,EAAajK,eAAemI,QACnD5H,EAAcsI,IAAMoB,EAAarY,MACjC2O,EAAcuI,IAAMmB,EAAapY,OACjC0O,EAAcwI,SACdxI,EAAczL,MAAMmV,EAAarY,MAAQA,EAAOqY,EAAapY,OAASA,GCtBxE,SAAqBqZ,EAAOC,EAAQC,EAAQjD,GAC1C,IAAIkD,EAAQ,EACZ,MAAMC,EAAOJ,EAAMtU,OAAUuU,EACvB1C,EAAIN,EAAOM,EACXC,EAAIP,EAAOO,EACXC,EAAIR,EAAOQ,EACXC,EAAIT,EAAOS,EACXC,EAAKV,EAAOU,GACZC,EAAKX,EAAOW,GAElB,IADAsC,GAAUD,EACHE,EAAQC,GAAM,CACnB,MAAMvW,EAAImW,EAAME,GACVpW,EAAIkW,EAAME,EAAS,GACzBF,EAAME,GAAU3C,EAAI1T,EAAI4T,EAAI3T,EAAI6T,EAChCqC,EAAME,EAAS,GAAK1C,EAAI3T,EAAI6T,EAAI5T,EAAI8T,EACpCsC,GAAUD,EACVE,GACF,CACF,CDKEE,CAAYlG,EAAK,EAAG,EAAG9E,EACzB,CFqGIiL,CAAOvB,EAActE,EAASN,KI7HlC,SAAsB4E,EAAcnF,GAClC,MAAMsD,EAAU6B,EAAavY,OAAOqD,EAC9BsT,EAAU4B,EAAavY,OAAOsD,EACpC8P,EAAU,IAAMsD,EAAU6B,EAAarY,MACvCkT,EAAU,IAAMuD,EAAU4B,EAAapY,OACvCiT,EAAU,IAAM,EAAIsD,GAAW6B,EAAarY,MAC5CkT,EAAU,IAAMuD,EAAU4B,EAAapY,OACvCiT,EAAU,IAAM,EAAIsD,GAAW6B,EAAarY,MAC5CkT,EAAU,IAAM,EAAIuD,GAAW4B,EAAapY,OAC5CiT,EAAU,IAAMsD,EAAU6B,EAAarY,MACvCkT,EAAU,IAAM,EAAIuD,GAAW4B,EAAapY,MAC9C,CJmHI4Z,CAAaxB,EAActE,EAASb,UACtC,CACA,OAAAxQ,GACErC,KAAKgQ,UAAY,IACnB,CACA,eAAA+H,CAAgBC,GACd,MAAMe,EAAiB/Y,KAAK6X,qBAAqBG,GAC3CxY,EAAUwY,EAAaxY,QAC7B,IAAIia,GAAqB,EAKzB,OAJIzZ,KAAKgQ,UAAUhI,OAAS0R,EAAaC,QACvCF,EAAqBzZ,KAAKgQ,UAAU4J,QAAQC,SAASC,mBAEvDf,EAAe1B,SAAW7X,EAAQ8O,cAAcyL,WAAaN,GAAsBja,EAAQuB,OAAOiZ,cAC3FjB,EAAe1B,QACxB,EAGFG,GAAiB9P,UAAY,CAC3BM,KAAM,CACJL,EAAc0J,WACd1J,EAAc2J,YACd3J,EAAc4J,aAEhBrJ,KAAM,gBKlJRwC,EAAWC,IAAI6M,ICAf9M,EAAWC,IAAIgJ","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}