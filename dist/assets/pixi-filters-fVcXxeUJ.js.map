{"version":3,"file":"pixi-filters-fVcXxeUJ.js","sources":["../../node_modules/pixi-filters/lib/defaults/default.mjs","../../node_modules/pixi-filters/lib/defaults/default2.mjs","../../node_modules/pixi-filters/lib/adjustment/AdjustmentFilter.mjs","../../node_modules/pixi-filters/lib/adjustment/adjustment2.mjs","../../node_modules/pixi-filters/lib/adjustment/adjustment.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs","../../node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/ExtractBrightnessFilter.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/extract-brightness2.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/extract-brightness.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/AdvancedBloomFilter.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom2.mjs","../../node_modules/pixi-filters/lib/ascii/ascii.mjs","../../node_modules/pixi-filters/lib/ascii/AsciiFilter.mjs","../../node_modules/pixi-filters/lib/ascii/ascii2.mjs","../../node_modules/pixi-filters/lib/backdrop-blur/backdrop-blur-blend2.mjs","../../node_modules/pixi-filters/lib/backdrop-blur/BackdropBlurFilter.mjs","../../node_modules/pixi-filters/lib/backdrop-blur/backdrop-blur-blend.mjs","../../node_modules/pixi-filters/lib/bevel/bevel.mjs","../../node_modules/pixi-filters/lib/bevel/BevelFilter.mjs","../../node_modules/pixi-filters/lib/bevel/bevel2.mjs","../../node_modules/pixi-filters/lib/bloom/BloomFilter.mjs","../../node_modules/pixi-filters/lib/bulge-pinch/bulge-pinch.mjs","../../node_modules/pixi-filters/lib/bulge-pinch/BulgePinchFilter.mjs","../../node_modules/pixi-filters/lib/bulge-pinch/bulge-pinch2.mjs","../../node_modules/pixi-filters/lib/color-gradient/color-gradient2.mjs","../../node_modules/pixi-filters/lib/external/gradient-parser/build/node.mjs","../../node_modules/pixi-filters/lib/color-gradient/color-gradient3.mjs","../../node_modules/pixi-filters/lib/color-gradient/CssGradientParser.mjs","../../node_modules/pixi-filters/lib/color-gradient/ColorGradientFilter.mjs","../../node_modules/pixi-filters/lib/color-gradient/color-gradient.mjs","../../node_modules/pixi-filters/lib/color-map/color-map2.mjs","../../node_modules/pixi-filters/lib/color-map/ColorMapFilter.mjs","../../node_modules/pixi-filters/lib/color-map/color-map.mjs","../../node_modules/pixi-filters/lib/color-overlay/color-overlay2.mjs","../../node_modules/pixi-filters/lib/color-overlay/ColorOverlayFilter.mjs","../../node_modules/pixi-filters/lib/color-overlay/color-overlay.mjs","../../node_modules/pixi-filters/lib/color-replace/color-replace.mjs","../../node_modules/pixi-filters/lib/color-replace/ColorReplaceFilter.mjs","../../node_modules/pixi-filters/lib/color-replace/color-replace2.mjs","../../node_modules/pixi-filters/lib/convolution/convolution.mjs","../../node_modules/pixi-filters/lib/convolution/ConvolutionFilter.mjs","../../node_modules/pixi-filters/lib/convolution/convolution2.mjs","../../node_modules/pixi-filters/lib/cross-hatch/CrossHatchFilter.mjs","../../node_modules/pixi-filters/lib/cross-hatch/crosshatch2.mjs","../../node_modules/pixi-filters/lib/cross-hatch/crosshatch.mjs","../../node_modules/pixi-filters/lib/crt/crt2.mjs","../../node_modules/pixi-filters/lib/crt/CRTFilter.mjs","../../node_modules/pixi-filters/lib/crt/crt.mjs","../../node_modules/pixi-filters/lib/dot/dot.mjs","../../node_modules/pixi-filters/lib/dot/DotFilter.mjs","../../node_modules/pixi-filters/lib/dot/dot2.mjs","../../node_modules/pixi-filters/lib/drop-shadow/drop-shadow.mjs","../../node_modules/pixi-filters/lib/drop-shadow/DropShadowFilter.mjs","../../node_modules/pixi-filters/lib/drop-shadow/drop-shadow2.mjs","../../node_modules/pixi-filters/lib/emboss/emboss2.mjs","../../node_modules/pixi-filters/lib/emboss/EmbossFilter.mjs","../../node_modules/pixi-filters/lib/emboss/emboss.mjs","../../node_modules/pixi-filters/lib/glitch/glitch2.mjs","../../node_modules/pixi-filters/lib/glitch/GlitchFilter.mjs","../../node_modules/pixi-filters/lib/glitch/glitch.mjs","../../node_modules/pixi-filters/lib/glow/glow.mjs","../../node_modules/pixi-filters/lib/glow/GlowFilter.mjs","../../node_modules/pixi-filters/lib/glow/glow2.mjs","../../node_modules/pixi-filters/lib/godray/god-ray2.mjs","../../node_modules/pixi-filters/lib/godray/GodrayFilter.mjs","../../node_modules/pixi-filters/lib/godray/god-ray.mjs","../../node_modules/pixi-filters/lib/godray/perlin2.mjs","../../node_modules/pixi-filters/lib/godray/perlin.mjs","../../node_modules/pixi-filters/lib/grayscale/GrayscaleFilter.mjs","../../node_modules/pixi-filters/lib/grayscale/grayscale.mjs","../../node_modules/pixi-filters/lib/grayscale/grayscale2.mjs","../../node_modules/pixi-filters/lib/hsl-adjustment/hsladjustment.mjs","../../node_modules/pixi-filters/lib/hsl-adjustment/HslAdjustmentFilter.mjs","../../node_modules/pixi-filters/lib/hsl-adjustment/hsladjustment2.mjs","../../node_modules/pixi-filters/lib/motion-blur/motion-blur2.mjs","../../node_modules/pixi-filters/lib/motion-blur/MotionBlurFilter.mjs","../../node_modules/pixi-filters/lib/motion-blur/motion-blur.mjs","../../node_modules/pixi-filters/lib/multi-color-replace/multi-color-replace.mjs","../../node_modules/pixi-filters/lib/multi-color-replace/MultiColorReplaceFilter.mjs","../../node_modules/pixi-filters/lib/multi-color-replace/multi-color-replace2.mjs","../../node_modules/pixi-filters/lib/old-film/old-film.mjs","../../node_modules/pixi-filters/lib/old-film/OldFilmFilter.mjs","../../node_modules/pixi-filters/lib/old-film/old-film2.mjs","../../node_modules/pixi-filters/lib/outline/outline.mjs","../../node_modules/pixi-filters/lib/outline/OutlineFilter.mjs","../../node_modules/pixi-filters/lib/outline/outline2.mjs","../../node_modules/pixi-filters/lib/pixelate/PixelateFilter.mjs","../../node_modules/pixi-filters/lib/pixelate/pixelate.mjs","../../node_modules/pixi-filters/lib/pixelate/pixelate2.mjs","../../node_modules/pixi-filters/lib/radial-blur/radial-blur.mjs","../../node_modules/pixi-filters/lib/radial-blur/RadialBlurFilter.mjs","../../node_modules/pixi-filters/lib/radial-blur/radial-blur2.mjs","../../node_modules/pixi-filters/lib/reflection/reflection.mjs","../../node_modules/pixi-filters/lib/reflection/ReflectionFilter.mjs","../../node_modules/pixi-filters/lib/reflection/reflection2.mjs","../../node_modules/pixi-filters/lib/rgb-split/rgb-split2.mjs","../../node_modules/pixi-filters/lib/rgb-split/RGBSplitFilter.mjs","../../node_modules/pixi-filters/lib/rgb-split/rgb-split.mjs","../../node_modules/pixi-filters/lib/shockwave/shockwave2.mjs","../../node_modules/pixi-filters/lib/shockwave/ShockwaveFilter.mjs","../../node_modules/pixi-filters/lib/shockwave/shockwave.mjs","../../node_modules/pixi-filters/lib/simple-lightmap/simple-lightmap.mjs","../../node_modules/pixi-filters/lib/simple-lightmap/SimpleLightmapFilter.mjs","../../node_modules/pixi-filters/lib/simple-lightmap/simple-lightmap2.mjs","../../node_modules/pixi-filters/lib/simplex-noise/simplex.mjs","../../node_modules/pixi-filters/lib/simplex-noise/SimplexNoiseFilter.mjs","../../node_modules/pixi-filters/lib/simplex-noise/simplex2.mjs","../../node_modules/pixi-filters/lib/tilt-shift/tilt-shift.mjs","../../node_modules/pixi-filters/lib/tilt-shift/TiltShiftAxisFilter.mjs","../../node_modules/pixi-filters/lib/tilt-shift/tilt-shift2.mjs","../../node_modules/pixi-filters/lib/tilt-shift/TiltShiftFilter.mjs","../../node_modules/pixi-filters/lib/twist/twist2.mjs","../../node_modules/pixi-filters/lib/twist/TwistFilter.mjs","../../node_modules/pixi-filters/lib/twist/twist.mjs","../../node_modules/pixi-filters/lib/zoom-blur/zoom-blur2.mjs","../../node_modules/pixi-filters/lib/zoom-blur/ZoomBlurFilter.mjs","../../node_modules/pixi-filters/lib/zoom-blur/zoom-blur.mjs"],"sourcesContent":["var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=default.mjs.map\n","var wgslVertex = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\";\n\nexport { wgslVertex as default };\n//# sourceMappingURL=default2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './adjustment.mjs';\nimport source from './adjustment2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _AdjustmentFilter = class _AdjustmentFilter extends Filter {\n  /**\n   * @param options - The options of the adjustment filter.\n   */\n  constructor(options) {\n    options = { ..._AdjustmentFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"adjustment-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        adjustmentUniforms: {\n          uGamma: { value: options.gamma, type: \"f32\" },\n          uContrast: { value: options.contrast, type: \"f32\" },\n          uSaturation: { value: options.saturation, type: \"f32\" },\n          uBrightness: { value: options.brightness, type: \"f32\" },\n          uColor: {\n            value: [\n              options.red,\n              options.green,\n              options.blue,\n              options.alpha\n            ],\n            type: \"vec4<f32>\"\n          }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.adjustmentUniforms.uniforms;\n  }\n  /**\n   * Amount of luminance\n   * @default 1\n   */\n  get gamma() {\n    return this.uniforms.uGamma;\n  }\n  set gamma(value) {\n    this.uniforms.uGamma = value;\n  }\n  /**\n   * Amount of contrast\n   * @default 1\n   */\n  get contrast() {\n    return this.uniforms.uContrast;\n  }\n  set contrast(value) {\n    this.uniforms.uContrast = value;\n  }\n  /**\n   * Amount of color saturation\n   * @default 1\n   */\n  get saturation() {\n    return this.uniforms.uSaturation;\n  }\n  set saturation(value) {\n    this.uniforms.uSaturation = value;\n  }\n  /**\n   * The overall brightness\n   * @default 1\n   */\n  get brightness() {\n    return this.uniforms.uBrightness;\n  }\n  set brightness(value) {\n    this.uniforms.uBrightness = value;\n  }\n  /**\n   * The multiplied red channel\n   * @default 1\n   */\n  get red() {\n    return this.uniforms.uColor[0];\n  }\n  set red(value) {\n    this.uniforms.uColor[0] = value;\n  }\n  /**\n   * The multiplied blue channel\n   * @default 1\n   */\n  get green() {\n    return this.uniforms.uColor[1];\n  }\n  set green(value) {\n    this.uniforms.uColor[1] = value;\n  }\n  /**\n   * The multiplied green channel\n   * @default 1\n   */\n  get blue() {\n    return this.uniforms.uColor[2];\n  }\n  set blue(value) {\n    this.uniforms.uColor[2] = value;\n  }\n  /**\n   * The overall alpha channel\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uColor[3];\n  }\n  set alpha(value) {\n    this.uniforms.uColor[3] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_AdjustmentFilter, \"DEFAULT_OPTIONS\", {\n  gamma: 1,\n  contrast: 1,\n  saturation: 1,\n  brightness: 1,\n  red: 1,\n  green: 1,\n  blue: 1,\n  alpha: 1\n});\nlet AdjustmentFilter = _AdjustmentFilter;\n\nexport { AdjustmentFilter };\n//# sourceMappingURL=AdjustmentFilter.mjs.map\n","var source = \"struct AdjustmentUniforms {\\n  uGamma: f32,\\n  uContrast: f32,\\n  uSaturation: f32,\\n  uBrightness: f32,\\n  uColor: vec4<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  var sample = textureSample(uTexture, uSampler, uv);\\n  let color = adjustmentUniforms.uColor;\\n\\n  if (sample.a > 0.0) \\n  {\\n    sample = vec4<f32>(sample.rgb / sample.a, sample.a);\\n    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));\\n    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);\\n    rgb.r *= color.r;\\n    rgb.g *= color.g;\\n    rgb.b *= color.b;\\n    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);\\n    sample = vec4<f32>(sample.rgb * sample.a, sample.a);\\n  }\\n\\n  return sample * color.a;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=adjustment2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uGamma;\\nuniform float uContrast;\\nuniform float uSaturation;\\nuniform float uBrightness;\\nuniform vec4 uColor;\\n\\nvoid main()\\n{\\n    vec4 c = texture(uTexture, vTextureCoord);\\n\\n    if (c.a > 0.0) {\\n        c.rgb /= c.a;\\n\\n        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));\\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);\\n        rgb.r *= uColor.r;\\n        rgb.g *= uColor.g;\\n        rgb.b *= uColor.b;\\n        c.rgb = rgb * uBrightness;\\n\\n        c.rgb *= c.a;\\n    }\\n\\n    finalColor = c * uColor.a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=adjustment.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=kawase-blur.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './kawase-blur.mjs';\nimport source from './kawase-blur2.mjs';\nimport fragmentClamp from './kawase-blur-clamp2.mjs';\nimport sourceClamp from './kawase-blur-clamp.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _KawaseBlurFilter = class _KawaseBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }\");\n      options = { strength: options };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.clamp = args[2];\n    }\n    options = { ..._KawaseBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: options?.clamp ? sourceClamp : source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: options?.clamp ? fragmentClamp : fragment,\n      name: \"kawase-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        kawaseBlurUniforms: {\n          uOffset: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_pixelSize\", { x: 0, y: 0 });\n    __publicField(this, \"_clamp\");\n    __publicField(this, \"_kernels\", []);\n    __publicField(this, \"_blur\");\n    __publicField(this, \"_quality\");\n    this.uniforms = this.resources.kawaseBlurUniforms.uniforms;\n    this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };\n    if (Array.isArray(options.strength)) {\n      this.kernels = options.strength;\n    } else if (typeof options.strength === \"number\") {\n      this._blur = options.strength;\n      this.quality = options.quality ?? 3;\n    }\n    this._clamp = !!options.clamp;\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const uvX = this.pixelSizeX / input.source.width;\n    const uvY = this.pixelSizeY / input.source.height;\n    let offset;\n    if (this._quality === 1 || this._blur === 0) {\n      offset = this._kernels[0] + 0.5;\n      this.uniforms.uOffset[0] = offset * uvX;\n      this.uniforms.uOffset[1] = offset * uvY;\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const renderTarget = TexturePool.getSameSizeTexture(input);\n      let source2 = input;\n      let target = renderTarget;\n      let tmp;\n      const last = this._quality - 1;\n      for (let i = 0; i < last; i++) {\n        offset = this._kernels[i] + 0.5;\n        this.uniforms.uOffset[0] = offset * uvX;\n        this.uniforms.uOffset[1] = offset * uvY;\n        filterManager.applyFilter(this, source2, target, true);\n        tmp = source2;\n        source2 = target;\n        target = tmp;\n      }\n      offset = this._kernels[last] + 0.5;\n      this.uniforms.uOffset[0] = offset * uvX;\n      this.uniforms.uOffset[1] = offset * uvY;\n      filterManager.applyFilter(this, source2, output, clearMode);\n      TexturePool.returnTexture(renderTarget);\n    }\n  }\n  /**\n    * The amount of blur, value greater than `0`.\n    * @default 4\n    */\n  get strength() {\n    return this._blur;\n  }\n  set strength(value) {\n    this._blur = value;\n    this._generateKernels();\n  }\n  /**\n    * The quality of the filter, integer greater than `1`.\n    * @default 3\n    */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = Math.max(1, Math.round(value));\n    this._generateKernels();\n  }\n  /**\n    * The kernel size of the blur filter, for advanced usage\n    * @default [0]\n    */\n  get kernels() {\n    return this._kernels;\n  }\n  set kernels(value) {\n    if (Array.isArray(value) && value.length > 0) {\n      this._kernels = value;\n      this._quality = value.length;\n      this._blur = Math.max(...value);\n    } else {\n      this._kernels = [0];\n      this._quality = 1;\n    }\n  }\n  /**\n    * The size of the pixels. Large size is blurrier. For advanced usage.\n    * @default {x:1,y:1}\n    */\n  get pixelSize() {\n    return this._pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      this.pixelSizeX = this.pixelSizeY = value;\n      return;\n    }\n    if (Array.isArray(value)) {\n      this.pixelSizeX = value[0];\n      this.pixelSizeY = value[1];\n      return;\n    }\n    this._pixelSize = value;\n  }\n  /**\n    * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.\n    * @default 1\n    */\n  get pixelSizeX() {\n    return this.pixelSize.x;\n  }\n  set pixelSizeX(value) {\n    this.pixelSize.x = value;\n  }\n  /**\n    * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.\n    * @default 1\n    */\n  get pixelSizeY() {\n    return this.pixelSize.y;\n  }\n  set pixelSizeY(value) {\n    this.pixelSize.y = value;\n  }\n  /**\n    * Get the if the filter is clamped\n    * @default false\n    */\n  get clamp() {\n    return this._clamp;\n  }\n  /** Update padding based on kernel data */\n  _updatePadding() {\n    this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n  }\n  /** Auto generate kernels by blur & quality */\n  _generateKernels() {\n    const blur = this._blur;\n    const quality = this._quality;\n    const kernels = [blur];\n    if (blur > 0) {\n      let k = blur;\n      const step = blur / quality;\n      for (let i = 1; i < quality; i++) {\n        k -= step;\n        kernels.push(k);\n      }\n    }\n    this._kernels = kernels;\n    this._updatePadding();\n  }\n};\n/** Default values for options. */\n__publicField(_KawaseBlurFilter, \"DEFAULT_OPTIONS\", {\n  strength: 4,\n  quality: 3,\n  clamp: false,\n  pixelSize: { x: 1, y: 1 }\n});\nlet KawaseBlurFilter = _KawaseBlurFilter;\n\nexport { KawaseBlurFilter };\n//# sourceMappingURL=KawaseBlurFilter.mjs.map\n","var sourceClamp = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Average\\n  color *= 0.25;\\n    \\n  return color;\\n}\";\n\nexport { sourceClamp as default };\n//# sourceMappingURL=kawase-blur-clamp.mjs.map\n","var source = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\\n  // Average\\n  color *= 0.25;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=kawase-blur2.mjs.map\n","var fragmentClamp = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputClamp;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragmentClamp as default };\n//# sourceMappingURL=kawase-blur-clamp2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uBloomScale;\\nuniform float uBrightness;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    color.rgb *= uBrightness;\\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\\n    bloomColor.rgb *= uBloomScale;\\n    finalColor = color + bloomColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=advanced-bloom.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './extract-brightness.mjs';\nimport source from './extract-brightness2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ExtractBrightnessFilter = class _ExtractBrightnessFilter extends Filter {\n  constructor(options) {\n    options = { ..._ExtractBrightnessFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"extract-brightness-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        extractBrightnessUniforms: {\n          uThreshold: { value: options.threshold, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.extractBrightnessUniforms.uniforms;\n  }\n  /**\n   * Defines how bright a color needs to be extracted.\n   * @default 0.5\n   */\n  get threshold() {\n    return this.uniforms.uThreshold;\n  }\n  set threshold(value) {\n    this.uniforms.uThreshold = value;\n  }\n};\n/** Default values for options. */\n__publicField(_ExtractBrightnessFilter, \"DEFAULT_OPTIONS\", {\n  threshold: 0.5\n});\nlet ExtractBrightnessFilter = _ExtractBrightnessFilter;\n\nexport { ExtractBrightnessFilter };\n//# sourceMappingURL=ExtractBrightnessFilter.mjs.map\n","var source = \"struct ExtractBrightnessUniforms {\\n  uThreshold: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // A simple & fast algorithm for getting brightness.\\n  // It's inaccurate, but good enough for this feature.\\n  let max: f32 = max(max(color.r, color.g), color.b);\\n  let min: f32 = min(min(color.r, color.g), color.b);\\n  let brightness: f32 = (max + min) * 0.5;\\n\\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=extract-brightness2.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uThreshold;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    // A simple & fast algorithm for getting brightness.\\n    // It's inaccuracy , but good enought for this feature.\\n    float _max = max(max(color.r, color.g), color.b);\\n    float _min = min(min(color.r, color.g), color.b);\\n    float brightness = (_max + _min) * 0.5;\\n\\n    if(brightness > uThreshold) {\\n        finalColor = color;\\n    } else {\\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=extract-brightness.mjs.map\n","import { Filter, GpuProgram, GlProgram, Texture, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter.mjs';\nimport fragment from './advanced-bloom.mjs';\nimport source from './advanced-bloom2.mjs';\nimport { ExtractBrightnessFilter } from './ExtractBrightnessFilter.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _AdvancedBloomFilter = class _AdvancedBloomFilter extends Filter {\n  /**\n   * @param options - Options for the AdvancedBloomFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._AdvancedBloomFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"advanced-bloom-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        advancedBloomUniforms: {\n          uBloomScale: { value: options.bloomScale, type: \"f32\" },\n          uBrightness: { value: options.brightness, type: \"f32\" }\n        },\n        uMapTexture: Texture.WHITE\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /** To adjust the strength of the bloom. Higher values is more intense brightness. */\n    __publicField(this, \"bloomScale\", 1);\n    /** The brightness, lower value is more subtle brightness, higher value is blown-out. */\n    __publicField(this, \"brightness\", 1);\n    __publicField(this, \"_extractFilter\");\n    __publicField(this, \"_blurFilter\");\n    this.uniforms = this.resources.advancedBloomUniforms.uniforms;\n    this._extractFilter = new ExtractBrightnessFilter({\n      threshold: options.threshold\n    });\n    this._blurFilter = new KawaseBlurFilter({\n      strength: options.kernels ?? options.blur,\n      quality: options.kernels ? void 0 : options.quality\n    });\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const brightTarget = TexturePool.getSameSizeTexture(input);\n    this._extractFilter.apply(filterManager, input, brightTarget, true);\n    const bloomTarget = TexturePool.getSameSizeTexture(input);\n    this._blurFilter.apply(filterManager, brightTarget, bloomTarget, true);\n    this.uniforms.uBloomScale = this.bloomScale;\n    this.uniforms.uBrightness = this.brightness;\n    this.resources.uMapTexture = bloomTarget.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n    TexturePool.returnTexture(bloomTarget);\n    TexturePool.returnTexture(brightTarget);\n  }\n  /**\n   * Defines how bright a color needs to be extracted.\n   * @default 0.5\n   */\n  get threshold() {\n    return this._extractFilter.threshold;\n  }\n  set threshold(value) {\n    this._extractFilter.threshold = value;\n  }\n  /** The kernels of the Blur Filter */\n  get kernels() {\n    return this._blurFilter.kernels;\n  }\n  set kernels(value) {\n    this._blurFilter.kernels = value;\n  }\n  /**\n   * The strength of the Blur properties simultaneously\n   * @default 2\n   */\n  get blur() {\n    return this._blurFilter.strength;\n  }\n  set blur(value) {\n    this._blurFilter.strength = value;\n  }\n  /**\n   * The quality of the Blur Filter\n   * @default 4\n   */\n  get quality() {\n    return this._blurFilter.quality;\n  }\n  set quality(value) {\n    this._blurFilter.quality = value;\n  }\n  /**\n   * The pixel size of the Kawase Blur filter\n   * @default {x:1,y:1}\n   */\n  get pixelSize() {\n    return this._blurFilter.pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this._blurFilter.pixelSize = value;\n  }\n  /**\n   * The horizontal pixelSize of the Kawase Blur filter\n   * @default 1\n   */\n  get pixelSizeX() {\n    return this._blurFilter.pixelSizeX;\n  }\n  set pixelSizeX(value) {\n    this._blurFilter.pixelSizeX = value;\n  }\n  /**\n   * The vertical pixel size of the Kawase Blur filter\n   * @default 1\n   */\n  get pixelSizeY() {\n    return this._blurFilter.pixelSizeY;\n  }\n  set pixelSizeY(value) {\n    this._blurFilter.pixelSizeY = value;\n  }\n};\n/** Default values for options. */\n__publicField(_AdvancedBloomFilter, \"DEFAULT_OPTIONS\", {\n  threshold: 0.5,\n  bloomScale: 1,\n  brightness: 1,\n  blur: 8,\n  quality: 4,\n  pixelSize: { x: 1, y: 1 }\n});\nlet AdvancedBloomFilter = _AdvancedBloomFilter;\n\nexport { AdvancedBloomFilter };\n//# sourceMappingURL=AdvancedBloomFilter.mjs.map\n","var source = \"struct AdvancedBloomUniforms {\\n  uBloomScale: f32,\\n  uBrightness: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color = textureSample(uTexture, uSampler, uv);\\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\\n\\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\\n  \\n  return color + bloomColor;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=advanced-bloom2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uSize;\\nuniform vec3 uColor;\\nuniform float uReplaceColor;\\n\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 pixelate(vec2 coord, vec2 size)\\n{\\n    return floor(coord / size) * size;\\n}\\n\\nvec2 getMod(vec2 coord, vec2 size)\\n{\\n    return mod(coord, size) / size;\\n}\\n\\nfloat character(float n, vec2 p)\\n{\\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\\n\\n    if (clamp(p.x, 0.0, 4.0) == p.x)\\n    {\\n        if (clamp(p.y, 0.0, 4.0) == p.y)\\n        {\\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\\n        }\\n    }\\n    return 0.0;\\n}\\n\\nvoid main()\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n\\n    // get the grid position\\n    vec2 pixCoord = pixelate(coord, vec2(uSize));\\n    pixCoord = unmapCoord(pixCoord);\\n\\n    // sample the color at grid position\\n    vec4 color = texture(uTexture, pixCoord);\\n\\n    // brightness of the color as it's perceived by the human eye\\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\\n\\n    // determine the character to use\\n    float n =  65536.0;             // .\\n    if (gray > 0.2) n = 65600.0;    // :\\n    if (gray > 0.3) n = 332772.0;   // *\\n    if (gray > 0.4) n = 15255086.0; // o\\n    if (gray > 0.5) n = 23385164.0; // &\\n    if (gray > 0.6) n = 15252014.0; // 8\\n    if (gray > 0.7) n = 13199452.0; // @\\n    if (gray > 0.8) n = 11512810.0; // #\\n\\n    // get the mod..\\n    vec2 modd = getMod(coord, vec2(uSize));\\n\\n    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=ascii.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './ascii.mjs';\nimport source from './ascii2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _AsciiFilter = class _AsciiFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }\");\n      options = { size: options };\n    }\n    const replaceColor = options?.color && options.replaceColor !== false;\n    options = { ..._AsciiFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"ascii-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        asciiUniforms: {\n          uSize: { value: options.size, type: \"f32\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uReplaceColor: { value: Number(replaceColor), type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.asciiUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 16777215;\n  }\n  /**\n   * The pixel size used by the filter.\n   * @default 8\n   */\n  get size() {\n    return this.uniforms.uSize;\n  }\n  set size(value) {\n    this.uniforms.uSize = value;\n  }\n  /**\n   * The resulting color of the ascii characters, as a 3 component RGB or numerical hex\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0xffffff\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Determine whether or not to replace the source colors with the provided.\n   */\n  get replaceColor() {\n    return this.uniforms.uReplaceColor > 0.5;\n  }\n  set replaceColor(value) {\n    this.uniforms.uReplaceColor = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_AsciiFilter, \"DEFAULT_OPTIONS\", {\n  size: 8,\n  color: 16777215,\n  replaceColor: false\n});\nlet AsciiFilter = _AsciiFilter;\n\nexport { AsciiFilter };\n//# sourceMappingURL=AsciiFilter.mjs.map\n","var source = \"struct AsciiUniforms {\\n    uSize: f32,\\n    uColor: vec3<f32>,\\n    uReplaceColor: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let pixelSize: f32 = asciiUniforms.uSize;\\n    let coord: vec2<f32> = mapCoord(uv);\\n\\n    // get the rounded color..\\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\\n    pixCoord = unmapCoord(pixCoord);\\n\\n    var color = textureSample(uTexture, uSampler, pixCoord);\\n\\n    // determine the character to use\\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\\n    \\n    var n: f32 = 65536.0; // .\\n    if (gray > 0.2) {\\n        n = 65600.0;    // :\\n    }\\n    if (gray > 0.3) {\\n        n = 332772.0;   // *\\n    }\\n    if (gray > 0.4) {\\n        n = 15255086.0; // o\\n    }\\n    if (gray > 0.5) {\\n        n = 23385164.0; // &\\n    }\\n    if (gray > 0.6) {\\n        n = 15252014.0; // 8\\n    }\\n    if (gray > 0.7) {\\n        n = 13199452.0; // @\\n    }\\n    if (gray > 0.8) {\\n        n = 11512810.0; // #\\n    }\\n\\n    // get the mod..\\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\\n}\\n\\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n    return floor( coord / size ) * size;\\n}\\n\\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n    return moduloVec2( coord , size) / size;\\n}\\n\\nfn character(n: f32, p: vec2<f32>) -> f32\\n{\\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\\n\\n    if (clamp(q.x, 0.0, 4.0) == q.x)\\n    {\\n        if (clamp(q.y, 0.0, 4.0) == q.y)\\n        {\\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\\n        {\\n            return 1.0;\\n        }\\n        }\\n    }\\n\\n    return 0.0;\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n    var mappedCoord: vec2<f32> = coord;\\n    mappedCoord *= gfu.uInputSize.xy;\\n    mappedCoord += gfu.uOutputFrame.xy;\\n    return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n    var mappedCoord: vec2<f32> = coord;\\n    mappedCoord -= gfu.uOutputFrame.xy;\\n    mappedCoord /= gfu.uInputSize.xy;\\n    return mappedCoord;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=ascii2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uBackground;\\n\\nvoid main(void){\\n    vec4 front = texture(uTexture, vTextureCoord);\\n    vec4 back = texture(uBackground, vTextureCoord);\\n\\n    if (front.a == 0.0) {\\n        discard;\\n    }\\n    \\n    vec3 color = mix(back.rgb, front.rgb / front.a, front.a);\\n\\n    finalColor = vec4(color, 1.0);\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=backdrop-blur-blend2.mjs.map\n","import { BlurFilter, Filter, GpuProgram, GlProgram, Texture, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './backdrop-blur-blend2.mjs';\nimport wgslFragment from './backdrop-blur-blend.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass BackdropBlurFilter extends BlurFilter {\n  /**\n   * @param options - The options of the blur filter.\n   */\n  constructor(options) {\n    super(options);\n    __publicField(this, \"_blendPass\");\n    this.blendRequired = true;\n    this.padding = 0;\n    this._blendPass = new Filter({\n      gpuProgram: GpuProgram.from({\n        vertex: {\n          source: wgslVertex,\n          entryPoint: \"mainVertex\"\n        },\n        fragment: {\n          source: wgslFragment,\n          entryPoint: \"mainFragment\"\n        }\n      }),\n      glProgram: GlProgram.from({\n        vertex,\n        fragment,\n        name: \"drop-shadow-filter\"\n      }),\n      resources: {\n        uBackground: Texture.EMPTY\n      }\n    });\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const backTexture = filterManager._activeFilterData.backTexture;\n    const blurredBackground = TexturePool.getSameSizeTexture(input);\n    super.apply(filterManager, backTexture, blurredBackground, true);\n    this._blendPass.resources.uBackground = blurredBackground.source;\n    this._blendPass.apply(filterManager, input, output, clearMode);\n    TexturePool.returnTexture(blurredBackground);\n  }\n  updatePadding() {\n    this.padding = 0;\n  }\n}\n\nexport { BackdropBlurFilter };\n//# sourceMappingURL=BackdropBlurFilter.mjs.map\n","var wgslFragment = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var uBackground: texture_2d<f32>; \\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    var front: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n    var back: vec4<f32> = textureSample(uBackground, uSampler, uv);\\n    \\n    if (front.a == 0.0) {\\n        discard;\\n    }\\n\\n    var color: vec3<f32> = mix(back.rgb, front.rgb / front.a, front.a);\\n\\n    return vec4<f32>(color, 1.0);\\n}\";\n\nexport { wgslFragment as default };\n//# sourceMappingURL=backdrop-blur-blend.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTransform;\\nuniform vec3 uLightColor;\\nuniform float uLightAlpha;\\nuniform vec3 uShadowColor;\\nuniform float uShadowAlpha;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void) {\\n    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float light = texture(uTexture, vTextureCoord - transform).a;\\n    float shadow = texture(uTexture, vTextureCoord + transform).a;\\n\\n    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));\\n    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));\\n    finalColor = vec4(color.rgb * color.a, color.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=bevel.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color, DEG_TO_RAD } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './bevel.mjs';\nimport source from './bevel2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _BevelFilter = class _BevelFilter extends Filter {\n  /**\n   * @param options - Options for the BevelFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._BevelFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"bevel-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        bevelUniforms: {\n          uLightColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uLightAlpha: { value: options.lightAlpha, type: \"f32\" },\n          uShadowColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uShadowAlpha: { value: options.shadowAlpha, type: \"f32\" },\n          uTransform: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      },\n      // Workaround: https://github.com/pixijs/filters/issues/230\n      // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image\n      // To solve this problem, a padding of 1 put on the filter should suffice\n      padding: 1\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_thickness\");\n    __publicField(this, \"_rotation\");\n    __publicField(this, \"_lightColor\");\n    __publicField(this, \"_shadowColor\");\n    this.uniforms = this.resources.bevelUniforms.uniforms;\n    this._lightColor = new Color();\n    this._shadowColor = new Color();\n    this.lightColor = options.lightColor ?? 16777215;\n    this.shadowColor = options.shadowColor ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * The angle of the light in degrees\n   * @default 45\n   */\n  get rotation() {\n    return this._rotation / DEG_TO_RAD;\n  }\n  set rotation(value) {\n    this._rotation = value * DEG_TO_RAD;\n    this._updateTransform();\n  }\n  /**\n   * The thickness of the bevel\n   * @default 2\n   */\n  get thickness() {\n    return this._thickness;\n  }\n  set thickness(value) {\n    this._thickness = value;\n    this._updateTransform();\n  }\n  /**\n   * The color value of the left & top bevel.\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0xffffff\n   */\n  get lightColor() {\n    return this._lightColor.value;\n  }\n  set lightColor(value) {\n    this._lightColor.setValue(value);\n    const [r, g, b] = this._lightColor.toArray();\n    this.uniforms.uLightColor[0] = r;\n    this.uniforms.uLightColor[1] = g;\n    this.uniforms.uLightColor[2] = b;\n  }\n  /**\n   * The alpha value of the left & top bevel.\n   * @default 0.7\n   */\n  get lightAlpha() {\n    return this.uniforms.uLightAlpha;\n  }\n  set lightAlpha(value) {\n    this.uniforms.uLightAlpha = value;\n  }\n  /**\n   * The color value of the right & bottom bevel.\n   * @default 0xffffff\n   */\n  get shadowColor() {\n    return this._shadowColor.value;\n  }\n  set shadowColor(value) {\n    this._shadowColor.setValue(value);\n    const [r, g, b] = this._shadowColor.toArray();\n    this.uniforms.uShadowColor[0] = r;\n    this.uniforms.uShadowColor[1] = g;\n    this.uniforms.uShadowColor[2] = b;\n  }\n  /**\n   * The alpha value of the right & bottom bevel.\n   * @default 0.7\n   */\n  get shadowAlpha() {\n    return this.uniforms.uShadowAlpha;\n  }\n  set shadowAlpha(value) {\n    this.uniforms.uShadowAlpha = value;\n  }\n  /**\n   * Update the transform matrix of offset angle.\n   * @private\n   */\n  _updateTransform() {\n    this.uniforms.uTransform[0] = this.thickness * Math.cos(this._rotation);\n    this.uniforms.uTransform[1] = this.thickness * Math.sin(this._rotation);\n  }\n};\n/** Default values for options. */\n__publicField(_BevelFilter, \"DEFAULT_OPTIONS\", {\n  rotation: 45,\n  thickness: 2,\n  lightColor: 16777215,\n  lightAlpha: 0.7,\n  shadowColor: 0,\n  shadowAlpha: 0.7\n});\nlet BevelFilter = _BevelFilter;\n\nexport { BevelFilter };\n//# sourceMappingURL=BevelFilter.mjs.map\n","var source = \"struct BevelUniforms {\\n  uLightColor: vec3<f32>,\\n  uLightAlpha: f32,\\n  uShadowColor: vec3<f32>,\\n  uShadowAlpha: f32,\\n  uTransform: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;\\n  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;\\n\\n  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);\\n  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);\\n\\n  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);\\n  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);\\n  \\n  return vec4<f32>(color.rgb * color.a, color.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=bevel2.mjs.map\n","import { AlphaFilter, deprecation, BlurFilterPass, TexturePool } from 'pixi.js';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _BloomFilter = class _BloomFilter extends AlphaFilter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options) || \"x\" in options && \"y\" in options) {\n      deprecation(\"6.0.0\", \"BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }\");\n      let strength = options;\n      if (Array.isArray(strength))\n        strength = { x: strength[0], y: strength[1] };\n      options = { strength };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.resolution = args[2];\n      if (args[3] !== void 0)\n        options.kernelSize = args[3];\n    }\n    options = { ..._BloomFilter.DEFAULT_OPTIONS, ...options };\n    super();\n    __publicField(this, \"_blurXFilter\");\n    __publicField(this, \"_blurYFilter\");\n    __publicField(this, \"_strength\");\n    this._strength = { x: 2, y: 2 };\n    if (options.strength) {\n      if (typeof options.strength === \"number\") {\n        this._strength.x = options.strength;\n        this._strength.y = options.strength;\n      } else {\n        this._strength.x = options.strength.x;\n        this._strength.y = options.strength.y;\n      }\n    }\n    this._blurXFilter = new BlurFilterPass({\n      ...options,\n      horizontal: true,\n      strength: this.strengthX\n    });\n    this._blurYFilter = new BlurFilterPass({\n      ...options,\n      horizontal: false,\n      strength: this.strengthY\n    });\n    this._blurYFilter.blendMode = \"screen\";\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clear) {\n    const renderTarget = TexturePool.getSameSizeTexture(input);\n    filterManager.applyFilter(this, input, output, clear);\n    this._blurXFilter.apply(filterManager, input, renderTarget, true);\n    this._blurYFilter.apply(filterManager, renderTarget, output, false);\n    TexturePool.returnTexture(renderTarget);\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   */\n  get strength() {\n    return this._strength;\n  }\n  set strength(value) {\n    this._strength = typeof value === \"number\" ? { x: value, y: value } : value;\n    this._updateStrength();\n  }\n  /**\n   * Sets the strength of the blur on the `x` axis\n   * @default 2\n   */\n  get strengthX() {\n    return this.strength.x;\n  }\n  set strengthX(value) {\n    this.strength.x = value;\n    this._updateStrength();\n  }\n  /**\n   * Sets the strength of the blur on the `y` axis\n   * @default 2\n   */\n  get strengthY() {\n    return this.strength.y;\n  }\n  set strengthY(value) {\n    this.strength.y = value;\n    this._updateStrength();\n  }\n  _updateStrength() {\n    this._blurXFilter.blur = this.strengthX;\n    this._blurYFilter.blur = this.strengthY;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   * @see BloomFilter#strength\n   */\n  get blur() {\n    deprecation(\"6.0.0\", \"BloomFilter.blur is deprecated, please use BloomFilter.strength instead\");\n    return this.strengthX;\n  }\n  set blur(value) {\n    deprecation(\"6.0.0\", \"BloomFilter.blur is deprecated, please use BloomFilter.strength instead\");\n    this.strength = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The strength of the blurX property\n   * @default 2\n   * @see BloomFilter#strengthX\n   */\n  get blurX() {\n    deprecation(\"6.0.0\", \"BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead\");\n    return this.strengthX;\n  }\n  set blurX(value) {\n    deprecation(\"6.0.0\", \"BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead\");\n    this.strengthX = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The strength of the blurY property\n   * @default 2\n   * @see BloomFilter#strengthY\n   */\n  get blurY() {\n    deprecation(\"6.0.0\", \"BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead\");\n    return this.strengthY;\n  }\n  set blurY(value) {\n    deprecation(\"6.0.0\", \"BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead\");\n    this.strengthY = value;\n  }\n};\n/** Default values for options. */\n__publicField(_BloomFilter, \"DEFAULT_OPTIONS\", {\n  strength: { x: 2, y: 2 },\n  quality: 4,\n  resolution: 1,\n  kernelSize: 5\n});\nlet BloomFilter = _BloomFilter;\n\nexport { BloomFilter };\n//# sourceMappingURL=BloomFilter.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uDimensions;\\nuniform vec2 uCenter;\\nuniform float uRadius;\\nuniform float uStrength;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nvoid main()\\n{\\n    vec2 coord = vTextureCoord * uInputSize.xy;\\n    coord -= uCenter * uDimensions.xy;\\n    float distance = length(coord);\\n\\n    if (distance < uRadius) {\\n        float percent = distance / uRadius;\\n        if (uStrength > 0.0) {\\n            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);\\n        } else {\\n            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);\\n        }\\n    }\\n\\n    coord += uCenter * uDimensions.xy;\\n    coord /= uInputSize.xy;\\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    vec4 color = texture(uTexture, clampedCoord);\\n\\n    if (coord != clampedCoord) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=bulge-pinch.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './bulge-pinch.mjs';\nimport source from './bulge-pinch2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _BulgePinchFilter = class _BulgePinchFilter extends Filter {\n  /**\n   * @param options - Options for the BulgePinchFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._BulgePinchFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"bulge-pinch-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        bulgePinchUniforms: {\n          uDimensions: { value: [0, 0], type: \"vec2<f32>\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uRadius: { value: options.radius, type: \"f32\" },\n          uStrength: { value: options.strength, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.bulgePinchUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords.\n   * { x: 0, y: 0 } means top-left and { x: 1, y: 1 } mean bottom-right\n   * @default {x:0.5,y:0.5}\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.uniforms.uCenter.x;\n  }\n  set centerX(value) {\n    this.uniforms.uCenter.x = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `y` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.uniforms.uCenter.y;\n  }\n  set centerY(value) {\n    this.uniforms.uCenter.y = value;\n  }\n  /**\n   * The radius of the circle of effect\n   * @default 100\n   */\n  get radius() {\n    return this.uniforms.uRadius;\n  }\n  set radius(value) {\n    this.uniforms.uRadius = value;\n  }\n  /**\n   * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n   * @default 1\n   */\n  get strength() {\n    return this.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.uniforms.uStrength = value;\n  }\n};\n/** Default values for options. */\n__publicField(_BulgePinchFilter, \"DEFAULT_OPTIONS\", {\n  center: { x: 0.5, y: 0.5 },\n  radius: 100,\n  strength: 1\n});\nlet BulgePinchFilter = _BulgePinchFilter;\n\nexport { BulgePinchFilter };\n//# sourceMappingURL=BulgePinchFilter.mjs.map\n","var source = \"struct BulgePinchUniforms {\\n  uDimensions: vec2<f32>,\\n  uCenter: vec2<f32>,\\n  uRadius: f32,\\n  uStrength: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;\\n  let center: vec2<f32> = bulgePinchUniforms.uCenter;\\n  let radius: f32 = bulgePinchUniforms.uRadius;\\n  let strength: f32 = bulgePinchUniforms.uStrength;\\n  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;\\n\\n  let distance: f32 = length(coord);\\n\\n  if (distance < radius) {\\n      let percent: f32 = distance / radius;\\n      if (strength > 0.0) {\\n          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\\n      } else {\\n          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\\n      }\\n  }\\n    coord += (center * dimensions.xy);\\n    coord /= gfu.uInputSize.xy;\\n\\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\\n    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\\n    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    return color;\\n}\\n\\nfn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool\\n{\\n  if (x.x == y.x && x.y == y.y)\\n  {\\n    return true;\\n  }\\n\\n  return false;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=bulge-pinch2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nin vec2 vFilterCoord;\\nout vec4 finalColor;\\n\\nconst int TYPE_LINEAR = 0;\\nconst int TYPE_RADIAL = 1;\\nconst int TYPE_CONIC = 2;\\nconst int MAX_STOPS = 32;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uOptions;\\nuniform vec2 uCounts;\\nuniform vec3 uColors[MAX_STOPS];\\nuniform vec4 uStops[MAX_STOPS];\\n\\nconst float PI = 3.1415926538;\\nconst float PI_2 = PI*2.;\\n\\nstruct ColorStop {\\n    float offset;\\n    vec3 color;\\n    float alpha;\\n};\\n\\nmat2 rotate2d(float angle){\\n    return mat2(cos(angle), -sin(angle),\\n    sin(angle), cos(angle));\\n}\\n\\nfloat projectLinearPosition(vec2 pos, float angle){\\n    vec2 center = vec2(0.5);\\n    vec2 result = pos - center;\\n    result = rotate2d(angle) * result;\\n    result = result + center;\\n    return clamp(result.x, 0., 1.);\\n}\\n\\nfloat projectRadialPosition(vec2 pos) {\\n    float r = distance(pos, vec2(0.5));\\n    return clamp(2.*r, 0., 1.);\\n}\\n\\nfloat projectAnglePosition(vec2 pos, float angle) {\\n    vec2 center = pos - vec2(0.5);\\n    float polarAngle=atan(-center.y, center.x);\\n    return mod(polarAngle + angle, PI_2) / PI_2;\\n}\\n\\nfloat projectPosition(vec2 pos, int type, float angle) {\\n    if (type == TYPE_LINEAR) {\\n        return projectLinearPosition(pos, angle);\\n    } else if (type == TYPE_RADIAL) {\\n        return projectRadialPosition(pos);\\n    } else if (type == TYPE_CONIC) {\\n        return projectAnglePosition(pos, angle);\\n    }\\n\\n    return pos.y;\\n}\\n\\nvoid main(void) {\\n    int uType = int(uOptions[0]);\\n    float uAngle = uOptions[1];\\n    float uAlpha = uOptions[2];\\n    float uReplace = uOptions[3];\\n\\n    int uNumStops = int(uCounts[0]);\\n    float uMaxColors = uCounts[1];\\n\\n    // current/original color\\n    vec4 currentColor = texture(uTexture, vTextureCoord);\\n\\n    // skip calculations if gradient alpha is 0\\n    if (0.0 == uAlpha) {\\n        finalColor = currentColor;\\n        return;\\n    }\\n\\n    // project position\\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\\n\\n    // check gradient bounds\\n    float offsetMin = uStops[0][0];\\n    float offsetMax = 0.0;\\n\\n    int numStops = int(uNumStops);\\n\\n    for (int i = 0; i < MAX_STOPS; i++) {\\n        if (i == numStops-1){ // last index\\n            offsetMax = uStops[i][0];\\n        }\\n    }\\n\\n    if (y  < offsetMin || y > offsetMax) {\\n        finalColor = currentColor;\\n        return;\\n    }\\n\\n    // limit colors\\n    if (uMaxColors > 0.) {\\n        float stepSize = 1./uMaxColors;\\n        float stepNumber = float(floor(y/stepSize));\\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\\n    }\\n\\n    // find color stops\\n    ColorStop from;\\n    ColorStop to;\\n\\n    for (int i = 0; i < MAX_STOPS; i++) {\\n        if (y >= uStops[i][0]) {\\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\\n        }\\n\\n        if (i == numStops-1){ // last index\\n            break;\\n        }\\n    }\\n\\n    // mix colors from stops\\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\\n\\n    float segmentHeight = to.offset - from.offset;\\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\\n\\n    float gradientAlpha = uAlpha * currentColor.a;\\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\\n\\n    if (uReplace < 0.5) {\\n        // mix resulting color with current color\\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\\n    } else {\\n        // replace with gradient color\\n        finalColor = gradientColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-gradient2.mjs.map\n","// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.stringify = (function() {\n\n  var visitor = {\n\n    'visit_linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_gradient': function(node) {\n      var orientation = visitor.visit(node.orientation);\n      if (orientation) {\n        orientation += ', ';\n      }\n\n      return node.type + '(' + orientation + visitor.visit(node.colorStops) + ')';\n    },\n\n    'visit_shape': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at),\n          style = visitor.visit(node.style);\n\n      if (style) {\n        result += ' ' + style;\n      }\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_default-radial': function(node) {\n      var result = '',\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += at;\n      }\n      return result;\n    },\n\n    'visit_extent-keyword': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_position-keyword': function(node) {\n      return node.value;\n    },\n\n    'visit_position': function(node) {\n      return visitor.visit(node.value.x) + ' ' + visitor.visit(node.value.y);\n    },\n\n    'visit_%': function(node) {\n      return node.value + '%';\n    },\n\n    'visit_em': function(node) {\n      return node.value + 'em';\n    },\n\n    'visit_px': function(node) {\n      return node.value + 'px';\n    },\n\n    'visit_literal': function(node) {\n      return visitor.visit_color(node.value, node);\n    },\n\n    'visit_hex': function(node) {\n      return visitor.visit_color('#' + node.value, node);\n    },\n\n    'visit_rgb': function(node) {\n      return visitor.visit_color('rgb(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_rgba': function(node) {\n      return visitor.visit_color('rgba(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_color': function(resultColor, node) {\n      var result = resultColor,\n          length = visitor.visit(node.length);\n\n      if (length) {\n        result += ' ' + length;\n      }\n      return result;\n    },\n\n    'visit_angular': function(node) {\n      return node.value + 'deg';\n    },\n\n    'visit_directional': function(node) {\n      return 'to ' + node.value;\n    },\n\n    'visit_array': function(elements) {\n      var result = '',\n          size = elements.length;\n\n      elements.forEach(function(element, i) {\n        result += visitor.visit(element);\n        if (i < size - 1) {\n          result += ', ';\n        }\n      });\n\n      return result;\n    },\n\n    'visit': function(element) {\n      if (!element) {\n        return '';\n      }\n      var result = '';\n\n      if (element instanceof Array) {\n        return visitor.visit_array(element, result);\n      } else if (element.type) {\n        var nodeVisitor = visitor['visit_' + element.type];\n        if (nodeVisitor) {\n          return nodeVisitor(element);\n        } else {\n          throw Error('Missing visitor visit_' + element.type);\n        }\n      } else {\n        throw Error('Invalid node.');\n      }\n    }\n\n  };\n\n  return function(root) {\n    return visitor.visit(root);\n  };\n})();\n\n// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.parse = (function() {\n\n  var tokens = {\n    linearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(linear\\-gradient)/i,\n    repeatingLinearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-linear\\-gradient)/i,\n    radialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(radial\\-gradient)/i,\n    repeatingRadialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-radial\\-gradient)/i,\n    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,\n    extentKeywords: /^(closest\\-side|closest\\-corner|farthest\\-side|farthest\\-corner|contain|cover)/,\n    positionKeywords: /^(left|center|right|top|bottom)/i,\n    pixelValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))px/,\n    percentageValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))\\%/,\n    emValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))em/,\n    angleValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))deg/,\n    startCall: /^\\(/,\n    endCall: /^\\)/,\n    comma: /^,/,\n    hexColor: /^\\#([0-9a-fA-F]+)/,\n    literalColor: /^([a-zA-Z]+)/,\n    rgbColor: /^rgb/i,\n    rgbaColor: /^rgba/i,\n    number: /^(([0-9]*\\.[0-9]+)|([0-9]+\\.?))/\n  };\n\n  var input = '';\n\n  function error(msg) {\n    var err = new Error(input + ': ' + msg);\n    err.source = input;\n    throw err;\n  }\n\n  function getAST() {\n    var ast = matchListDefinitions();\n\n    if (input.length > 0) {\n      error('Invalid input not EOF');\n    }\n\n    return ast;\n  }\n\n  function matchListDefinitions() {\n    return matchListing(matchDefinition);\n  }\n\n  function matchDefinition() {\n    return matchGradient(\n            'linear-gradient',\n            tokens.linearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'repeating-linear-gradient',\n            tokens.repeatingLinearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'radial-gradient',\n            tokens.radialGradient,\n            matchListRadialOrientations) ||\n\n          matchGradient(\n            'repeating-radial-gradient',\n            tokens.repeatingRadialGradient,\n            matchListRadialOrientations);\n  }\n\n  function matchGradient(gradientType, pattern, orientationMatcher) {\n    return matchCall(pattern, function(captures) {\n\n      var orientation = orientationMatcher();\n      if (orientation) {\n        if (!scan(tokens.comma)) {\n          error('Missing comma before color stops');\n        }\n      }\n\n      return {\n        type: gradientType,\n        orientation: orientation,\n        colorStops: matchListing(matchColorStop)\n      };\n    });\n  }\n\n  function matchCall(pattern, callback) {\n    var captures = scan(pattern);\n\n    if (captures) {\n      if (!scan(tokens.startCall)) {\n        error('Missing (');\n      }\n\n      var result = callback(captures);\n\n      if (!scan(tokens.endCall)) {\n        error('Missing )');\n      }\n\n      return result;\n    }\n  }\n\n  function matchLinearOrientation() {\n    return matchSideOrCorner() ||\n      matchAngle();\n  }\n\n  function matchSideOrCorner() {\n    return match('directional', tokens.sideOrCorner, 1);\n  }\n\n  function matchAngle() {\n    return match('angular', tokens.angleValue, 1);\n  }\n\n  function matchListRadialOrientations() {\n    var radialOrientations,\n        radialOrientation = matchRadialOrientation(),\n        lookaheadCache;\n\n    if (radialOrientation) {\n      radialOrientations = [];\n      radialOrientations.push(radialOrientation);\n\n      lookaheadCache = input;\n      if (scan(tokens.comma)) {\n        radialOrientation = matchRadialOrientation();\n        if (radialOrientation) {\n          radialOrientations.push(radialOrientation);\n        } else {\n          input = lookaheadCache;\n        }\n      }\n    }\n\n    return radialOrientations;\n  }\n\n  function matchRadialOrientation() {\n    var radialType = matchCircle() ||\n      matchEllipse();\n\n    if (radialType) {\n      radialType.at = matchAtPosition();\n    } else {\n      var extent = matchExtentKeyword();\n      if (extent) {\n        radialType = extent;\n        var positionAt = matchAtPosition();\n        if (positionAt) {\n          radialType.at = positionAt;\n        }\n      } else {\n        var defaultPosition = matchPositioning();\n        if (defaultPosition) {\n          radialType = {\n            type: 'default-radial',\n            at: defaultPosition\n          };\n        }\n      }\n    }\n\n    return radialType;\n  }\n\n  function matchCircle() {\n    var circle = match('shape', /^(circle)/i, 0);\n\n    if (circle) {\n      circle.style = matchLength() || matchExtentKeyword();\n    }\n\n    return circle;\n  }\n\n  function matchEllipse() {\n    var ellipse = match('shape', /^(ellipse)/i, 0);\n\n    if (ellipse) {\n      ellipse.style =  matchDistance() || matchExtentKeyword();\n    }\n\n    return ellipse;\n  }\n\n  function matchExtentKeyword() {\n    return match('extent-keyword', tokens.extentKeywords, 1);\n  }\n\n  function matchAtPosition() {\n    if (match('position', /^at/, 0)) {\n      var positioning = matchPositioning();\n\n      if (!positioning) {\n        error('Missing positioning value');\n      }\n\n      return positioning;\n    }\n  }\n\n  function matchPositioning() {\n    var location = matchCoordinates();\n\n    if (location.x || location.y) {\n      return {\n        type: 'position',\n        value: location\n      };\n    }\n  }\n\n  function matchCoordinates() {\n    return {\n      x: matchDistance(),\n      y: matchDistance()\n    };\n  }\n\n  function matchListing(matcher) {\n    var captures = matcher(),\n      result = [];\n\n    if (captures) {\n      result.push(captures);\n      while (scan(tokens.comma)) {\n        captures = matcher();\n        if (captures) {\n          result.push(captures);\n        } else {\n          error('One extra comma');\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function matchColorStop() {\n    var color = matchColor();\n\n    if (!color) {\n      error('Expected color definition');\n    }\n\n    color.length = matchDistance();\n    return color;\n  }\n\n  function matchColor() {\n    return matchHexColor() ||\n      matchRGBAColor() ||\n      matchRGBColor() ||\n      matchLiteralColor();\n  }\n\n  function matchLiteralColor() {\n    return match('literal', tokens.literalColor, 0);\n  }\n\n  function matchHexColor() {\n    return match('hex', tokens.hexColor, 1);\n  }\n\n  function matchRGBColor() {\n    return matchCall(tokens.rgbColor, function() {\n      return  {\n        type: 'rgb',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchRGBAColor() {\n    return matchCall(tokens.rgbaColor, function() {\n      return  {\n        type: 'rgba',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchNumber() {\n    return scan(tokens.number)[1];\n  }\n\n  function matchDistance() {\n    return match('%', tokens.percentageValue, 1) ||\n      matchPositionKeyword() ||\n      matchLength();\n  }\n\n  function matchPositionKeyword() {\n    return match('position-keyword', tokens.positionKeywords, 1);\n  }\n\n  function matchLength() {\n    return match('px', tokens.pixelValue, 1) ||\n      match('em', tokens.emValue, 1);\n  }\n\n  function match(type, pattern, captureIndex) {\n    var captures = scan(pattern);\n    if (captures) {\n      return {\n        type: type,\n        value: captures[captureIndex]\n      };\n    }\n  }\n\n  function scan(regexp) {\n    var captures,\n        blankCaptures;\n\n    blankCaptures = /^[\\n\\r\\t\\s]+/.exec(input);\n    if (blankCaptures) {\n        consume(blankCaptures[0].length);\n    }\n\n    captures = regexp.exec(input);\n    if (captures) {\n        consume(captures[0].length);\n    }\n\n    return captures;\n  }\n\n  function consume(size) {\n    input = input.substr(size);\n  }\n\n  return function(code) {\n    input = code.toString();\n    return getAST();\n  };\n})();\n\nvar parse = GradientParser.parse;\nGradientParser.stringify;\n\nexport { parse };\n//# sourceMappingURL=node.mjs.map\n","var source = \"struct BaseUniforms {\\n  uOptions: vec4<f32>,\\n  uCounts: vec2<f32>,\\n};\\n\\nstruct StopsUniforms {\\n  uColors: array<vec3<f32>, MAX_STOPS>,\\n  uStops: array<vec4<f32>, MAX_STOPS>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n  @location(1) coord : vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\\n{\\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   vTextureCoord,\\n   filterCoord(vTextureCoord),\\n  );\\n}\\n\\nstruct ColorStop {\\n  offset: f32,\\n  color: vec3<f32>,\\n  alpha: f32,\\n};\\n\\nfn rotate2d(angle: f32) -> mat2x2<f32>{\\n  return mat2x2(cos(angle), -sin(angle),\\n  sin(angle), cos(angle));\\n}\\n\\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\\n  var center: vec2<f32> = vec2<f32>(0.5);\\n  var result: vec2<f32> = pos - center;\\n  result = rotate2d(angle) * result;\\n  result = result + center;\\n  return clamp(result.x, 0.0, 1.0);\\n}\\n\\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\\n  var r: f32 = distance(pos, vec2<f32>(0.5));\\n  return clamp(2.0 * r, 0.0, 1.0);\\n}\\n\\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\\n  var polarAngle: f32 = atan2(-center.y, center.x);\\n  return ((polarAngle + angle) % PI_2) / PI_2;\\n}\\n\\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\\n  if (gradientType == TYPE_LINEAR) {\\n      return projectLinearPosition(pos, angle);\\n  } else if (gradientType == TYPE_RADIAL) {\\n      return projectRadialPosition(pos);\\n  } else if (gradientType == TYPE_CONIC) {\\n      return projectAnglePosition(pos, angle);\\n  }\\n\\n  return pos.y;\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n  @location(1) coord : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\\n  let uAngle: f32 = baseUniforms.uOptions[1];\\n  let uAlpha: f32 = baseUniforms.uOptions[2];\\n  let uReplace: f32 = baseUniforms.uOptions[3];\\n\\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\\n\\n  // current/original color\\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // skip calculations if gradient alpha is 0\\n  if (uAlpha == 0.0) { return currentColor; }\\n\\n  // project position\\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\\n\\n  // check gradient bounds\\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\\n  var offsetMax: f32 = 0.0;\\n\\n  let numStops: i32 = uNumStops;\\n\\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\\n      if (i == numStops - 1) { // last index\\n          offsetMax = stopsUniforms.uStops[i][0];\\n      }\\n  }\\n\\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\\n\\n  // limit colors\\n  if (uMaxColors > 0.0) {\\n      var stepSize: f32 = 1.0 / uMaxColors;\\n      var stepNumber: f32 = floor(y / stepSize);\\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\\n  }\\n\\n  // find color stops\\n  var stopFrom: ColorStop;\\n  var stopTo: ColorStop;\\n\\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\\n      if (y >= stopsUniforms.uStops[i][0]) {\\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\\n      }\\n\\n      if (i == numStops - 1) { // last index\\n          break;\\n      }\\n  }\\n\\n  // mix colors from stops\\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\\n\\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\\n\\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\\n\\n  if (uReplace < 0.5) {\\n      // mix resulting color with current color\\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\\n  } else {\\n      // replace with gradient color\\n      return gradientColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\\nconst PI_2: f32 = PI * 2.0;\\n\\nconst TYPE_LINEAR: i32 = 0;\\nconst TYPE_RADIAL: i32 = 1;\\nconst TYPE_CONIC: i32 = 2;\\nconst MAX_STOPS: i32 = 32;\";\n\nexport { source as default };\n//# sourceMappingURL=color-gradient3.mjs.map\n","import { parse } from '../external/gradient-parser/build/node.mjs';\nimport { Color } from 'pixi.js';\n\nfunction parseCssGradient(cssGradient) {\n  const cssGradientNodes = parse(trimCssGradient(cssGradient));\n  if (cssGradientNodes.length === 0) {\n    throw new Error(\"Invalid CSS gradient.\");\n  } else if (cssGradientNodes.length !== 1) {\n    throw new Error(\"Unsupported CSS gradient (multiple gradients is not supported).\");\n  }\n  const cssGradientNode = cssGradientNodes[0];\n  const type = typeFromCssType(cssGradientNode.type);\n  const stops = stopsFromCssStops(cssGradientNode.colorStops);\n  const angle = angleFromCssOrientation(cssGradientNode.orientation);\n  return {\n    type,\n    stops,\n    angle\n  };\n}\nfunction typeFromCssType(type) {\n  const supportedTypes = {\n    \"linear-gradient\": 0,\n    \"radial-gradient\": 1\n  };\n  if (!(type in supportedTypes)) {\n    throw new Error(`Unsupported gradient type \"${type}\"`);\n  }\n  return supportedTypes[type];\n}\nfunction stopsFromCssStops(stops) {\n  const offsets = offsetsFromCssColorStops(stops);\n  const result = [];\n  const color = new Color();\n  for (let i = 0; i < stops.length; i++) {\n    const colorString = colorAsStringFromCssStop(stops[i]);\n    const rgbaColor = color.setValue(colorString).toArray();\n    result.push({\n      offset: offsets[i],\n      color: rgbaColor.slice(0, 3),\n      alpha: rgbaColor[3]\n    });\n  }\n  return result;\n}\nfunction colorAsStringFromCssStop(stop) {\n  switch (stop.type) {\n    case \"hex\":\n      return `#${stop.value}`;\n    case \"literal\":\n      return stop.value;\n    default:\n      return `${stop.type}(${stop.value.join(\",\")})`;\n  }\n}\nfunction offsetsFromCssColorStops(stops) {\n  const offsets = [];\n  const dynamicOffset = -1;\n  for (let i = 0; i < stops.length; i++) {\n    const cssStop = stops[i];\n    let stopOffset = dynamicOffset;\n    if (cssStop.type === \"literal\") {\n      if (cssStop.length && \"type\" in cssStop.length && cssStop.length.type === \"%\" && \"value\" in cssStop.length) {\n        stopOffset = parseFloat(cssStop.length.value) / 100;\n      }\n    }\n    offsets.push(stopOffset);\n  }\n  const findNextFixedStop = (fromIndex) => {\n    for (let k = fromIndex; k < offsets.length; k++) {\n      if (offsets[k] !== dynamicOffset) {\n        return {\n          indexDelta: k - fromIndex,\n          offset: offsets[k]\n        };\n      }\n    }\n    return {\n      indexDelta: offsets.length - 1 - fromIndex,\n      offset: 1\n    };\n  };\n  let prevFixedOffset = 0;\n  for (let i = 0; i < offsets.length; i++) {\n    const offset = offsets[i];\n    if (offset !== dynamicOffset) {\n      prevFixedOffset = offset;\n    } else if (i === 0) {\n      offsets[i] = 0;\n    } else if (i + 1 === offsets.length) {\n      offsets[i] = 1;\n    } else {\n      const nextFixed = findNextFixedStop(i);\n      const offsetDelta = nextFixed.offset - prevFixedOffset;\n      const stepSize = offsetDelta / (1 + nextFixed.indexDelta);\n      for (let s = 0; s <= nextFixed.indexDelta; s++) {\n        offsets[i + s] = prevFixedOffset + (s + 1) * stepSize;\n      }\n      i += nextFixed.indexDelta;\n      prevFixedOffset = offsets[i];\n    }\n  }\n  return offsets.map(fixFloatRounding);\n}\nfunction fixFloatRounding(value) {\n  const maxLength = 6;\n  if (value.toString().length > maxLength) {\n    return parseFloat(value.toString().substring(0, maxLength));\n  }\n  return value;\n}\nfunction angleFromCssOrientation(orientation) {\n  if (typeof orientation === \"undefined\") {\n    return 0;\n  }\n  if (\"type\" in orientation && \"value\" in orientation) {\n    switch (orientation.type) {\n      case \"angular\":\n        return parseFloat(orientation.value);\n      case \"directional\":\n        return angleFromDirectionalValue(orientation.value);\n    }\n  }\n  return 0;\n}\nfunction angleFromDirectionalValue(value) {\n  const supportedValues = {\n    left: 270,\n    top: 0,\n    bottom: 180,\n    right: 90,\n    \"left top\": 315,\n    \"top left\": 315,\n    \"left bottom\": 225,\n    \"bottom left\": 225,\n    \"right top\": 45,\n    \"top right\": 45,\n    \"right bottom\": 135,\n    \"bottom right\": 135\n  };\n  if (!(value in supportedValues)) {\n    throw new Error(`Unsupported directional value \"${value}\"`);\n  }\n  return supportedValues[value];\n}\nfunction trimCssGradient(value) {\n  let value_ = value.replace(/\\s{2,}/gu, \" \");\n  value_ = value_.replace(/;/g, \"\");\n  value_ = value_.replace(/ ,/g, \",\");\n  value_ = value_.replace(/\\( /g, \"(\");\n  value_ = value_.replace(/ \\)/g, \")\");\n  return value_.trim();\n}\n\nexport { angleFromCssOrientation, angleFromDirectionalValue, colorAsStringFromCssStop, offsetsFromCssColorStops, parseCssGradient, stopsFromCssStops, trimCssGradient, typeFromCssType };\n//# sourceMappingURL=CssGradientParser.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport fragment from './color-gradient2.mjs';\nimport vertex from './color-gradient.mjs';\nimport source from './color-gradient3.mjs';\nimport { parseCssGradient } from './CssGradientParser.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst ANGLE_OFFSET = 90;\nfunction sortColorStops(stops) {\n  return [...stops].sort((a, b) => a.offset - b.offset);\n}\nconst _ColorGradientFilter = class _ColorGradientFilter extends Filter {\n  /**\n   * @param options - Options for the ColorGradientFilter constructor.\n   */\n  constructor(options) {\n    if (options && \"css\" in options) {\n      options = {\n        ...parseCssGradient(options.css || \"\"),\n        alpha: options.alpha ?? _ColorGradientFilter.defaults.alpha,\n        maxColors: options.maxColors ?? _ColorGradientFilter.defaults.maxColors\n      };\n    } else {\n      options = { ..._ColorGradientFilter.defaults, ...options };\n    }\n    if (!options.stops || options.stops.length < 2) {\n      throw new Error(\"ColorGradientFilter requires at least 2 color stops.\");\n    }\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-gradient-filter\"\n    });\n    const maxStops = 32;\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        baseUniforms: {\n          uOptions: {\n            value: [\n              // Gradient Type\n              options.type,\n              // Gradient Angle\n              options.angle ?? ANGLE_OFFSET,\n              // Master Alpha\n              options.alpha,\n              // Replace Base Color\n              options.replace ? 1 : 0\n            ],\n            type: \"vec4<f32>\"\n          },\n          uCounts: {\n            value: [\n              // Number of Stops\n              options.stops.length,\n              // Max Gradient Colors\n              options.maxColors\n            ],\n            type: \"vec2<f32>\"\n          }\n        },\n        stopsUniforms: {\n          uColors: { value: new Float32Array(maxStops * 3), type: \"vec3<f32>\", size: maxStops },\n          // We only need vec2, but we need to pad to eliminate the WGSL warning, TODO: @Mat ?\n          uStops: { value: new Float32Array(maxStops * 4), type: \"vec4<f32>\", size: maxStops }\n        }\n      }\n    });\n    __publicField(this, \"baseUniforms\");\n    __publicField(this, \"stopsUniforms\");\n    __publicField(this, \"_stops\", []);\n    this.baseUniforms = this.resources.baseUniforms.uniforms;\n    this.stopsUniforms = this.resources.stopsUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  get stops() {\n    return this._stops;\n  }\n  set stops(stops) {\n    const sortedStops = sortColorStops(stops);\n    const color = new Color();\n    let r;\n    let g;\n    let b;\n    for (let i = 0; i < sortedStops.length; i++) {\n      color.setValue(sortedStops[i].color);\n      const indexStart = i * 3;\n      [r, g, b] = color.toArray();\n      this.stopsUniforms.uColors[indexStart] = r;\n      this.stopsUniforms.uColors[indexStart + 1] = g;\n      this.stopsUniforms.uColors[indexStart + 2] = b;\n      this.stopsUniforms.uStops[i * 4] = sortedStops[i].offset;\n      this.stopsUniforms.uStops[i * 4 + 1] = sortedStops[i].alpha;\n    }\n    this.baseUniforms.uCounts[0] = sortedStops.length;\n    this._stops = sortedStops;\n  }\n  /**\n  * The type of gradient\n  * @default ColorGradientFilter.LINEAR\n  */\n  get type() {\n    return this.baseUniforms.uOptions[0];\n  }\n  set type(value) {\n    this.baseUniforms.uOptions[0] = value;\n  }\n  /**\n  * The angle of the gradient in degrees\n  * @default 90\n  */\n  get angle() {\n    return this.baseUniforms.uOptions[1] + ANGLE_OFFSET;\n  }\n  set angle(value) {\n    this.baseUniforms.uOptions[1] = value - ANGLE_OFFSET;\n  }\n  /**\n  * The alpha value of the gradient (0-1)\n  * @default 1\n  */\n  get alpha() {\n    return this.baseUniforms.uOptions[2];\n  }\n  set alpha(value) {\n    this.baseUniforms.uOptions[2] = value;\n  }\n  /**\n  * The maximum number of colors to render (0 = no limit)\n  * @default 0\n  */\n  get maxColors() {\n    return this.baseUniforms.uCounts[1];\n  }\n  set maxColors(value) {\n    this.baseUniforms.uCounts[1] = value;\n  }\n  /**\n   * If true, the gradient will replace the existing color, otherwise it\n   * will be multiplied with it\n   * @default false\n   */\n  get replace() {\n    return this.baseUniforms.uOptions[3] > 0.5;\n  }\n  set replace(value) {\n    this.baseUniforms.uOptions[3] = value ? 1 : 0;\n  }\n};\n/** Gradient types */\n__publicField(_ColorGradientFilter, \"LINEAR\", 0);\n__publicField(_ColorGradientFilter, \"RADIAL\", 1);\n__publicField(_ColorGradientFilter, \"CONIC\", 2);\n/** Default constructor options */\n__publicField(_ColorGradientFilter, \"defaults\", {\n  type: _ColorGradientFilter.LINEAR,\n  stops: [\n    { offset: 0, color: 16711680, alpha: 1 },\n    { offset: 1, color: 255, alpha: 1 }\n  ],\n  alpha: 1,\n  angle: 90,\n  maxColors: 0,\n  replace: false\n});\nlet ColorGradientFilter = _ColorGradientFilter;\n\nexport { ColorGradientFilter };\n//# sourceMappingURL=ColorGradientFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=color-gradient.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uMix;\\nuniform float uSize;\\nuniform float uSliceSize;\\nuniform float uSlicePixelSize;\\nuniform float uSliceInnerSize;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord.xy);\\n    vec4 adjusted;\\n\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n        float innerWidth = uSize - 1.0;\\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\\n        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;\\n        float s0 = xOffset + (zSlice0 * uSliceSize);\\n        float s1 = xOffset + (zSlice1 * uSliceSize);\\n        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);\\n        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));\\n        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));\\n        float zOffset = fract(color.b * innerWidth);\\n        adjusted = mix(slice0Color, slice1Color, zOffset);\\n\\n        color.rgb *= color.a;\\n    }\\n\\n    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);\\n\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-map2.mjs.map\n","import { Texture, Filter, TextureSource, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './color-map2.mjs';\nimport source from './color-map.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ColorMapFilter = class _ColorMapFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Texture || options instanceof TextureSource) {\n      deprecation(\"6.0.0\", \"ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }\");\n      options = { colorMap: options };\n      if (args[1] !== void 0)\n        options.nearest = args[1];\n      if (args[2] !== void 0)\n        options.mix = args[2];\n    }\n    options = { ..._ColorMapFilter.DEFAULT_OPTIONS, ...options };\n    if (!options.colorMap)\n      throw Error(\"No color map texture source was provided to ColorMapFilter\");\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-map-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorMapUniforms: {\n          uMix: { value: options.mix, type: \"f32\" },\n          uSize: { value: 0, type: \"f32\" },\n          uSliceSize: { value: 0, type: \"f32\" },\n          uSlicePixelSize: { value: 0, type: \"f32\" },\n          uSliceInnerSize: { value: 0, type: \"f32\" }\n        },\n        uMapTexture: options.colorMap.source,\n        uMapSampler: options.colorMap.source.style\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_size\", 0);\n    __publicField(this, \"_sliceSize\", 0);\n    __publicField(this, \"_slicePixelSize\", 0);\n    __publicField(this, \"_sliceInnerSize\", 0);\n    __publicField(this, \"_nearest\", false);\n    __publicField(this, \"_scaleMode\", \"linear\");\n    __publicField(this, \"_colorMap\");\n    this.uniforms = this.resources.colorMapUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /** The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image. */\n  get mix() {\n    return this.uniforms.uMix;\n  }\n  set mix(value) {\n    this.uniforms.uMix = value;\n  }\n  /**\n   * The size of one color slice.\n   * @readonly\n   */\n  get colorSize() {\n    return this._size;\n  }\n  /** The colorMap texture. */\n  get colorMap() {\n    return this._colorMap;\n  }\n  set colorMap(value) {\n    if (!value || value === this.colorMap)\n      return;\n    const source2 = value instanceof Texture ? value.source : value;\n    source2.style.scaleMode = this._scaleMode;\n    source2.autoGenerateMipmaps = false;\n    this._size = source2.height;\n    this._sliceSize = 1 / this._size;\n    this._slicePixelSize = this._sliceSize / this._size;\n    this._sliceInnerSize = this._slicePixelSize * (this._size - 1);\n    this.uniforms.uSize = this._size;\n    this.uniforms.uSliceSize = this._sliceSize;\n    this.uniforms.uSlicePixelSize = this._slicePixelSize;\n    this.uniforms.uSliceInnerSize = this._sliceInnerSize;\n    this.resources.uMapTexture = source2;\n    this._colorMap = value;\n  }\n  /** Whether use NEAREST for colorMap texture. */\n  get nearest() {\n    return this._nearest;\n  }\n  set nearest(nearest) {\n    this._nearest = nearest;\n    this._scaleMode = nearest ? \"nearest\" : \"linear\";\n    const texture = this._colorMap;\n    if (texture && texture.source) {\n      texture.source.scaleMode = this._scaleMode;\n      texture.source.autoGenerateMipmaps = false;\n      texture.source.style.update();\n      texture.source.update();\n    }\n  }\n  /**\n   * If the colorMap is based on canvas,\n   * and the content of canvas has changed, then call `updateColorMap` for update texture.\n   */\n  updateColorMap() {\n    const texture = this._colorMap;\n    if (texture?.source) {\n      texture.source.update();\n      this.colorMap = texture;\n    }\n  }\n  /**\n   * Destroys this filter\n   * @default false\n   */\n  destroy() {\n    this._colorMap?.destroy(\n      /** true | TODO: Should base texture be destroyed? **/\n    );\n    super.destroy();\n  }\n};\n/** Default values for options. */\n__publicField(_ColorMapFilter, \"DEFAULT_OPTIONS\", {\n  colorMap: Texture.WHITE,\n  nearest: false,\n  mix: 1\n});\nlet ColorMapFilter = _ColorMapFilter;\n\nexport { ColorMapFilter };\n//# sourceMappingURL=ColorMapFilter.mjs.map\n","var source = \"struct ColorMapUniforms {\\n  uMix: f32,\\n  uSize: f32,\\n  uSliceSize: f32,\\n  uSlicePixelSize: f32,\\n  uSliceInnerSize: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  var adjusted: vec4<f32>;\\n\\n  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);\\n  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;\\n  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);\\n  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);\\n  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;\\n  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);\\n  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);\\n  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);\\n  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));\\n  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));\\n  let zOffset: f32 = fract(color.b * innerWidth);\\n  adjusted = mix(slice0Color, slice1Color, zOffset);\\n  altColor = vec4<f32>(color.rgb * color.a, color.a);\\n\\n  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);\\n\\n  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=color-map.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\n\\nvoid main(void) {\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    finalColor = vec4(mix(c.rgb, uColor * c.a, uAlpha), c.a);\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-overlay2.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './color-overlay2.mjs';\nimport source from './color-overlay.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ColorOverlayFilter = class _ColorOverlayFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options) || options instanceof Float32Array) {\n      deprecation(\"6.0.0\", \"ColorOverlayFilter constructor params are now options object. See params: { color, alpha }\");\n      options = { color: options };\n      if (args[1] !== void 0)\n        options.alpha = args[1];\n    }\n    options = { ..._ColorOverlayFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-overlay-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorOverlayUniforms: {\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.colorOverlayUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 0;\n  }\n  /**\n   * The over color source\n   * @member {number|Array<number>|Float32Array}\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * The alpha value of the color\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n};\n/** Default shockwave filter options */\n__publicField(_ColorOverlayFilter, \"DEFAULT_OPTIONS\", {\n  /** The color of the overlay */\n  color: 0,\n  /** The alpha of the overlay */\n  alpha: 1\n});\nlet ColorOverlayFilter = _ColorOverlayFilter;\n\nexport { ColorOverlayFilter };\n//# sourceMappingURL=ColorOverlayFilter.mjs.map\n","var source = \"struct ColorOverlayUniforms {\\n    uColor: vec3<f32>,\\n    uAlpha: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    let c = textureSample(uTexture, uSampler, uv);\\n    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb * c.a, colorOverlayUniforms.uAlpha), c.a);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=color-overlay.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uOriginalColor;\\nuniform vec3 uTargetColor;\\nuniform float uTolerance;\\n\\nvoid main(void) {\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));\\n    float colorDistance = length(colorDiff);\\n    float doReplace = step(colorDistance, uTolerance);\\n    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-replace.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './color-replace.mjs';\nimport source from './color-replace2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ColorReplaceFilter = class _ColorReplaceFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options) || options instanceof Float32Array) {\n      deprecation(\"6.0.0\", \"ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }\");\n      options = { originalColor: options };\n      if (args[1] !== void 0)\n        options.targetColor = args[1];\n      if (args[2] !== void 0)\n        options.tolerance = args[2];\n    }\n    options = { ..._ColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-replace-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorReplaceUniforms: {\n          uOriginalColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uTargetColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uTolerance: { value: options.tolerance, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_originalColor\");\n    __publicField(this, \"_targetColor\");\n    this.uniforms = this.resources.colorReplaceUniforms.uniforms;\n    this._originalColor = new Color();\n    this._targetColor = new Color();\n    this.originalColor = options.originalColor ?? 16711680;\n    this.targetColor = options.targetColor ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * The color that will be changed.\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0xff0000\n   */\n  get originalColor() {\n    return this._originalColor.value;\n  }\n  set originalColor(value) {\n    this._originalColor.setValue(value);\n    const [r, g, b] = this._originalColor.toArray();\n    this.uniforms.uOriginalColor[0] = r;\n    this.uniforms.uOriginalColor[1] = g;\n    this.uniforms.uOriginalColor[2] = b;\n  }\n  /**\n    * The resulting color.\n    * @example [1.0, 1.0, 1.0] = 0xffffff\n    * @default 0x000000\n    */\n  get targetColor() {\n    return this._targetColor.value;\n  }\n  set targetColor(value) {\n    this._targetColor.setValue(value);\n    const [r, g, b] = this._targetColor.toArray();\n    this.uniforms.uTargetColor[0] = r;\n    this.uniforms.uTargetColor[1] = g;\n    this.uniforms.uTargetColor[2] = b;\n  }\n  /**\n    * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n    * @default 0.4\n    */\n  get tolerance() {\n    return this.uniforms.uTolerance;\n  }\n  set tolerance(value) {\n    this.uniforms.uTolerance = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]\n   * @member {number|Array<number>|Float32Array}\n   * @default 0x000000\n   * @see ColorReplaceFilter#targetColor\n   */\n  set newColor(value) {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead\");\n    this.targetColor = value;\n  }\n  get newColor() {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead\");\n    return this.targetColor;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n   * @default 0.4\n   * @see ColorReplaceFilter#tolerance\n   */\n  set epsilon(value) {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead\");\n    this.tolerance = value;\n  }\n  get epsilon() {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead\");\n    return this.tolerance;\n  }\n};\n/** Default values for options. */\n__publicField(_ColorReplaceFilter, \"DEFAULT_OPTIONS\", {\n  originalColor: 16711680,\n  targetColor: 0,\n  tolerance: 0.4\n});\nlet ColorReplaceFilter = _ColorReplaceFilter;\n\nexport { ColorReplaceFilter };\n//# sourceMappingURL=ColorReplaceFilter.mjs.map\n","var source = \"struct ColorReplaceUniforms {\\n  uOriginalColor: vec3<f32>,\\n  uTargetColor: vec3<f32>,\\n  uTolerance: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;\\n\\n@fragment\\nfn mainFragment(\\n   @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));\\n  let colorDistance: f32 = length(colorDiff);\\n  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);\\n\\n  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=color-replace2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTexelSize;\\nuniform mat3 uMatrix;\\n\\nvoid main(void)\\n{\\n    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left\\n    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center\\n    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right\\n\\n    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left\\n    vec4 c22 = texture(uTexture, vTextureCoord); // mid center\\n    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right\\n\\n    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left\\n    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center\\n    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right\\n\\n    finalColor =\\n        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +\\n        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +\\n        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];\\n\\n    finalColor.a = c22.a;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=convolution.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './convolution.mjs';\nimport source from './convolution2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ConvolutionFilter = class _ConvolutionFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }\");\n      options = { matrix: options };\n      if (args[1] !== void 0)\n        options.width = args[1];\n      if (args[2] !== void 0)\n        options.height = args[2];\n    }\n    options = { ..._ConvolutionFilter.DEFAULT_OPTIONS, ...options };\n    const width = options.width ?? 200;\n    const height = options.height ?? 200;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"convolution-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        convolutionUniforms: {\n          uMatrix: { value: options.matrix, type: \"mat3x3<f32>\" },\n          uTexelSize: { value: { x: 1 / width, y: 1 / height }, type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.convolutionUniforms.uniforms;\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * An array of values used for matrix transformation, specified as a 9 point Array\n   * @example\n   * const matrix = new Float32Array(9); // 9 elements of value 0\n   * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];\n   * @default [0,0,0,0,0,0,0,0,0]\n   */\n  get matrix() {\n    return this.uniforms.uMatrix;\n  }\n  set matrix(matrix) {\n    matrix.forEach((v, i) => {\n      this.uniforms.uMatrix[i] = v;\n    });\n  }\n  /**\n   * Width of the object you are transforming\n   * @default 200\n   */\n  get width() {\n    return 1 / this.uniforms.uTexelSize.x;\n  }\n  set width(value) {\n    this.uniforms.uTexelSize.x = 1 / value;\n  }\n  /**\n   * Height of the object you are transforming\n   * @default 200\n   */\n  get height() {\n    return 1 / this.uniforms.uTexelSize.y;\n  }\n  set height(value) {\n    this.uniforms.uTexelSize.y = 1 / value;\n  }\n};\n/** Default values for options. */\n__publicField(_ConvolutionFilter, \"DEFAULT_OPTIONS\", {\n  matrix: new Float32Array(9),\n  width: 200,\n  height: 200\n});\nlet ConvolutionFilter = _ConvolutionFilter;\n\nexport { ConvolutionFilter };\n//# sourceMappingURL=ConvolutionFilter.mjs.map\n","var source = \"struct ConvolutionUniforms {\\n    uMatrix: mat3x3<f32>,\\n    uTexelSize: vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let texelSize = convolutionUniforms.uTexelSize;\\n    let matrix = convolutionUniforms.uMatrix;\\n\\n    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left\\n    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center\\n    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right\\n\\n    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left\\n    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center\\n    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right\\n\\n    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left\\n    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center\\n    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right\\n\\n    var finalColor: vec4<f32> = vec4<f32>(\\n        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +\\n        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +\\n        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]\\n    );\\n\\n    finalColor.a = c22.a;\\n\\n    return finalColor;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=convolution2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './crosshatch.mjs';\nimport source from './crosshatch2.mjs';\n\nclass CrossHatchFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"cross-hatch-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {}\n    });\n  }\n}\n\nexport { CrossHatchFilter };\n//# sourceMappingURL=CrossHatchFilter.mjs.map\n","var source = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let lum: f32 = length(textureSample(uTexture, uSampler, uv).rgb);\\n\\n    if (lum < 1.00)\\n    {\\n        if (modulo(position.x + position.y, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (modulo(position.x - position.y, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (modulo(position.x + position.y - 5.0, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (modulo(position.x - position.y - 5.0, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    return vec4<f32>(1.0);\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=crosshatch2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void)\\n{\\n    float lum = length(texture(uTexture, vTextureCoord.xy).rgb);\\n\\n    finalColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n    if (lum < 1.00)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=crosshatch.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uLine;\\nuniform vec2 uNoise;\\nuniform vec3 uVignette;\\nuniform float uSeed;\\nuniform float uTime;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nconst float SQRT_2 = 1.414213;\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfloat vignette(vec3 co, vec2 coord)\\n{\\n    float outter = SQRT_2 - uVignette[0] * SQRT_2;\\n    vec2 dir = vec2(0.5) - coord;\\n    dir.y *= uDimensions.y / uDimensions.x;\\n    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\\n    return darker + (1.0 - darker) * (1.0 - uVignette[1]);\\n}\\n\\nfloat noise(vec2 coord)\\n{\\n    vec2 pixelCoord = coord * uInputSize.xy;\\n    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\\n\\nvec3 interlaceLines(vec3 co, vec2 coord)\\n{\\n    vec3 color = co;\\n\\n    float curvature = uLine[0];\\n    float lineWidth = uLine[1];\\n    float lineContrast = uLine[2];\\n    float verticalLine = uLine[3];\\n\\n    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);\\n\\n    float _c = curvature > 0. ? curvature : 1.;\\n    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\\n    vec2 uv = dir * k;\\n    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;\\n    v *= min(1.0, 2.0 / lineWidth ) / _c;\\n    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;\\n    color *= j;\\n\\n    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);\\n    color *= 0.99 + ceil(segment) * 0.015;\\n\\n    return color;\\n}\\n\\nvoid main(void)\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\\n\\n    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n    {\\n        float n = noise(vTextureCoord);\\n        finalColor += vec4(n, n, n, finalColor.a);\\n    }\\n\\n    if (uVignette[0] > 0.)\\n    {\\n        float v = vignette(finalColor.rgb, coord);\\n        finalColor *= vec4(v, v, v, finalColor.a);\\n    }\\n\\n    if (uLine[1] > 0.0)\\n    {\\n        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  \\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=crt2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './crt2.mjs';\nimport source from './crt.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _CRTFilter = class _CRTFilter extends Filter {\n  /**\n   * @param options - Options for the CRTFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._CRTFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"crt-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        crtUniforms: {\n          uLine: { value: new Float32Array(4), type: \"vec4<f32>\" },\n          uNoise: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uVignette: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uSeed: { value: options.seed, type: \"f32\" },\n          uTime: { value: options.time, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    __publicField(this, \"seed\");\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    __publicField(this, \"time\");\n    this.uniforms = this.resources.crtUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    this.uniforms.uSeed = this.seed;\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Bend of interlaced lines, higher value means more bend\n   * @default 1\n   */\n  get curvature() {\n    return this.uniforms.uLine[0];\n  }\n  set curvature(value) {\n    this.uniforms.uLine[0] = value;\n  }\n  /**\n   * Width of interlaced lines\n   * @default 1\n   */\n  get lineWidth() {\n    return this.uniforms.uLine[1];\n  }\n  set lineWidth(value) {\n    this.uniforms.uLine[1] = value;\n  }\n  /**\n   * Contrast of interlaced lines\n   * @default 0.25\n   */\n  get lineContrast() {\n    return this.uniforms.uLine[2];\n  }\n  set lineContrast(value) {\n    this.uniforms.uLine[2] = value;\n  }\n  /**\n   * The orientation of the line:\n   *\n   * `true` create vertical lines, `false` creates horizontal lines\n   * @default false\n   */\n  get verticalLine() {\n    return this.uniforms.uLine[3] > 0.5;\n  }\n  set verticalLine(value) {\n    this.uniforms.uLine[3] = value ? 1 : 0;\n  }\n  /**\n   * Opacity/intensity of the noise effect between `0` and `1`\n   * @default 0.3\n   */\n  get noise() {\n    return this.uniforms.uNoise[0];\n  }\n  set noise(value) {\n    this.uniforms.uNoise[0] = value;\n  }\n  /**\n   * The size of the noise particles\n   * @default 0\n   */\n  get noiseSize() {\n    return this.uniforms.uNoise[1];\n  }\n  set noiseSize(value) {\n    this.uniforms.uNoise[1] = value;\n  }\n  /**\n   * The radius of the vignette effect, smaller values produces a smaller vignette\n   * @default 0.3\n   */\n  get vignetting() {\n    return this.uniforms.uVignette[0];\n  }\n  set vignetting(value) {\n    this.uniforms.uVignette[0] = value;\n  }\n  /**\n   * Amount of opacity of vignette\n   * @default 1\n   */\n  get vignettingAlpha() {\n    return this.uniforms.uVignette[1];\n  }\n  set vignettingAlpha(value) {\n    this.uniforms.uVignette[1] = value;\n  }\n  /**\n   * Blur intensity of the vignette\n   * @default 0.3\n   */\n  get vignettingBlur() {\n    return this.uniforms.uVignette[2];\n  }\n  set vignettingBlur(value) {\n    this.uniforms.uVignette[2] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_CRTFilter, \"DEFAULT_OPTIONS\", {\n  curvature: 1,\n  lineWidth: 1,\n  lineContrast: 0.25,\n  verticalLine: false,\n  noise: 0,\n  noiseSize: 1,\n  vignetting: 0.3,\n  vignettingAlpha: 1,\n  vignettingBlur: 0.3,\n  time: 0,\n  seed: 0\n});\nlet CRTFilter = _CRTFilter;\n\nexport { CRTFilter };\n//# sourceMappingURL=CRTFilter.mjs.map\n","var source = \"struct CRTUniforms {\\n    uLine: vec4<f32>,\\n    uNoise: vec2<f32>,\\n    uVignette: vec3<f32>,\\n    uSeed: f32,\\n    uTime: f32,\\n    uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    \\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\\n\\n  let uNoise = crtUniforms.uNoise;\\n\\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n  {\\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\\n  }\\n\\n  if (crtUniforms.uVignette[0] > 0.)\\n  {\\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\\n  }\\n\\n  if (crtUniforms.uLine[1] > 0.0)\\n  {\\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \\n  }\\n\\n  return color;\\n}\\n\\nconst SQRT_2: f32 = 1.414213;\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn rand(co: vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\\n{\\n  let uVignette = crtUniforms.uVignette;\\n  let uDimensions = crtUniforms.uDimensions;\\n  \\n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\\n  dir.y *= uDimensions.y / uDimensions.x;\\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\\n}\\n\\nfn noise(coord: vec2<f32>) -> f32\\n{\\n  let uNoise = crtUniforms.uNoise;\\n  let uSeed = crtUniforms.uSeed;\\n\\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\\n\\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\\n{\\n  var color = co;\\n\\n  let uDimensions = crtUniforms.uDimensions;\\n\\n  let curvature: f32 = crtUniforms.uLine[0];\\n  let lineWidth: f32 = crtUniforms.uLine[1];\\n  let lineContrast: f32 = crtUniforms.uLine[2];\\n  let verticalLine: f32 = crtUniforms.uLine[3];\\n\\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\\n\\n  let _c: f32 = select(1., curvature, curvature > 0.);\\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\\n  let uv: vec2<f32> = dir * k;\\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\\n  color *= j;\\n\\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\\n  color *= 0.99 + ceil(segment) * 0.015;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=crt.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uAngle;\\nuniform float uScale;\\nuniform bool uGrayScale;\\n\\nuniform vec4 uInputSize;\\n\\nfloat pattern()\\n{\\n    float s = sin(uAngle), c = cos(uAngle);\\n    vec2 tex = vTextureCoord * uInputSize.xy;\\n    vec2 point = vec2(\\n        c * tex.x - s * tex.y,\\n        s * tex.x + c * tex.y\\n    ) * uScale;\\n    return (sin(point.x) * sin(point.y)) * 4.0;\\n    }\\n\\n    void main()\\n    {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    vec3 colorRGB = vec3(color);\\n\\n    if (uGrayScale)\\n    {\\n        colorRGB = vec3(color.r + color.g + color.b) / 3.0;\\n    }\\n\\n    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=dot.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './dot.mjs';\nimport source from './dot2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _DotFilter = class _DotFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"DotFilter constructor params are now options object. See params: { scale, angle, grayscale }\");\n      options = { scale: options };\n      if (args[1] !== void 0)\n        options.angle = args[1];\n      if (args[2] !== void 0)\n        options.grayscale = args[2];\n    }\n    options = { ..._DotFilter.DEFAULT_OPTIONS, ...options };\n    const dotUniforms = {\n      uScale: { value: options.scale, type: \"f32\" },\n      uAngle: { value: options.angle, type: \"f32\" },\n      uGrayScale: { value: options.grayscale ? 1 : 0, type: \"f32\" }\n    };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"dot-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        dotUniforms\n      }\n    });\n  }\n  /**\n   * The scale of the effect.\n   * @default 1\n   */\n  get scale() {\n    return this.resources.dotUniforms.uniforms.uScale;\n  }\n  set scale(value) {\n    this.resources.dotUniforms.uniforms.uScale = value;\n  }\n  /**\n  * The radius of the effect.\n  * @default 5\n  */\n  get angle() {\n    return this.resources.dotUniforms.uniforms.uAngle;\n  }\n  set angle(value) {\n    this.resources.dotUniforms.uniforms.uAngle = value;\n  }\n  /**\n  * Whether to rendering it in gray scale.\n  * @default true\n  */\n  get grayscale() {\n    return this.resources.dotUniforms.uniforms.uGrayScale === 1;\n  }\n  set grayscale(value) {\n    this.resources.dotUniforms.uniforms.uGrayScale = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_DotFilter, \"DEFAULT_OPTIONS\", {\n  scale: 1,\n  angle: 5,\n  grayscale: true\n});\nlet DotFilter = _DotFilter;\n\nexport { DotFilter };\n//# sourceMappingURL=DotFilter.mjs.map\n","var source = \"struct DotUniforms {\\n  uScale:f32,\\n  uAngle:f32,\\n  uGrayScale:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \\n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\\n\\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\\n}\\n\\nfn pattern(uv: vec2<f32>) -> f32\\n{\\n  let s: f32 = sin(dotUniforms.uAngle);\\n  let c: f32 = cos(dotUniforms.uAngle);\\n  \\n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\\n  \\n  let p: vec2<f32> = vec2<f32>(\\n      c * tex.x - s * tex.y,\\n      s * tex.x + c * tex.y\\n  ) * dotUniforms.uScale;\\n\\n  return (sin(p.x) * sin(p.y)) * 4.0;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=dot2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uAlpha;\\nuniform vec3 uColor;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void){\\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\\n\\n    // Premultiply alpha\\n    sample.rgb = uColor.rgb * sample.a;\\n\\n    // alpha user alpha\\n    sample *= uAlpha;\\n\\n    finalColor = sample;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=drop-shadow.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter.mjs';\nimport fragment from './drop-shadow.mjs';\nimport source from './drop-shadow2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _DropShadowFilter = class _DropShadowFilter extends Filter {\n  /**\n   * @param options - Options for the DropShadowFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._DropShadowFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"drop-shadow-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        dropShadowUniforms: {\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uOffset: { value: options.offset, type: \"vec2<f32>\" }\n        }\n      },\n      resolution: options.resolution\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * Hide the contents, only show the shadow.\n     * @default false\n     */\n    __publicField(this, \"shadowOnly\", false);\n    __publicField(this, \"_color\");\n    __publicField(this, \"_blurFilter\");\n    __publicField(this, \"_basePass\");\n    this.uniforms = this.resources.dropShadowUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 0;\n    this._blurFilter = new KawaseBlurFilter({\n      strength: options.kernels ?? options.blur,\n      quality: options.kernels ? void 0 : options.quality\n    });\n    this._basePass = new Filter({\n      gpuProgram: GpuProgram.from({\n        vertex: {\n          source: wgslVertex,\n          entryPoint: \"mainVertex\"\n        },\n        fragment: {\n          source: `\n                    @group(0) @binding(1) var uTexture: texture_2d<f32>; \n                    @group(0) @binding(2) var uSampler: sampler;\n                    @fragment\n                    fn mainFragment(\n                        @builtin(position) position: vec4<f32>,\n                        @location(0) uv : vec2<f32>\n                    ) -> @location(0) vec4<f32> {\n                        return textureSample(uTexture, uSampler, uv);\n                    }\n                    `,\n          entryPoint: \"mainFragment\"\n        }\n      }),\n      glProgram: GlProgram.from({\n        vertex,\n        fragment: `\n                in vec2 vTextureCoord;\n                out vec4 finalColor;\n                uniform sampler2D uTexture;\n\n                void main(void){\n                    finalColor = texture(uTexture, vTextureCoord);\n                }\n                `,\n        name: \"drop-shadow-filter\"\n      }),\n      resources: {}\n    });\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const renderTarget = TexturePool.getSameSizeTexture(input);\n    filterManager.applyFilter(this, input, renderTarget, true);\n    this._blurFilter.apply(filterManager, renderTarget, output, clearMode);\n    if (!this.shadowOnly) {\n      filterManager.applyFilter(this._basePass, input, output, false);\n    }\n    TexturePool.returnTexture(renderTarget);\n  }\n  /**\n   * Set the offset position of the drop-shadow relative to the original image.\n   * @default [4,4]\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n    this._updatePadding();\n  }\n  /**\n   * Set the offset position of the drop-shadow relative to the original image on the `x` axis\n   * @default 4\n   */\n  get offsetX() {\n    return this.offset.x;\n  }\n  set offsetX(value) {\n    this.offset.x = value;\n    this._updatePadding();\n  }\n  /**\n   * Set the offset position of the drop-shadow relative to the original image on the `y` axis\n   * @default 4\n   */\n  get offsetY() {\n    return this.offset.y;\n  }\n  set offsetY(value) {\n    this.offset.y = value;\n    this._updatePadding();\n  }\n  /**\n   * The color value of shadow.\n   * @example [0.0, 0.0, 0.0] = 0x000000\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n   * The strength of the shadow's blur.\n   * @default 2\n   */\n  get blur() {\n    return this._blurFilter.strength;\n  }\n  set blur(value) {\n    this._blurFilter.strength = value;\n    this._updatePadding();\n  }\n  /**\n   * Sets the quality of the Blur Filter\n   * @default 4\n   */\n  get quality() {\n    return this._blurFilter.quality;\n  }\n  set quality(value) {\n    this._blurFilter.quality = value;\n    this._updatePadding();\n  }\n  /** Sets the kernels of the Blur Filter */\n  get kernels() {\n    return this._blurFilter.kernels;\n  }\n  set kernels(value) {\n    this._blurFilter.kernels = value;\n  }\n  /**\n   * Sets the pixelSize of the Kawase Blur filter\n   * @default [1,1]\n   */\n  get pixelSize() {\n    return this._blurFilter.pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this._blurFilter.pixelSize = value;\n  }\n  /**\n   * Sets the pixelSize of the Kawase Blur filter on the `x` axis\n   * @default 1\n   */\n  get pixelSizeX() {\n    return this._blurFilter.pixelSizeX;\n  }\n  set pixelSizeX(value) {\n    this._blurFilter.pixelSizeX = value;\n  }\n  /**\n   * Sets the pixelSize of the Kawase Blur filter on the `y` axis\n   * @default 1\n   */\n  get pixelSizeY() {\n    return this._blurFilter.pixelSizeY;\n  }\n  set pixelSizeY(value) {\n    this._blurFilter.pixelSizeY = value;\n  }\n  /**\n   * Recalculate the proper padding amount.\n   * @private\n   */\n  _updatePadding() {\n    const offsetPadding = Math.max(\n      Math.abs(this.offsetX),\n      Math.abs(this.offsetY)\n    );\n    this.padding = offsetPadding + this.blur * 2 + this.quality * 4;\n  }\n};\n/** Default values for options. */\n__publicField(_DropShadowFilter, \"DEFAULT_OPTIONS\", {\n  offset: { x: 4, y: 4 },\n  color: 0,\n  alpha: 0.5,\n  shadowOnly: false,\n  kernels: void 0,\n  blur: 2,\n  quality: 3,\n  pixelSize: { x: 1, y: 1 },\n  resolution: 1\n});\nlet DropShadowFilter = _DropShadowFilter;\n\nexport { DropShadowFilter };\n//# sourceMappingURL=DropShadowFilter.mjs.map\n","var source = \"struct DropShadowUniforms {\\n  uAlpha: f32,\\n  uColor: vec3<f32>,\\n  uOffset: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\\n\\n  // Premultiply alpha\\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\\n  // alpha user alpha\\n  color *= dropShadowUniforms.uAlpha;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=drop-shadow2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void)\\n{\\n\\tvec2 onePixel = vec2(1.0 / uInputSize);\\n\\n\\tvec4 color;\\n\\n\\tcolor.rgb = vec3(0.5);\\n\\n\\tcolor -= texture(uTexture, vTextureCoord - onePixel) * uStrength;\\n\\tcolor += texture(uTexture, vTextureCoord + onePixel) * uStrength;\\n\\n\\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\\n\\n\\tfloat alpha = texture(uTexture, vTextureCoord).a;\\n\\n\\tfinalColor = vec4(color.rgb * alpha, alpha);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=emboss2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './emboss2.mjs';\nimport source from './emboss.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EmbossFilter extends Filter {\n  /**\n   * @param {number} [strength=5] - Strength of the emboss.\n   */\n  constructor(strength = 5) {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"emboss-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        embossUniforms: {\n          uStrength: { value: strength, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.embossUniforms.uniforms;\n  }\n  /**\n   * Strength of the emboss\n   * @default 5\n   */\n  get strength() {\n    return this.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.uniforms.uStrength = value;\n  }\n}\n\nexport { EmbossFilter };\n//# sourceMappingURL=EmbossFilter.mjs.map\n","var source = \"struct EmbossUniforms {\\n  uStrength:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> embossUniforms : EmbossUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let onePixel: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\tvar color: vec3<f32> = vec3<f32>(0.5);\\n\\n\\tcolor -= (textureSample(uTexture, uSampler, uv - onePixel) * embossUniforms.uStrength).rgb;\\n\\tcolor += (textureSample(uTexture, uSampler, uv + onePixel) * embossUniforms.uStrength).rgb;\\n\\n\\tcolor = vec3<f32>((color.r + color.g + color.b) / 3.0);\\n\\n\\tlet blendColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n\\treturn vec4<f32>(color.rgb * blendColor.a, blendColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=emboss.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uDisplacementMap;\\nuniform float uSeed;\\nuniform vec2 uDimensions;\\nuniform float uAspect;\\nuniform float uFillMode;\\nuniform float uOffset;\\nuniform float uDirection;\\nuniform vec2 uRed;\\nuniform vec2 uGreen;\\nuniform vec2 uBlue;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst int TRANSPARENT = 0;\\nconst int ORIGINAL = 1;\\nconst int LOOP = 2;\\nconst int CLAMP = 3;\\nconst int MIRROR = 4;\\n\\nvoid main(void)\\n{\\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n        return;\\n    }\\n\\n    float sinDir = sin(uDirection);\\n    float cosDir = cos(uDirection);\\n\\n    float cx = coord.x - 0.5;\\n    float cy = (coord.y - 0.5) * uAspect;\\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\\n\\n    // displacementMap: repeat\\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\\n\\n    // displacementMap: mirror\\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\\n\\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\\n\\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\\n\\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\\n\\n    int fillMode = int(uFillMode);\\n\\n    if (fillMode == CLAMP) {\\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    } else {\\n        if( coord.x > uInputClamp.z ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x -= uInputClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x = uInputClamp.z * 2.0 - coord.x;\\n            }\\n        } else if( coord.x < uInputClamp.x ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x += uInputClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x *= -uInputClamp.z;\\n            }\\n        }\\n\\n        if( coord.y > uInputClamp.w ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y -= uInputClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y = uInputClamp.w * 2.0 - coord.y;\\n            }\\n        } else if( coord.y < uInputClamp.y ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y += uInputClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y *= -uInputClamp.w;\\n            }\\n        }\\n    }\\n\\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\\n    finalColor.a = texture(uTexture, coord).a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glitch2.mjs.map\n","import { Filter, GpuProgram, GlProgram, Texture, ImageSource, DEG_TO_RAD } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './glitch2.mjs';\nimport source from './glitch.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GlitchFilter = class _GlitchFilter extends Filter {\n  /**\n   * @param options - Options for the GlitchFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GlitchFilter.defaults, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"glitch-filter\"\n    });\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 4;\n    canvas.height = options.sampleSize ?? 512;\n    const texture = new Texture({\n      source: new ImageSource({ resource: canvas })\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        glitchUniforms: {\n          uSeed: { value: options?.seed ?? 0, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uAspect: { value: 1, type: \"f32\" },\n          uFillMode: { value: options?.fillMode ?? 0, type: \"f32\" },\n          uOffset: { value: options?.offset ?? 100, type: \"f32\" },\n          uDirection: { value: options?.direction ?? 0, type: \"f32\" },\n          uRed: { value: options.red, type: \"vec2<f32>\" },\n          uGreen: { value: options.green, type: \"vec2<f32>\" },\n          uBlue: { value: options.blue, type: \"vec2<f32>\" }\n        },\n        uDisplacementMap: texture.source,\n        uDisplacementSampler: texture.source.style\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     */\n    __publicField(this, \"average\", false);\n    /** Minimum size of slices as a portion of the `sampleSize` */\n    __publicField(this, \"minSize\", 8);\n    /** Height of the displacement map canvas. */\n    __publicField(this, \"sampleSize\", 512);\n    /** Internally generated canvas. */\n    __publicField(this, \"_canvas\");\n    /**\n     * The displacement map is used to generate the bands.\n     * If using your own texture, `slices` will be ignored.\n     *\n     * @member {Texture}\n     * @readonly\n     */\n    __publicField(this, \"texture\");\n    /** Internal number of slices */\n    __publicField(this, \"_slices\", 0);\n    __publicField(this, \"_sizes\", new Float32Array(1));\n    __publicField(this, \"_offsets\", new Float32Array(1));\n    this.uniforms = this.resources.glitchUniforms.uniforms;\n    this._canvas = canvas;\n    this.texture = texture;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in Filter\n   * @private\n   */\n  apply(filterManager, input, output, clearMode) {\n    const { width, height } = input.frame;\n    this.uniforms.uDimensions[0] = width;\n    this.uniforms.uDimensions[1] = height;\n    this.uniforms.uAspect = height / width;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Randomize the slices size (heights).\n   *\n   * @private\n   */\n  _randomizeSizes() {\n    const arr = this._sizes;\n    const last = this._slices - 1;\n    const size = this.sampleSize;\n    const min = Math.min(this.minSize / size, 0.9 / this._slices);\n    if (this.average) {\n      const count = this._slices;\n      let rest = 1;\n      for (let i = 0; i < last; i++) {\n        const averageWidth = rest / (count - i);\n        const w = Math.max(averageWidth * (1 - Math.random() * 0.6), min);\n        arr[i] = w;\n        rest -= w;\n      }\n      arr[last] = rest;\n    } else {\n      let rest = 1;\n      const ratio = Math.sqrt(1 / this._slices);\n      for (let i = 0; i < last; i++) {\n        const w = Math.max(ratio * rest * Math.random(), min);\n        arr[i] = w;\n        rest -= w;\n      }\n      arr[last] = rest;\n    }\n    this.shuffle();\n  }\n  /**\n   * Shuffle the sizes of the slices, advanced usage.\n   */\n  shuffle() {\n    const arr = this._sizes;\n    const last = this._slices - 1;\n    for (let i = last; i > 0; i--) {\n      const rand = Math.random() * i >> 0;\n      const temp = arr[i];\n      arr[i] = arr[rand];\n      arr[rand] = temp;\n    }\n  }\n  /**\n   * Randomize the values for offset from -1 to 1\n   *\n   * @private\n   */\n  _randomizeOffsets() {\n    for (let i = 0; i < this._slices; i++) {\n      this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);\n    }\n  }\n  /**\n   * Regenerating random size, offsets for slices.\n   */\n  refresh() {\n    this._randomizeSizes();\n    this._randomizeOffsets();\n    this.redraw();\n  }\n  /**\n   * Redraw displacement bitmap texture, advanced usage.\n   */\n  redraw() {\n    const size = this.sampleSize;\n    const texture = this.texture;\n    const ctx = this._canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, 8, size);\n    let offset;\n    let y = 0;\n    for (let i = 0; i < this._slices; i++) {\n      offset = Math.floor(this._offsets[i] * 256);\n      const height = this._sizes[i] * size;\n      const red = offset > 0 ? offset : 0;\n      const green = offset < 0 ? -offset : 0;\n      ctx.fillStyle = `rgba(${red}, ${green}, 0, 1)`;\n      ctx.fillRect(0, y >> 0, size, height + 1 >> 0);\n      y += height;\n    }\n    texture.source.update();\n  }\n  /**\n   * Manually custom slices size (height) of displacement bitmap\n   *\n   * @member {number[]|Float32Array}\n   */\n  set sizes(sizes) {\n    const len = Math.min(this._slices, sizes.length);\n    for (let i = 0; i < len; i++) {\n      this._sizes[i] = sizes[i];\n    }\n  }\n  get sizes() {\n    return this._sizes;\n  }\n  /**\n   * Manually set custom slices offset of displacement bitmap, this is\n   * a collection of values from -1 to 1. To change the max offset value\n   * set `offset`.\n   *\n   * @member {number[]|Float32Array}\n   */\n  set offsets(offsets) {\n    const len = Math.min(this._slices, offsets.length);\n    for (let i = 0; i < len; i++) {\n      this._offsets[i] = offsets[i];\n    }\n  }\n  get offsets() {\n    return this._offsets;\n  }\n  /**\n   * The count of slices.\n   * @default 5\n   */\n  get slices() {\n    return this._slices;\n  }\n  set slices(value) {\n    if (this._slices === value)\n      return;\n    this._slices = value;\n    this._sizes = new Float32Array(value);\n    this._offsets = new Float32Array(value);\n    this.refresh();\n  }\n  /**\n   * The maximum offset amount of slices.\n   * @default 100\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n  }\n  /**\n   * A seed value for randomizing glitch effect.\n   * @default 0\n   */\n  get seed() {\n    return this.uniforms.uSeed;\n  }\n  set seed(value) {\n    this.uniforms.uSeed = value;\n  }\n  /**\n   * The fill mode of the space after the offset.\n   * @default FILL_MODES.TRANSPARENT\n   */\n  get fillMode() {\n    return this.uniforms.uFillMode;\n  }\n  set fillMode(value) {\n    this.uniforms.uFillMode = value;\n  }\n  /**\n   * The angle in degree of the offset of slices.\n   * @default 0\n   */\n  get direction() {\n    return this.uniforms.uDirection / DEG_TO_RAD;\n  }\n  set direction(value) {\n    this.uniforms.uDirection = value * DEG_TO_RAD;\n  }\n  /**\n   * Red channel offset.\n   * @default {x:0,y:0}\n   */\n  get red() {\n    return this.uniforms.uRed;\n  }\n  set red(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uRed = value;\n  }\n  /**\n   * Green channel offset.\n   * @default {x:0,y:0}\n   */\n  get green() {\n    return this.uniforms.uGreen;\n  }\n  set green(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uGreen = value;\n  }\n  /**\n   * Blue offset.\n   * @default {x:0,y:0}\n   */\n  get blue() {\n    return this.uniforms.uBlue;\n  }\n  set blue(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uBlue = value;\n  }\n  /**\n   * Removes all references\n   */\n  destroy() {\n    this.texture?.destroy(true);\n    this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;\n  }\n};\n/** Default constructor options. */\n__publicField(_GlitchFilter, \"defaults\", {\n  slices: 5,\n  offset: 100,\n  direction: 0,\n  fillMode: 0,\n  average: false,\n  seed: 0,\n  red: { x: 0, y: 0 },\n  green: { x: 0, y: 0 },\n  blue: { x: 0, y: 0 },\n  minSize: 8,\n  sampleSize: 512\n});\nlet GlitchFilter = _GlitchFilter;\n\nexport { GlitchFilter };\n//# sourceMappingURL=GlitchFilter.mjs.map\n","var source = \"struct GlitchUniforms {\\n  uSeed: f32,\\n  uDimensions: vec2<f32>,\\n  uAspect: f32,\\n  uFillMode: f32,\\n  uOffset: f32,\\n  uDirection: f32,\\n  uRed: vec2<f32>,\\n  uGreen: vec2<f32>,\\n  uBlue: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;\\n@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; \\n@group(1) @binding(2) var uDisplacementSampler: sampler; \\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uSeed: f32 = glitchUniforms.uSeed;\\n  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;\\n  let uAspect: f32 = glitchUniforms.uAspect;\\n  let uOffset: f32 = glitchUniforms.uOffset;\\n  let uDirection: f32 = glitchUniforms.uDirection;\\n  let uRed: vec2<f32> = glitchUniforms.uRed;\\n  let uGreen: vec2<f32> = glitchUniforms.uGreen;\\n  let uBlue: vec2<f32> = glitchUniforms.uBlue;\\n\\n  let uInputSize: vec4<f32> = gfu.uInputSize;\\n  let uInputClamp: vec4<f32> = gfu.uInputClamp;\\n\\n  var discarded: bool = false;\\n  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n      discarded = true;\\n    }\\n\\n    let sinDir: f32 = sin(uDirection);\\n    let cosDir: f32 = cos(uDirection);\\n\\n    let cx: f32 = coord.x - 0.5;\\n    let cy: f32 = (coord.y - 0.5) * uAspect;\\n    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\\n\\n    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);\\n\\n    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));\\n\\n    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);\\n\\n    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);\\n\\n    let fillMode: i32 = i32(glitchUniforms.uFillMode);\\n\\n    if (fillMode == CLAMP) {\\n      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    } else {\\n      if (coord.x > uInputClamp.z) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.x = coord.x - uInputClamp.z;\\n        } else if (fillMode == MIRROR) {\\n          coord.x = uInputClamp.z * 2.0 - coord.x;\\n        }\\n      } else if (coord.x < uInputClamp.x) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.x = coord.x + uInputClamp.z;\\n        } else if (fillMode == MIRROR) {\\n          coord.x = coord.x * -uInputClamp.z;\\n        }\\n      }\\n\\n      if (coord.y > uInputClamp.w) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.y = coord.y - uInputClamp.w;\\n        } else if (fillMode == MIRROR) {\\n          coord.y = uInputClamp.w * 2.0 - coord.y;\\n        }\\n      } else if (coord.y < uInputClamp.y) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.y = coord.y + uInputClamp.w;\\n        } else if (fillMode == MIRROR) {\\n          coord.y = coord.y * -uInputClamp.w;\\n        }\\n      }\\n    }\\n\\n    let seedR: f32 = 1.0 - uSeed * 0.4;\\n    let seedG: f32 = 1.0 - uSeed * 0.3;\\n    let seedB: f32 = 1.0 - uSeed * 0.2;\\n\\n    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);\\n    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);\\n    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);\\n\\n    let r = textureSample(uTexture, uSampler, coord + offsetR).r;\\n    let g = textureSample(uTexture, uSampler, coord + offsetG).g;\\n    let b = textureSample(uTexture, uSampler, coord + offsetB).b;\\n    let a = textureSample(uTexture, uSampler, coord).a;\\n\\n    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);\\n}\\n\\nconst TRANSPARENT: i32 = 0;\\nconst ORIGINAL: i32 = 1;\\nconst LOOP: i32 = 2;\\nconst CLAMP: i32 = 3;\\nconst MIRROR: i32 = 4;\";\n\nexport { source as default };\n//# sourceMappingURL=glitch.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uStrength;\\nuniform vec3 uColor;\\nuniform float uKnockout;\\nuniform float uAlpha;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159265358979323846264;\\n\\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\\nconst float DIST = __DIST__;\\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\\n\\nvoid main(void) {\\n    vec2 px = vec2(1.) / uInputSize.xy;\\n\\n    float totalAlpha = 0.;\\n\\n    vec2 direction;\\n    vec2 displaced;\\n    vec4 curColor;\\n\\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\\n      direction = vec2(cos(angle), sin(angle)) * px;\\n\\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\\n          curColor = texture(uTexture, displaced);\\n          totalAlpha += (DIST - curDistance) * curColor.a;\\n      }\\n    }\\n    \\n    curColor = texture(uTexture, vTextureCoord);\\n\\n    vec4 glowColor = vec4(uColor, uAlpha);\\n    bool knockout = uKnockout > .5;\\n    float innerStrength = uStrength[0];\\n    float outerStrength = uStrength[1];\\n\\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\\n    float innerGlowStrength = min(1., innerGlowAlpha);\\n    \\n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\\n\\n    if (knockout) {\\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\\n    }\\n    else {\\n      finalColor = innerColor + outerGlowColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glow.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './glow.mjs';\nimport source from './glow2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GlowFilter = class _GlowFilter extends Filter {\n  /**\n   * @param options - Options for the GlowFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GlowFilter.DEFAULT_OPTIONS, ...options };\n    const distance = options.distance ?? 10;\n    const quality = options.quality ?? 0.1;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / quality / distance).toFixed(7)}`).replace(/__DIST__/gi, `${distance.toFixed(0)}.0`),\n      name: \"glow-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        glowUniforms: {\n          uDistance: { value: distance, type: \"f32\" },\n          uStrength: { value: [options.innerStrength, options.outerStrength], type: \"vec2<f32>\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uQuality: { value: quality, type: \"f32\" },\n          uKnockout: { value: options?.knockout ?? false ? 1 : 0, type: \"f32\" }\n        }\n      },\n      padding: distance\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.glowUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 16777215;\n  }\n  /**\n   * Only draw the glow, not the texture itself\n   * @default false\n   */\n  get distance() {\n    return this.uniforms.uDistance;\n  }\n  set distance(value) {\n    this.uniforms.uDistance = this.padding = value;\n  }\n  /**\n  * The strength of the glow inward from the edge of the sprite.\n  * @default 0\n  */\n  get innerStrength() {\n    return this.uniforms.uStrength[0];\n  }\n  set innerStrength(value) {\n    this.uniforms.uStrength[0] = value;\n  }\n  /**\n  * The strength of the glow outward from the edge of the sprite.\n  * @default 4\n  */\n  get outerStrength() {\n    return this.uniforms.uStrength[1];\n  }\n  set outerStrength(value) {\n    this.uniforms.uStrength[1] = value;\n  }\n  /**\n  * The color of the glow.\n  * @default 0xFFFFFF\n  */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n  * The alpha of the glow\n  * @default 1\n  */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n  * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n  * @default 0.1\n  */\n  get quality() {\n    return this.uniforms.uQuality;\n  }\n  set quality(value) {\n    this.uniforms.uQuality = value;\n  }\n  /**\n  * Only draw the glow, not the texture itself\n  * @default false\n  */\n  get knockout() {\n    return this.uniforms.uKnockout === 1;\n  }\n  set knockout(value) {\n    this.uniforms.uKnockout = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_GlowFilter, \"DEFAULT_OPTIONS\", {\n  distance: 10,\n  outerStrength: 4,\n  innerStrength: 0,\n  color: 16777215,\n  alpha: 1,\n  quality: 0.1,\n  knockout: false\n});\nlet GlowFilter = _GlowFilter;\n\nexport { GlowFilter };\n//# sourceMappingURL=GlowFilter.mjs.map\n","var source = \"struct GlowUniforms {\\n  uDistance: f32,\\n  uStrength: vec2<f32>,\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uQuality: f32,\\n  uKnockout: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let quality = glowUniforms.uQuality;\\n  let distance = glowUniforms.uDistance;\\n\\n  let dist: f32 = glowUniforms.uDistance;\\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\\n\\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\n  var totalAlpha: f32 = 0.0;\\n\\n  var direction: vec2<f32>;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n      curColor = textureSample(uTexture, uSampler, displaced);\\n      totalAlpha += (dist - curDistance) * curColor.a;\\n    }\\n  }\\n    \\n  curColor = textureSample(uTexture, uSampler, uv);\\n\\n  let glowColorRGB = glowUniforms.uColor;\\n  let glowAlpha = glowUniforms.uAlpha;\\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\\n  let innerStrength = glowUniforms.uStrength[0];\\n  let outerStrength = glowUniforms.uStrength[1];\\n\\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\\n  \\n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\\n  \\n  if (knockout) {\\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\\n  }\\n  else {\\n    return innerColor + outerGlowColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\";\n\nexport { source as default };\n//# sourceMappingURL=glow2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uDimensions;\\nuniform float uParallel;\\nuniform vec2 uLight;\\nuniform float uAspect;\\nuniform float uTime;\\nuniform vec3 uRay;\\n\\nuniform vec4 uInputSize;\\n\\n${PERLIN}\\n\\nvoid main(void) {\\n    vec2 uDimensions = uDimensions;\\n    bool uParallel = uParallel > 0.5;\\n    vec2 uLight = uLight;\\n    float uAspect = uAspect;\\n\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\\n\\n    float d;\\n\\n    if (uParallel) {\\n        float _cos = uLight.x;\\n        float _sin = uLight.y;\\n        d = (_cos * coord.x) + (_sin * coord.y * uAspect);\\n    } else {\\n        float dx = coord.x - uLight.x / uDimensions.x;\\n        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;\\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\\n        d = dy / dis;\\n    }\\n\\n    float uTime = uTime;\\n    vec3 uRay = uRay;\\n\\n    float gain = uRay[0];\\n    float lacunarity = uRay[1];\\n    float alpha = uRay[2];\\n\\n    vec3 dir = vec3(d, d, 0.0);\\n    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\\n    noise = mix(noise, 0.0, 0.3);\\n    //fade vertically.\\n    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);\\n    mist.a = 1.0;\\n    // apply user alpha\\n    mist *= alpha;\\n\\n    finalColor = texture(uTexture, vTextureCoord) + mist;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=god-ray2.mjs.map\n","import { Filter, GpuProgram, GlProgram, DEG_TO_RAD } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './god-ray2.mjs';\nimport source from './god-ray.mjs';\nimport perlin from './perlin.mjs';\nimport sourcePerlin from './perlin2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GodrayFilter = class _GodrayFilter extends Filter {\n  /**\n   * @param options - Options for the GodrayFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GodrayFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: source.replace(\"${PERLIN}\", sourcePerlin),\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(\"${PERLIN}\", perlin),\n      name: \"god-ray-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        godrayUniforms: {\n          uLight: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uParallel: { value: 0, type: \"f32\" },\n          uAspect: { value: 0, type: \"f32\" },\n          uTime: { value: options.time, type: \"f32\" },\n          uRay: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * The current time position\n     * @default 0\n     */\n    __publicField(this, \"time\", 0);\n    __publicField(this, \"_angleLight\", [0, 0]);\n    __publicField(this, \"_angle\", 0);\n    __publicField(this, \"_center\");\n    this.uniforms = this.resources.godrayUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in Filter\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const width = input.frame.width;\n    const height = input.frame.height;\n    this.uniforms.uLight[0] = this.parallel ? this._angleLight[0] : this._center.x;\n    this.uniforms.uLight[1] = this.parallel ? this._angleLight[1] : this._center.y;\n    this.uniforms.uDimensions[0] = width;\n    this.uniforms.uDimensions[1] = height;\n    this.uniforms.uAspect = height / width;\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The angle/light-source of the rays in degrees. For instance,\n   * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays\n   * @default 30\n   */\n  get angle() {\n    return this._angle;\n  }\n  set angle(value) {\n    this._angle = value;\n    const radians = value * DEG_TO_RAD;\n    this._angleLight[0] = Math.cos(radians);\n    this._angleLight[1] = Math.sin(radians);\n  }\n  /**\n   * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point\n   * @default true\n   */\n  get parallel() {\n    return this.uniforms.uParallel > 0.5;\n  }\n  set parallel(value) {\n    this.uniforms.uParallel = value ? 1 : 0;\n  }\n  /**\n   * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.\n   * @default {x:0,y:0}\n   */\n  get center() {\n    return this._center;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this._center = value;\n  }\n  /**\n   * Focal point for non-parallel rays on the `x` axis, to use this `parallel` must be set to `false`.\n   * @default 0\n   */\n  get centerX() {\n    return this.center.x;\n  }\n  set centerX(value) {\n    this.center.x = value;\n  }\n  /**\n   * Focal point for non-parallel rays on the `y` axis, to use this `parallel` must be set to `false`.\n   * @default 0\n   */\n  get centerY() {\n    return this.center.y;\n  }\n  set centerY(value) {\n    this.center.y = value;\n  }\n  /**\n   * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n   * where a value closer to 0 will produce a subtler effect\n   * @default 0.5\n   */\n  get gain() {\n    return this.uniforms.uRay[0];\n  }\n  set gain(value) {\n    this.uniforms.uRay[0] = value;\n  }\n  /**\n   * The density of the fractal noise.\n   * A higher amount produces more rays and a smaller amount produces fewer waves\n   * @default 2.5\n   */\n  get lacunarity() {\n    return this.uniforms.uRay[1];\n  }\n  set lacunarity(value) {\n    this.uniforms.uRay[1] = value;\n  }\n  /**\n   * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uRay[2];\n  }\n  set alpha(value) {\n    this.uniforms.uRay[2] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_GodrayFilter, \"DEFAULT_OPTIONS\", {\n  angle: 30,\n  gain: 0.5,\n  lacunarity: 2.5,\n  parallel: true,\n  time: 0,\n  center: { x: 0, y: 0 },\n  alpha: 1\n});\nlet GodrayFilter = _GodrayFilter;\n\nexport { GodrayFilter };\n//# sourceMappingURL=GodrayFilter.mjs.map\n","var source = \"struct GodrayUniforms {\\n  uLight: vec2<f32>,\\n  uParallel: f32,\\n  uAspect: f32,\\n  uTime: f32,\\n  uRay: vec3<f32>,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;\\n  let uParallel: bool = godrayUniforms.uParallel > 0.5;\\n  let uLight: vec2<f32> = godrayUniforms.uLight;\\n  let uAspect: f32 = godrayUniforms.uAspect;\\n\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;\\n\\n  var d: f32;\\n\\n  if (uParallel) {\\n    let _cos: f32 = uLight.x;\\n    let _sin: f32 = uLight.y;\\n    d = (_cos * coord.x) + (_sin * coord.y * uAspect);\\n  } else {\\n    let dx: f32 = coord.x - uLight.x / uDimensions.x;\\n    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;\\n    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;\\n    d = dy / dis;\\n  }\\n\\n  let uTime: f32 = godrayUniforms.uTime;\\n  let uRay: vec3<f32> = godrayUniforms.uRay;\\n  \\n  let gain = uRay[0];\\n  let lacunarity = uRay[1];\\n  let alpha = uRay[2];\\n\\n  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);\\n  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);\\n  noise = mix(noise, 0.0, 0.3);\\n  //fade vertically.\\n  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);\\n  mist.a = 1.0;\\n  // apply user alpha\\n  mist *= alpha;\\n  return textureSample(uTexture, uSampler, uv) + mist;\\n}\\n\\n${PERLIN}\";\n\nexport { source as default };\n//# sourceMappingURL=god-ray.mjs.map\n","var sourcePerlin = \"// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\\n\\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\\n{\\n  return x - y * floor(x/y);\\n}\\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nfn permute4(x: vec4<f32>) -> vec4<f32>\\n{\\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\\n}\\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nfn fade3(t: vec3<f32>) -> vec3<f32>\\n{\\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\\n}\\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\\n\\nfn perlinNoise2(P: vec2<f32>) -> f32 {\\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\\n  let ix = Pi.xzxz;\\n  let iy = Pi.yyww;\\n  let fx = Pf.xzxz;\\n  let fy = Pf.yyww;\\n  let i = permute4(permute4(ix) + iy);\\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\\n  let gy = abs(gx) - 0.5;\\n  let tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\\n  let norm = 1.79284291400159 - 0.85373472095314 *\\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\\n  g00 = g00 * norm.x;\\n  g01 = g01 * norm.y;\\n  g10 = g10 * norm.z;\\n  g11 = g11 * norm.w;\\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\\n  let fade_xy = fade2(Pf.xy);\\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return 2.3 * n_xy;\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\\n{\\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289Vec3(Pi0);\\n    Pi1 = mod289Vec3(Pi1);\\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\\n    let iz0: vec4<f32> = Pi0.zzzz;\\n    let iz1: vec4<f32> = Pi1.zzzz;\\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n    let n000: f32 = dot(g000, Pf0);\\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\\n    let n111: f32 = dot(g111, Pf1);\\n    let fade_xyz: vec3<f32> = fade3(Pf0);\\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n}\\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\\n{\\n    var sum: f32 = 0.0;\\n    var sc: f32 = 1.0;\\n    var totalgain: f32 = 1.0;\\n    for (var i = 0.0; i < 6.0; i += 1)\\n    {\\n        sum += totalgain * perlinNoise3(P * sc, rep);\\n        sc *= lacunarity;\\n        totalgain *= gain;\\n    }\\n    return abs(sum);\\n}\";\n\nexport { sourcePerlin as default };\n//# sourceMappingURL=perlin2.mjs.map\n","var perlin = \"vec3 mod289(vec3 x)\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 mod289(vec4 x)\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 permute(vec4 x)\\n{\\n    return mod289(((x * 34.0) + 1.0) * x);\\n}\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec3 fade(vec3 t)\\n{\\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\\n}\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec3 P, vec3 rep)\\n{\\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = Pi0.zzzz;\\n    vec4 iz1 = Pi1.zzzz;\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n    vec4 sz0 = step(gz0, vec4(0.0));\\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n    vec4 sz1 = step(gz1, vec4(0.0));\\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n    float n000 = dot(g000, Pf0);\\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n    float n111 = dot(g111, Pf1);\\n    vec3 fade_xyz = fade(Pf0);\\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n}\\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\\n{\\n    float sum = 0.0;\\n    float sc = 1.0;\\n    float totalgain = 1.0;\\n    for (float i = 0.0; i < 6.0; i++)\\n    {\\n        sum += totalgain * pnoise(P * sc, rep);\\n        sc *= lacunarity;\\n        totalgain *= gain;\\n    }\\n    return abs(sum);\\n}\\n\";\n\nexport { perlin as default };\n//# sourceMappingURL=perlin.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './grayscale2.mjs';\nimport source from './grayscale.mjs';\n\nclass GrayscaleFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"grayscale-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {}\n    });\n  }\n}\n\nexport { GrayscaleFilter };\n//# sourceMappingURL=GrayscaleFilter.mjs.map\n","var source = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let g: f32 = dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114));\\n  return vec4<f32>(vec3<f32>(g), 1.);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=grayscale.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\n\\n// https://en.wikipedia.org/wiki/Luma_(video)\\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\\n\\nvoid main()\\n{\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    finalColor = vec4(\\n        vec3(c.r * weight.r + c.g * weight.g  + c.b * weight.b),\\n        c.a\\n    );\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=grayscale2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uHsl;\\nuniform float uAlpha;\\nuniform float uColorize;\\n\\n// https://en.wikipedia.org/wiki/Luma_(video)\\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\\n\\nfloat getWeightedAverage(vec3 rgb) {\\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\\n}\\n\\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\\n\\nvec3 hueShift(vec3 color, float angle) {\\n    float cosAngle = cos(angle);\\n    return vec3(\\n    color * cosAngle +\\n    cross(k, color) * sin(angle) +\\n    k * dot(k, color) * (1.0 - cosAngle)\\n    );\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    vec3 resultRGB = color.rgb;\\n\\n    float hue = uHsl[0];\\n    float saturation = uHsl[1];\\n    float lightness = uHsl[2];\\n\\n    // colorize\\n    if (uColorize > 0.5) {\\n        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);\\n    }\\n\\n    // hue\\n    resultRGB = hueShift(resultRGB, hue);\\n\\n    // saturation\\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\\n    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\\n\\n    if (saturation > 0.) {\\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\\n    } else {\\n        resultRGB -= (average - resultRGB) * saturation;\\n    }\\n\\n    // lightness\\n    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));\\n\\n    // alpha\\n    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=hsladjustment.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './hsladjustment.mjs';\nimport source from './hsladjustment2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _HslAdjustmentFilter = class _HslAdjustmentFilter extends Filter {\n  /**\n   * @param options - Options for the HslAdjustmentFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._HslAdjustmentFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"hsl-adjustment-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        hslUniforms: {\n          uHsl: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uColorize: { value: options.colorize ? 1 : 0, type: \"f32\" },\n          uAlpha: { value: options.alpha, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_hue\");\n    this.uniforms = this.resources.hslUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * The amount of hue in degrees (-180 to 180)\n   * @default 0\n   */\n  get hue() {\n    return this._hue;\n  }\n  set hue(value) {\n    this._hue = value;\n    this.uniforms.uHsl[0] = value * (Math.PI / 180);\n  }\n  /**\n   * The amount of lightness (-1 to 1)\n   * @default 0\n   */\n  get saturation() {\n    return this.uniforms.uHsl[1];\n  }\n  set saturation(value) {\n    this.uniforms.uHsl[1] = value;\n  }\n  /**\n   * The amount of lightness (-1 to 1)\n   * @default 0\n   */\n  get lightness() {\n    return this.uniforms.uHsl[2];\n  }\n  set lightness(value) {\n    this.uniforms.uHsl[2] = value;\n  }\n  /**\n   * Whether to colorize the image\n   * @default false\n   */\n  get colorize() {\n    return this.uniforms.uColorize === 1;\n  }\n  set colorize(value) {\n    this.uniforms.uColorize = value ? 1 : 0;\n  }\n  /**\n   * The amount of alpha (0 to 1)\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n};\n/** Default values for options. */\n__publicField(_HslAdjustmentFilter, \"DEFAULT_OPTIONS\", {\n  hue: 0,\n  saturation: 0,\n  lightness: 0,\n  colorize: false,\n  alpha: 1\n});\nlet HslAdjustmentFilter = _HslAdjustmentFilter;\n\nexport { HslAdjustmentFilter };\n//# sourceMappingURL=HslAdjustmentFilter.mjs.map\n","var source = \"struct HslUniforms {\\n  uHsl:vec3<f32>,\\n  uColorize:f32,\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n    var resultRGB: vec3<f32> = color.rgb;\\n\\n    let hue: f32 = hslUniforms.uHsl[0];\\n    let saturation: f32 = hslUniforms.uHsl[1];\\n    let lightness: f32 = hslUniforms.uHsl[2];\\n\\n    // colorize\\n    if (hslUniforms.uColorize > 0.5) {\\n        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);\\n    }\\n\\n    // hue\\n    resultRGB = hueShift(resultRGB, hue);\\n\\n    // saturation\\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\\n    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\\n\\n    if (saturation > 0.) {\\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\\n    } else {\\n        resultRGB -= (average - resultRGB) * saturation;\\n    }\\n\\n    // lightness\\n    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));\\n\\n    // alpha\\n    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);\\n}\\n\\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\\nconst k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);\\n\\nfn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> \\n{\\n    let cosAngle: f32 = cos(angle);\\n    return vec3<f32>(\\n    color * cosAngle +\\n    cross(k, color) * sin(angle) +\\n    k * dot(k, color) * (1.0 - cosAngle)\\n    );\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=hsladjustment2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uVelocity;\\nuniform int uKernelSize;\\nuniform float uOffset;\\n\\nuniform vec4 uInputSize;\\n\\nconst int MAX_KERNEL_SIZE = 2048;\\n\\n// Notice:\\n// the perfect way:\\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\\n// So use uKernelSize directly.\\n\\nvoid main(void)\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    if (uKernelSize == 0)\\n    {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    vec2 velocity = uVelocity / uInputSize.xy;\\n    float offset = -uOffset / length(uVelocity) - 0.5;\\n    int k = uKernelSize - 1;\\n\\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\\n        if (i == k) {\\n            break;\\n        }\\n        vec2 bias = velocity * (float(i) / float(k) + offset);\\n        color += texture(uTexture, vTextureCoord + bias);\\n    }\\n    finalColor = color / float(uKernelSize);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=motion-blur2.mjs.map\n","import { Filter, ObservablePoint, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './motion-blur2.mjs';\nimport source from './motion-blur.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _MotionBlurFilter = class _MotionBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options) || \"x\" in options && \"y\" in options || options instanceof ObservablePoint) {\n      deprecation(\"6.0.0\", \"MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }\");\n      const x = \"x\" in options ? options.x : options[0];\n      const y = \"y\" in options ? options.y : options[1];\n      options = { velocity: { x, y } };\n      if (args[1] !== void 0)\n        options.kernelSize = args[1];\n      if (args[2] !== void 0)\n        options.offset = args[2];\n    }\n    options = { ..._MotionBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"motion-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        motionBlurUniforms: {\n          uVelocity: { value: options.velocity, type: \"vec2<f32>\" },\n          uKernelSize: { value: Math.trunc(options.kernelSize ?? 5), type: \"i32\" },\n          uOffset: { value: options.offset, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_kernelSize\");\n    this.uniforms = this.resources.motionBlurUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Sets the velocity of the motion for blur effect\n   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n   * once defined in the constructor\n   * @default {x:0,y:0}\n   */\n  get velocity() {\n    return this.uniforms.uVelocity;\n  }\n  set velocity(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uVelocity = value;\n    this._updateDirty();\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get velocityX() {\n    return this.velocity.x;\n  }\n  set velocityX(value) {\n    this.velocity.x = value;\n    this._updateDirty();\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get velocityY() {\n    return this.velocity.y;\n  }\n  set velocityY(value) {\n    this.velocity.y = value;\n    this._updateDirty();\n  }\n  /**\n   * The kernelSize of the blur filter. Must be odd number >= 5\n   * @default 5\n   */\n  get kernelSize() {\n    return this._kernelSize;\n  }\n  set kernelSize(value) {\n    this._kernelSize = value;\n    this._updateDirty();\n  }\n  /**\n   * The offset of the blur filter\n   * @default 0\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n  }\n  _updateDirty() {\n    this.padding = (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >> 0) + 1;\n    this.uniforms.uKernelSize = this.velocityX !== 0 || this.velocityY !== 0 ? this._kernelSize : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_MotionBlurFilter, \"DEFAULT_OPTIONS\", {\n  velocity: { x: 0, y: 0 },\n  kernelSize: 5,\n  offset: 0\n});\nlet MotionBlurFilter = _MotionBlurFilter;\n\nexport { MotionBlurFilter };\n//# sourceMappingURL=MotionBlurFilter.mjs.map\n","var source = \"struct MotionBlurUniforms {\\n  uVelocity: vec2<f32>,\\n  uKernelSize: i32,\\n  uOffset: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uVelocity = motionBlurUniforms.uVelocity;\\n  let uKernelSize = motionBlurUniforms.uKernelSize;\\n  let uOffset = motionBlurUniforms.uOffset;\\n\\n  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;\\n  let offset: f32 = -uOffset / length(uVelocity) - 0.5;\\n  let k: i32 = min(uKernelSize - 1, MAX_KERNEL_SIZE - 1);\\n\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  for(var i: i32 = 0; i < k; i += 1) {\\n    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);\\n    color += textureSample(uTexture, uSampler, uv + bias);\\n  }\\n  \\n  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);\\n}\\n\\nconst MAX_KERNEL_SIZE: i32 = 2048;\";\n\nexport { source as default };\n//# sourceMappingURL=motion-blur.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nconst int MAX_COLORS = ${MAX_COLORS};\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uOriginalColors[MAX_COLORS];\\nuniform vec3 uTargetColors[MAX_COLORS];\\nuniform float uTolerance;\\n\\nvoid main(void)\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n\\n    float alpha = finalColor.a;\\n    if (alpha < 0.0001)\\n    {\\n      return;\\n    }\\n\\n    vec3 color = finalColor.rgb / alpha;\\n\\n    for(int i = 0; i < MAX_COLORS; i++)\\n    {\\n      vec3 origColor = uOriginalColors[i];\\n      if (origColor.r < 0.0)\\n      {\\n        break;\\n      }\\n      vec3 colorDiff = origColor - color;\\n      if (length(colorDiff) < uTolerance)\\n      {\\n        vec3 targetColor = uTargetColors[i];\\n        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);\\n        return;\\n      }\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=multi-color-replace.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './multi-color-replace.mjs';\nimport source from './multi-color-replace2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _MultiColorReplaceFilter = class _MultiColorReplaceFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }\");\n      options = { replacements: options };\n      if (args[1])\n        options.tolerance = args[1];\n      if (args[2])\n        options.maxColors = args[2];\n    }\n    options = { ..._MultiColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n    const maxColors = options.maxColors ?? options.replacements.length;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: source.replace(/\\$\\{MAX_COLORS\\}/g, maxColors.toFixed(0)),\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/\\$\\{MAX_COLORS\\}/g, maxColors.toFixed(0)),\n      name: \"multi-color-replace-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        multiColorReplaceUniforms: {\n          uOriginalColors: {\n            value: new Float32Array(3 * maxColors),\n            type: \"vec3<f32>\",\n            size: maxColors\n          },\n          uTargetColors: {\n            value: new Float32Array(3 * maxColors),\n            type: \"vec3<f32>\",\n            size: maxColors\n          },\n          uTolerance: { value: options.tolerance, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_replacements\", []);\n    __publicField(this, \"_maxColors\");\n    this._maxColors = maxColors;\n    this.uniforms = this.resources.multiColorReplaceUniforms.uniforms;\n    this.replacements = options.replacements;\n  }\n  /**\n   * The collection of replacement items. Each item is color-pair\n   * (an array length is 2). In the pair, the first value is original color , the second value is target color\n   */\n  set replacements(replacements) {\n    const originals = this.uniforms.uOriginalColors;\n    const targets = this.uniforms.uTargetColors;\n    const colorCount = replacements.length;\n    const color = new Color();\n    if (colorCount > this._maxColors) {\n      throw new Error(`Length of replacements (${colorCount}) exceeds the maximum colors length (${this._maxColors})`);\n    }\n    originals[colorCount * 3] = -1;\n    let r;\n    let g;\n    let b;\n    for (let i = 0; i < colorCount; i++) {\n      const pair = replacements[i];\n      color.setValue(pair[0]);\n      [r, g, b] = color.toArray();\n      originals[i * 3] = r;\n      originals[i * 3 + 1] = g;\n      originals[i * 3 + 2] = b;\n      color.setValue(pair[1]);\n      [r, g, b] = color.toArray();\n      targets[i * 3] = r;\n      targets[i * 3 + 1] = g;\n      targets[i * 3 + 2] = b;\n    }\n    this._replacements = replacements;\n  }\n  get replacements() {\n    return this._replacements;\n  }\n  /**\n    * Should be called after changing any of the contents of the replacements.\n    * This is a convenience method for resetting the `replacements`.\n    * @todo implement nested proxy to remove the need for this function\n    */\n  refresh() {\n    this.replacements = this._replacements;\n  }\n  /**\n    * The maximum number of color replacements supported by this filter. Can be changed\n    * _only_ during construction.\n    * @readonly\n    */\n  get maxColors() {\n    return this._maxColors;\n  }\n  /**\n    * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n    * @default 0.05\n    */\n  get tolerance() {\n    return this.uniforms.uTolerance;\n  }\n  set tolerance(value) {\n    this.uniforms.uTolerance = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n   * @default 0.05\n   */\n  set epsilon(value) {\n    deprecation(\"6.0.0\", \"MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead\");\n    this.tolerance = value;\n  }\n  get epsilon() {\n    deprecation(\"6.0.0\", \"MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead\");\n    return this.tolerance;\n  }\n};\n/** Default values for options. */\n__publicField(_MultiColorReplaceFilter, \"DEFAULT_OPTIONS\", {\n  replacements: [[16711680, 255]],\n  tolerance: 0.05,\n  maxColors: void 0\n});\nlet MultiColorReplaceFilter = _MultiColorReplaceFilter;\n\nexport { MultiColorReplaceFilter };\n//# sourceMappingURL=MultiColorReplaceFilter.mjs.map\n","var source = \"struct MultiColorReplaceUniforms {\\n  uOriginalColors: array<vec3<f32>, MAX_COLORS>,\\n  uTargetColors: array<vec3<f32>, MAX_COLORS>,\\n  uTolerance:f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;\\n  let uTargetColors = multiColorReplaceUniforms.uTargetColors;\\n  let uTolerance = multiColorReplaceUniforms.uTolerance;\\n\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let alpha: f32 = color.a;\\n\\n  if (alpha > 0.0001)\\n  {\\n    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;\\n\\n    for(var i: i32 = 0; i < MAX_COLORS; i += 1)\\n    {\\n      let origColor: vec3<f32> = uOriginalColors[i];\\n      if (origColor.r < 0.0)\\n      {\\n        break;\\n      }\\n      let colorDiff: vec3<f32> = origColor - modColor;\\n      \\n      if (length(colorDiff) < uTolerance)\\n      {\\n        let targetColor: vec3<f32> = uTargetColors[i];\\n        color = vec4((targetColor + colorDiff) * alpha, alpha);\\n        return color;\\n      }\\n    }\\n  }\\n\\n  return color;\\n}\\n\\nconst MAX_COLORS: i32 = ${MAX_COLORS};\";\n\nexport { source as default };\n//# sourceMappingURL=multi-color-replace2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uSepia;\\nuniform vec2 uNoise;\\nuniform vec3 uScratch;\\nuniform vec3 uVignetting;\\nuniform float uSeed;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nconst float SQRT_2 = 1.414213;\\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvec3 Overlay(vec3 src, vec3 dst)\\n{\\n    // if (dst <= 0.5) then: 2 * src * dst\\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\\n}\\n\\n\\nvoid main()\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n    vec3 color = finalColor.rgb;\\n\\n    if (uSepia > 0.0)\\n    {\\n        float gray = (color.x + color.y + color.z) / 3.0;\\n        vec3 grayscale = vec3(gray);\\n\\n        color = Overlay(SEPIA_RGB, grayscale);\\n\\n        color = grayscale + uSepia * (color - grayscale);\\n    }\\n\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;\\n\\n    float vignette = uVignetting[0];\\n    float vignetteAlpha = uVignetting[1];\\n    float vignetteBlur = uVignetting[2];\\n\\n    if (vignette > 0.0)\\n    {\\n        float outter = SQRT_2 - vignette * SQRT_2;\\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\\n        dir.y *= uDimensions.y / uDimensions.x;\\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);\\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);\\n    }\\n\\n    float scratch = uScratch[0];\\n    float scratchDensity = uScratch[1];\\n    float scratchWidth = uScratch[2];\\n\\n    if (scratchDensity > uSeed && scratch != 0.0)\\n    {\\n        float phase = uSeed * 256.0;\\n        float s = mod(floor(phase), 2.0);\\n        float dist = 1.0 / scratchDensity;\\n        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));\\n        if (d < uSeed * 0.6 + 0.4)\\n        {\\n            highp float period = scratchDensity * 10.0;\\n\\n            float xx = coord.x * period + phase;\\n            float aa = abs(mod(xx, 0.5) * 4.0);\\n            float bb = mod(floor(xx / 0.5), 2.0);\\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\\n\\n            float kk = 2.0 * period;\\n            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);\\n            float dh = dw * kk;\\n\\n            float tine = (yy - (2.0 - dh));\\n\\n            if (tine > 0.0) {\\n                float _sign = sign(scratch);\\n\\n                tine = s * tine / period + scratch + 0.1;\\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\\n\\n                color.rgb *= tine;\\n            }\\n        }\\n    }\\n\\n    float noise = uNoise[0];\\n    float noiseSize = uNoise[1];\\n\\n    if (noise > 0.0 && noiseSize > 0.0)\\n    {\\n        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);\\n        // float _noise = snoise(d) * 0.5;\\n        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;\\n        color += _noise * noise;\\n    }\\n\\n    finalColor.rgb = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=old-film.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './old-film.mjs';\nimport source from './old-film2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _OldFilmFilter = class _OldFilmFilter extends Filter {\n  /**\n   * @param options - Options for the OldFilmFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._OldFilmFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"old-film-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        oldFilmUniforms: {\n          uSepia: { value: options.sepia, type: \"f32\" },\n          uNoise: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uScratch: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uVignetting: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uSeed: { value: options.seed, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    __publicField(this, \"seed\");\n    this.uniforms = this.resources.oldFilmUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    this.uniforms.uSeed = this.seed;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The amount of saturation of sepia effect,\n   * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect\n   * @default 0.3\n   */\n  get sepia() {\n    return this.uniforms.uSepia;\n  }\n  set sepia(value) {\n    this.uniforms.uSepia = value;\n  }\n  /**\n   * Opacity/intensity of the noise effect between `0` and `1`\n   * @default 0.3\n   */\n  get noise() {\n    return this.uniforms.uNoise[0];\n  }\n  set noise(value) {\n    this.uniforms.uNoise[0] = value;\n  }\n  /**\n   * The size of the noise particles\n   * @default 1\n   */\n  get noiseSize() {\n    return this.uniforms.uNoise[1];\n  }\n  set noiseSize(value) {\n    this.uniforms.uNoise[1] = value;\n  }\n  /**\n   * How often scratches appear\n   * @default 0.5\n   */\n  get scratch() {\n    return this.uniforms.uScratch[0];\n  }\n  set scratch(value) {\n    this.uniforms.uScratch[0] = value;\n  }\n  /**\n   * The density of the number of scratches\n   * @default 0.3\n   */\n  get scratchDensity() {\n    return this.uniforms.uScratch[1];\n  }\n  set scratchDensity(value) {\n    this.uniforms.uScratch[1] = value;\n  }\n  /**\n   * The width of the scratches\n   * @default 1\n   */\n  get scratchWidth() {\n    return this.uniforms.uScratch[2];\n  }\n  set scratchWidth(value) {\n    this.uniforms.uScratch[2] = value;\n  }\n  /**\n   * The radius of the vignette effect, smaller values produces a smaller vignette\n   * @default 0.3\n   */\n  get vignetting() {\n    return this.uniforms.uVignetting[0];\n  }\n  set vignetting(value) {\n    this.uniforms.uVignetting[0] = value;\n  }\n  /**\n   * Amount of opacity on the vignette\n   * @default 1\n   */\n  get vignettingAlpha() {\n    return this.uniforms.uVignetting[1];\n  }\n  set vignettingAlpha(value) {\n    this.uniforms.uVignetting[1] = value;\n  }\n  /**\n   * Blur intensity of the vignette\n   * @default 1\n   */\n  get vignettingBlur() {\n    return this.uniforms.uVignetting[2];\n  }\n  set vignettingBlur(value) {\n    this.uniforms.uVignetting[2] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_OldFilmFilter, \"DEFAULT_OPTIONS\", {\n  sepia: 0.3,\n  noise: 0.3,\n  noiseSize: 1,\n  scratch: 0.5,\n  scratchDensity: 0.3,\n  scratchWidth: 1,\n  vignetting: 0.3,\n  vignettingAlpha: 1,\n  vignettingBlur: 0.3,\n  seed: 0\n});\nlet OldFilmFilter = _OldFilmFilter;\n\nexport { OldFilmFilter };\n//# sourceMappingURL=OldFilmFilter.mjs.map\n","var source = \"struct OldFilmUniforms {\\n    uSepia: f32,\\n    uNoise: vec2<f32>,\\n    uScratch: vec3<f32>,\\n    uVignetting: vec3<f32>,\\n    uSeed: f32,\\n    uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  if (oldFilmUniforms.uSepia > 0.)\\n  {\\n    color = vec4<f32>(sepia(color.rgb), color.a);\\n  }\\n\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;\\n\\n  if (oldFilmUniforms.uVignetting[0] > 0.)\\n  {\\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\\n  }\\n\\n  let uScratch = oldFilmUniforms.uScratch; \\n\\n  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)\\n  {\\n    color = vec4<f32>(scratch(color.rgb, coord), color.a);\\n  }\\n\\n  let uNoise = oldFilmUniforms.uNoise;\\n\\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n  {\\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\\n  }\\n\\n  return color;\\n}\\n\\nconst SQRT_2: f32 = 1.414213;\\nconst SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn rand(co: vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>\\n{\\n    // if (dst <= 0.5) then: 2 * src * dst\\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\\n\\n    return vec3<f32>(\\n      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), \\n      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),\\n      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))\\n    );\\n}\\n\\nfn sepia(co: vec3<f32>) -> vec3<f32>\\n{\\n  let gray: f32 = (co.x + co.y + co.z) / 3.0;\\n  let grayscale: vec3<f32> = vec3<f32>(gray);\\n  let color = overlay(SEPIA_RGB, grayscale);\\n  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);\\n}\\n\\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\\n{\\n  let uVignetting = oldFilmUniforms.uVignetting;\\n  let uDimensions = oldFilmUniforms.uDimensions;\\n  \\n  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;\\n  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);\\n  dir.y *= uDimensions.y / uDimensions.x;\\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);\\n  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);\\n}\\n\\nfn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\\n{\\n  var color = co;\\n  let uScratch = oldFilmUniforms.uScratch;\\n  let uSeed = oldFilmUniforms.uSeed;\\n  let uDimensions = oldFilmUniforms.uDimensions;\\n\\n  let phase: f32 = uSeed * 256.0;\\n  let s: f32 = modulo(floor(phase), 2.0);\\n  let dist: f32 = 1.0 / uScratch[1];\\n  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));\\n\\n  if (d < uSeed * 0.6 + 0.4)\\n  {\\n    let period: f32 = uScratch[1] * 10.0;\\n\\n    let xx: f32 = coord.x * period + phase;\\n    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);\\n    let bb: f32 = modulo(floor(xx / 0.5), 2.0);\\n    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);\\n\\n    let kk: f32 = 2.0 * period;\\n    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);\\n    let dh: f32 = dw * kk;\\n\\n    var tine: f32 = (yy - (2.0 - dh));\\n\\n    if (tine > 0.0) {\\n        let _sign: f32 = sign(uScratch[0]);\\n\\n        tine = s * tine / period + uScratch[0] + 0.1;\\n        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\\n\\n        color *= tine;\\n    }\\n  }\\n\\n  return color;\\n}\\n\\nfn noise(coord: vec2<f32>) -> f32\\n{\\n  let uNoise = oldFilmUniforms.uNoise;\\n  let uSeed = oldFilmUniforms.uSeed;\\n\\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=old-film2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uThickness;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\nuniform float uKnockout;\\n\\nuniform vec4 uInputClamp;\\n\\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\\nconst float ANGLE_STEP = ${ANGLE_STEP};\\n\\nfloat outlineMaxAlphaAtPos(vec2 pos) {\\n    if (uThickness.x == 0. || uThickness.y == 0.) {\\n        return 0.;\\n    }\\n\\n    vec4 displacedColor;\\n    vec2 displacedPos;\\n    float maxAlpha = 0.;\\n\\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\\n        maxAlpha = max(maxAlpha, displacedColor.a);\\n    }\\n\\n    return maxAlpha;\\n}\\n\\nvoid main(void) {\\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\\n    finalColor = contentColor + outlineColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=outline.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './outline.mjs';\nimport source from './outline2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _OutlineFilter = class _OutlineFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }\");\n      options = { thickness: options };\n      if (args[1] !== void 0)\n        options.color = args[1];\n      if (args[2] !== void 0)\n        options.quality = args[2];\n      if (args[3] !== void 0)\n        options.alpha = args[3];\n      if (args[4] !== void 0)\n        options.knockout = args[4];\n    }\n    options = { ..._OutlineFilter.DEFAULT_OPTIONS, ...options };\n    const quality = options.quality ?? 0.1;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/\\$\\{ANGLE_STEP\\}/, _OutlineFilter.getAngleStep(quality).toFixed(7)),\n      name: \"outline-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        outlineUniforms: {\n          uThickness: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uAngleStep: { value: 0, type: \"f32\" },\n          uKnockout: { value: options.knockout ? 1 : 0, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_thickness\");\n    __publicField(this, \"_quality\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.outlineUniforms.uniforms;\n    this.uniforms.uAngleStep = _OutlineFilter.getAngleStep(quality);\n    this._color = new Color();\n    this.color = options.color ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uThickness[0] = this.thickness / input.source.width;\n    this.uniforms.uThickness[1] = this.thickness / input.source.height;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the angleStep by quality\n   * @param quality\n   */\n  static getAngleStep(quality) {\n    return parseFloat((Math.PI * 2 / Math.max(\n      quality * _OutlineFilter.MAX_SAMPLES,\n      _OutlineFilter.MIN_SAMPLES\n    )).toFixed(7));\n  }\n  /**\n   * The thickness of the outline\n   * @default 1\n   */\n  get thickness() {\n    return this._thickness;\n  }\n  set thickness(value) {\n    this._thickness = this.padding = value;\n  }\n  /**\n   * The color value of the ambient color\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n   * The quality of the outline from `0` to `1`.\n   * Using a higher quality setting will result in more accuracy but slower performance\n   * @default 0.1\n   */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.uniforms.uAngleStep = _OutlineFilter.getAngleStep(value);\n  }\n  /**\n   * Whether to only render outline, not the contents.\n   * @default false\n   */\n  get knockout() {\n    return this.uniforms.uKnockout === 1;\n  }\n  set knockout(value) {\n    this.uniforms.uKnockout = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_OutlineFilter, \"DEFAULT_OPTIONS\", {\n  thickness: 1,\n  color: 0,\n  alpha: 1,\n  quality: 0.1,\n  knockout: false\n});\n/** The minimum number of samples for rendering outline. */\n__publicField(_OutlineFilter, \"MIN_SAMPLES\", 1);\n/** The maximum number of samples for rendering outline. */\n__publicField(_OutlineFilter, \"MAX_SAMPLES\", 100);\nlet OutlineFilter = _OutlineFilter;\n\nexport { OutlineFilter };\n//# sourceMappingURL=OutlineFilter.mjs.map\n","var source = \"struct OutlineUniforms {\\n  uThickness:vec2<f32>,\\n  uColor:vec3<f32>,\\n  uAlpha:f32,\\n  uAngleStep:f32,\\n  uKnockout:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\\n  \\n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\\n  \\n  return contentColor + outlineColor;\\n}\\n\\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\\n  let thickness = outlineUniforms.uThickness;\\n\\n  if (thickness.x == 0. || thickness.y == 0.) {\\n    return 0.;\\n  }\\n  \\n  let angleStep = outlineUniforms.uAngleStep;\\n\\n  var displacedColor: vec4<f32>;\\n  var displacedPos: vec2<f32>;\\n\\n  var maxAlpha: f32 = 0.;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\\n  {\\n    displaced.x = uv.x + thickness.x * cos(angle);\\n    displaced.y = uv.y + thickness.y * sin(angle);\\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n    maxAlpha = max(maxAlpha, curColor.a);\\n  }\\n\\n  return maxAlpha;\\n}\\n\\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;\";\n\nexport { source as default };\n//# sourceMappingURL=outline2.mjs.map\n","import { Filter, GpuProgram, GlProgram, Point } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './pixelate2.mjs';\nimport source from './pixelate.mjs';\n\nclass PixelateFilter extends Filter {\n  /**\n   * @param {Point|Array<number>|number} [size=10] - Either the width/height of the size of the pixels, or square size\n   */\n  constructor(size = 10) {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"pixelate-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        pixelateUniforms: {\n          uSize: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    this.size = size;\n  }\n  /**\n   * The size of the pixels\n   * @default [10,10]\n   */\n  get size() {\n    return this.resources.pixelateUniforms.uniforms.uSize;\n  }\n  set size(value) {\n    if (value instanceof Point) {\n      this.sizeX = value.x;\n      this.sizeY = value.y;\n    } else if (Array.isArray(value)) {\n      this.resources.pixelateUniforms.uniforms.uSize = value;\n    } else {\n      this.sizeX = this.sizeY = value;\n    }\n  }\n  /**\n  * The size of the pixels on the `x` axis\n  * @default 10\n  */\n  get sizeX() {\n    return this.resources.pixelateUniforms.uniforms.uSize[0];\n  }\n  set sizeX(value) {\n    this.resources.pixelateUniforms.uniforms.uSize[0] = value;\n  }\n  /**\n  * The size of the pixels on the `y` axis\n  * @default 10\n  */\n  get sizeY() {\n    return this.resources.pixelateUniforms.uniforms.uSize[1];\n  }\n  set sizeY(value) {\n    this.resources.pixelateUniforms.uniforms.uSize[1] = value;\n  }\n}\n\nexport { PixelateFilter };\n//# sourceMappingURL=PixelateFilter.mjs.map\n","var source = \"struct PixelateUniforms {\\n  uSize:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> pixelateUniforms : PixelateUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let pixelSize: vec2<f32> = pixelateUniforms.uSize;\\n  let coord: vec2<f32> = mapCoord(uv);\\n\\n  var pixCoord: vec2<f32> = pixelate(coord, pixelSize);\\n  pixCoord = unmapCoord(pixCoord);\\n\\n  return textureSample(uTexture, uSampler, pixCoord);\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord *= gfu.uInputSize.xy;\\n  mappedCoord += gfu.uOutputFrame.xy;\\n  return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord -= gfu.uOutputFrame.xy;\\n  mappedCoord /= gfu.uInputSize.xy;\\n  return mappedCoord;\\n}\\n\\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n  return floor( coord / size ) * size;\\n}\\n\\n\";\n\nexport { source as default };\n//# sourceMappingURL=pixelate.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform vec2 uSize;\\nuniform sampler2D uTexture;\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 pixelate(vec2 coord, vec2 uSize)\\n{\\n\\treturn floor( coord / uSize ) * uSize;\\n}\\n\\nvoid main(void)\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n    coord = pixelate(coord, uSize);\\n    coord = unmapCoord(coord);\\n    finalColor = texture(uTexture, coord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=pixelate2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uRadian;\\nuniform vec2 uCenter;\\nuniform float uRadius;\\nuniform int uKernelSize;\\n\\nuniform vec4 uInputSize;\\n\\nconst int MAX_KERNEL_SIZE = 2048;\\n\\nvoid main(void)\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    if (uKernelSize == 0)\\n    {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    float aspect = uInputSize.y / uInputSize.x;\\n    vec2 center = uCenter.xy / uInputSize.xy;\\n    float gradient = uRadius / uInputSize.x * 0.3;\\n    float radius = uRadius / uInputSize.x - gradient * 0.5;\\n    int k = uKernelSize - 1;\\n\\n    vec2 coord = vTextureCoord;\\n    vec2 dir = vec2(center - coord);\\n    float dist = length(vec2(dir.x, dir.y * aspect));\\n\\n    float radianStep = uRadian;\\n    if (radius >= 0.0 && dist > radius) {\\n        float delta = dist - radius;\\n        float gap = gradient;\\n        float scale = 1.0 - abs(delta / gap);\\n        if (scale <= 0.0) {\\n            finalColor = color;\\n            return;\\n        }\\n        radianStep *= scale;\\n    }\\n    radianStep /= float(k);\\n\\n    float s = sin(radianStep);\\n    float c = cos(radianStep);\\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\\n\\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\\n        if (i == k) {\\n            break;\\n        }\\n\\n        coord -= center;\\n        coord.y *= aspect;\\n        coord = rotationMatrix * coord;\\n        coord.y /= aspect;\\n        coord += center;\\n\\n        vec4 sample = texture(uTexture, coord);\\n\\n        // switch to pre-multiplied alpha to correctly blur transparent images\\n        // sample.rgb *= sample.a;\\n\\n        color += sample;\\n    }\\n\\n    finalColor = color / float(uKernelSize);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=radial-blur.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './radial-blur.mjs';\nimport source from './radial-blur2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _RadialBlurFilter = class _RadialBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }\");\n      options = { angle: options };\n      if (args[1]) {\n        const x = \"x\" in args[1] ? args[1].x : args[1][0];\n        const y = \"y\" in args[1] ? args[1].y : args[1][1];\n        options.center = { x, y };\n      }\n      if (args[2])\n        options.kernelSize = args[2];\n      if (args[3])\n        options.radius = args[3];\n    }\n    options = { ..._RadialBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"radial-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        radialBlurUniforms: {\n          uRadian: { value: 0, type: \"f32\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uKernelSize: { value: options.kernelSize, type: \"i32\" },\n          uRadius: { value: options.radius, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_angle\");\n    __publicField(this, \"_kernelSize\");\n    this.uniforms = this.resources.radialBlurUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  _updateKernelSize() {\n    this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;\n  }\n  /**\n   * Sets the angle in degrees of the motion for blur effect.\n   * @default 0\n   */\n  get angle() {\n    return this._angle;\n  }\n  set angle(value) {\n    this._angle = value;\n    this.uniforms.uRadian = value * Math.PI / 180;\n    this._updateKernelSize();\n  }\n  /**\n   * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n   * once defined in the constructor\n   * @default {x:0,y:0}\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.center.x;\n  }\n  set centerX(value) {\n    this.center.x = value;\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.center.y;\n  }\n  set centerY(value) {\n    this.center.y = value;\n  }\n  /**\n   * The kernelSize of the blur filter. Must be odd number >= 3\n   * @default 5\n   */\n  get kernelSize() {\n    return this._kernelSize;\n  }\n  set kernelSize(value) {\n    this._kernelSize = value;\n    this._updateKernelSize();\n  }\n  /**\n   * The maximum size of the blur radius, less than `0` equates to infinity\n   * @default -1\n   */\n  get radius() {\n    return this.uniforms.uRadius;\n  }\n  set radius(value) {\n    this.uniforms.uRadius = value < 0 || value === Infinity ? -1 : value;\n  }\n};\n/** Default values for options. */\n__publicField(_RadialBlurFilter, \"DEFAULT_OPTIONS\", {\n  angle: 0,\n  center: { x: 0, y: 0 },\n  kernelSize: 5,\n  radius: -1\n});\nlet RadialBlurFilter = _RadialBlurFilter;\n\nexport { RadialBlurFilter };\n//# sourceMappingURL=RadialBlurFilter.mjs.map\n","var source = \"struct RadialBlurUniforms {\\n  uRadian: f32,\\n  uCenter: vec2<f32>,\\n  uKernelSize: f32,\\n  uRadius: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uRadian = radialBlurUniforms.uRadian;\\n  let uCenter = radialBlurUniforms.uCenter;\\n  let uKernelSize = radialBlurUniforms.uKernelSize;\\n  let uRadius = radialBlurUniforms.uRadius;\\n  \\n  var returnColorOnly = false;\\n\\n  if (uKernelSize == 0)\\n  {\\n    returnColorOnly = true;\\n  }\\n\\n  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;\\n  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;\\n  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;\\n  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;\\n  let k: i32 = i32(uKernelSize - 1);\\n\\n  var coord: vec2<f32> = uv;\\n  let dir: vec2<f32> = vec2<f32>(center - coord);\\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));\\n\\n  var radianStep: f32 = uRadian;\\n  \\n  if (radius >= 0.0 && dist > radius)\\n  {\\n    let delta: f32 = dist - radius;\\n    let gap: f32 = gradient;\\n    let scale: f32 = 1.0 - abs(delta / gap);\\n    if (scale <= 0.0) {\\n      returnColorOnly = true;\\n    }\\n    radianStep *= scale;\\n  }\\n\\n  radianStep /= f32(k);\\n\\n  let s: f32 = sin(radianStep);\\n  let c: f32 = cos(radianStep);\\n  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));\\n  \\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let baseColor = vec4<f32>(color);\\n\\n  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);\\n\\n  for(var i: i32 = 0; i < minK; i += 1) \\n  {\\n    coord -= center;\\n    coord.y *= aspect;\\n    coord = rotationMatrix * coord;\\n    coord.y /= aspect;\\n    coord += center;\\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);\\n    // switch to pre-multiplied alpha to correctly blur transparent images\\n    // sample.rgb *= sample.a;\\n    color += sample;\\n  }\\n\\n  return select(color / f32(uKernelSize), baseColor, returnColorOnly);\\n}\\n\\nconst MAX_KERNEL_SIZE: i32 = 2048;\";\n\nexport { source as default };\n//# sourceMappingURL=radial-blur2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uMirror;\\nuniform float uBoundary;\\nuniform vec2 uAmplitude;\\nuniform vec2 uWavelength;\\nuniform vec2 uAlpha;\\nuniform float uTime;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main(void)\\n{\\n    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\\n    vec2 coord = pixelCoord / uDimensions;\\n\\n    if (coord.y < uBoundary) {\\n        finalColor = texture(uTexture, vTextureCoord);\\n        return;\\n    }\\n\\n    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\\n    float areaY = uBoundary * uDimensions.y / uInputSize.y;\\n    float v = areaY + areaY - vTextureCoord.y;\\n    float y = uMirror > 0.5 ? v : vTextureCoord.y;\\n\\n    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;\\n    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;\\n    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;\\n\\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;\\n    x = clamp(x, uInputClamp.x, uInputClamp.z);\\n\\n    vec4 color = texture(uTexture, vec2(x, y));\\n\\n    finalColor = color * _alpha;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=reflection.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './reflection.mjs';\nimport source from './reflection2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ReflectionFilter = class _ReflectionFilter extends Filter {\n  /**\n   * @param options - Options for the ReflectionFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._ReflectionFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"reflection-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        reflectionUniforms: {\n          uMirror: { value: options.mirror ? 1 : 0, type: \"f32\" },\n          uBoundary: { value: options.boundary, type: \"f32\" },\n          uAmplitude: { value: options.amplitude, type: \"vec2<f32>\" },\n          uWavelength: { value: options.waveLength, type: \"vec2<f32>\" },\n          uAlpha: { value: options.alpha, type: \"vec2<f32>\" },\n          uTime: { value: options.time, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * Time for animating position of waves\n     * @default 0\n     */\n    __publicField(this, \"time\", 0);\n    this.uniforms = this.resources.reflectionUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * `true` to reflect the image, `false` for waves-only\n   * @default true\n   */\n  get mirror() {\n    return this.uniforms.uMirror > 0.5;\n  }\n  set mirror(value) {\n    this.uniforms.uMirror = value ? 1 : 0;\n  }\n  /**\n   * Vertical position of the reflection point, default is 50% (middle)\n   * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.\n   * @default 0.5\n   */\n  get boundary() {\n    return this.uniforms.uBoundary;\n  }\n  set boundary(value) {\n    this.uniforms.uBoundary = value;\n  }\n  /**\n   * Starting and ending amplitude of waves\n   * @default [0,20]\n   */\n  get amplitude() {\n    return Array.from(this.uniforms.uAmplitude);\n  }\n  set amplitude(value) {\n    this.uniforms.uAmplitude[0] = value[0];\n    this.uniforms.uAmplitude[1] = value[1];\n  }\n  /**\n   * Starting amplitude of waves\n   * @default 0\n   */\n  get amplitudeStart() {\n    return this.uniforms.uAmplitude[0];\n  }\n  set amplitudeStart(value) {\n    this.uniforms.uAmplitude[0] = value;\n  }\n  /**\n   * Starting amplitude of waves\n   * @default 20\n   */\n  get amplitudeEnd() {\n    return this.uniforms.uAmplitude[1];\n  }\n  set amplitudeEnd(value) {\n    this.uniforms.uAmplitude[1] = value;\n  }\n  /**\n   * Starting and ending length of waves\n   * @default [30,100]\n   */\n  get waveLength() {\n    return Array.from(this.uniforms.uWavelength);\n  }\n  set waveLength(value) {\n    this.uniforms.uWavelength[0] = value[0];\n    this.uniforms.uWavelength[1] = value[1];\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 30\n   */\n  get wavelengthStart() {\n    return this.uniforms.uWavelength[0];\n  }\n  set wavelengthStart(value) {\n    this.uniforms.uWavelength[0] = value;\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 100\n   */\n  get wavelengthEnd() {\n    return this.uniforms.uWavelength[1];\n  }\n  set wavelengthEnd(value) {\n    this.uniforms.uWavelength[1] = value;\n  }\n  /**\n   * Starting and ending alpha values\n   * @default [1,1]\n   */\n  get alpha() {\n    return Array.from(this.uniforms.uAlpha);\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha[0] = value[0];\n    this.uniforms.uAlpha[1] = value[1];\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 1\n   */\n  get alphaStart() {\n    return this.uniforms.uAlpha[0];\n  }\n  set alphaStart(value) {\n    this.uniforms.uAlpha[0] = value;\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 1\n   */\n  get alphaEnd() {\n    return this.uniforms.uAlpha[1];\n  }\n  set alphaEnd(value) {\n    this.uniforms.uAlpha[1] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_ReflectionFilter, \"DEFAULT_OPTIONS\", {\n  mirror: true,\n  boundary: 0.5,\n  amplitude: [0, 20],\n  waveLength: [30, 100],\n  alpha: [1, 1],\n  time: 0\n});\nlet ReflectionFilter = _ReflectionFilter;\n\nexport { ReflectionFilter };\n//# sourceMappingURL=ReflectionFilter.mjs.map\n","var source = \"struct ReflectionUniforms {\\n  uMirror: f32,\\n  uBoundary: f32,\\n  uAmplitude: vec2<f32>,\\n  uWavelength: vec2<f32>,\\n  uAlpha: vec2<f32>,\\n  uTime: f32,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\\n  let uTime: f32 = reflectionUniforms.uTime;\\n\\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\\n  let coord: vec2<f32> = pixelCoord /uDimensions;\\n  var returnColorOnly: bool = false;\\n\\n  if (coord.y < uBoundary) {\\n    returnColorOnly = true;\\n  }\\n\\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\\n  let v: f32 = areaY + areaY - uv.y;\\n  let y: f32 = select(uv.y, v, uMirror);\\n\\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\\n\\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\\n  \\n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\\n}\\n\\nfn rand(co: vec2<f32>) -> f32 \\n{\\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=reflection2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uInputSize;\\nuniform vec2 uRed;\\nuniform vec2 uGreen;\\nuniform vec2 uBlue;\\n\\nvoid main(void)\\n{\\n   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;\\n   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;\\n   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;\\n   float a = texture(uTexture, vTextureCoord).a;\\n   finalColor = vec4(r, g, b, a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=rgb-split2.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './rgb-split2.mjs';\nimport source from './rgb-split.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _RGBSplitFilter = class _RGBSplitFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options) || \"x\" in options && \"y\" in options) {\n      deprecation(\"6.0.0\", \"RGBSplitFilter constructor params are now options object. See params: { red, green, blue }\");\n      options = { red: options };\n      if (args[1] !== void 0)\n        options.green = args[1];\n      if (args[2] !== void 0)\n        options.blue = args[2];\n    }\n    options = { ..._RGBSplitFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"rgb-split-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        rgbSplitUniforms: {\n          uRed: { value: options.red, type: \"vec2<f32>\" },\n          uGreen: { value: options.green, type: \"vec2<f32>\" },\n          uBlue: { value: options.blue, type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.rgbSplitUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Red channel offset.\n   * @default {x:-10,y:0}\n   */\n  get red() {\n    return this.uniforms.uRed;\n  }\n  set red(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uRed = value;\n  }\n  /**\n   * Amount of x-axis offset for the red channel.\n   * @default -10\n   */\n  get redX() {\n    return this.red.x;\n  }\n  set redX(value) {\n    this.red.x = value;\n  }\n  /**\n   * Amount of y-axis offset for the red channel.\n   * @default 0\n   */\n  get redY() {\n    return this.red.y;\n  }\n  set redY(value) {\n    this.red.y = value;\n  }\n  /**\n   * Green channel offset.\n   * @default {x:0,y:10}\n   */\n  get green() {\n    return this.uniforms.uGreen;\n  }\n  set green(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uGreen = value;\n  }\n  /**\n   * Amount of x-axis offset for the green channel.\n   * @default 0\n   */\n  get greenX() {\n    return this.green.x;\n  }\n  set greenX(value) {\n    this.green.x = value;\n  }\n  /**\n   * Amount of y-axis offset for the green channel.\n   * @default 10\n   */\n  get greenY() {\n    return this.green.y;\n  }\n  set greenY(value) {\n    this.green.y = value;\n  }\n  /**\n   * Blue channel offset.\n   * @default {x:0,y:0}\n   */\n  get blue() {\n    return this.uniforms.uBlue;\n  }\n  set blue(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uBlue = value;\n  }\n  /**\n   * Amount of x-axis offset for the blue channel.\n   * @default 0\n   */\n  get blueX() {\n    return this.blue.x;\n  }\n  set blueX(value) {\n    this.blue.x = value;\n  }\n  /**\n   * Amount of y-axis offset for the blue channel.\n   * @default 0\n   */\n  get blueY() {\n    return this.blue.y;\n  }\n  set blueY(value) {\n    this.blue.y = value;\n  }\n};\n/** Default values for options. */\n__publicField(_RGBSplitFilter, \"DEFAULT_OPTIONS\", {\n  red: { x: -10, y: 0 },\n  green: { x: 0, y: 10 },\n  blue: { x: 0, y: 0 }\n});\nlet RGBSplitFilter = _RGBSplitFilter;\n\nexport { RGBSplitFilter };\n//# sourceMappingURL=RGBSplitFilter.mjs.map\n","var source = \"struct RgbSplitUniforms {\\n    uRed: vec2<f32>,\\n    uGreen: vec2<f32>,\\n    uBlue: vec3<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;\\n    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;\\n    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;\\n    let a = textureSample(uTexture, uSampler, uv).a;\\n    return vec4<f32>(r, g, b, a);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=rgb-split.mjs.map\n","var fragment = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uCenter;\\nuniform float uTime;\\nuniform float uSpeed;\\nuniform vec4 uWave;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159;\\n\\nvoid main()\\n{\\n    float uAmplitude = uWave[0];\\n    float uWavelength = uWave[1];\\n    float uBrightness = uWave[2];\\n    float uRadius = uWave[3];\\n\\n    float halfWavelength = uWavelength * 0.5 / uInputSize.x;\\n    float maxRadius = uRadius / uInputSize.x;\\n    float currentRadius = uTime * uSpeed / uInputSize.x;\\n\\n    float fade = 1.0;\\n\\n    if (maxRadius > 0.0) {\\n        if (currentRadius > maxRadius) {\\n            finalColor = texture(uTexture, vTextureCoord);\\n            return;\\n        }\\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\\n    }\\n\\n    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);\\n    dir.y *= uInputSize.y / uInputSize.x;\\n    float dist = length(dir);\\n\\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\\n        finalColor = texture(uTexture, vTextureCoord);\\n        return;\\n    }\\n\\n    vec2 diffUV = normalize(dir);\\n\\n    float diff = (dist - currentRadius) / halfWavelength;\\n\\n    float p = 1.0 - pow(abs(diff), 2.0);\\n\\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\\n    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\\n\\n    vec2 offset = diffUV * powDiff / uInputSize.xy;\\n\\n    // Do clamp :\\n    vec2 coord = vTextureCoord + offset;\\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    vec4 color = texture(uTexture, clampedCoord);\\n    if (coord != clampedCoord) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    // No clamp :\\n    // finalColor = texture(uTexture, vTextureCoord + offset);\\n\\n    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=shockwave2.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './shockwave2.mjs';\nimport source from './shockwave.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ShockwaveFilter = class _ShockwaveFilter extends Filter {\n  /** @ignore */\n  // eslint-disable-next-line max-len\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options) || \"x\" in options && \"y\" in options) {\n      deprecation(\"6.0.0\", \"ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }\");\n      options = { center: options, ...args[1] };\n      if (args[2] !== void 0)\n        options.time = args[2];\n    }\n    options = { ..._ShockwaveFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"shockwave-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        shockwaveUniforms: {\n          uTime: { value: options.time, type: \"f32\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uSpeed: { value: options.speed, type: \"f32\" },\n          uWave: { value: new Float32Array(4), type: \"vec4<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /** Sets the elapsed time of the shockwave. It could control the current size of shockwave. */\n    __publicField(this, \"time\");\n    this.time = 0;\n    this.uniforms = this.resources.shockwaveUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The `x` and `y` center coordinates to change the position of the center of the circle of effect.\n   * @default [0,0]\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.uniforms.uCenter.x;\n  }\n  set centerX(value) {\n    this.uniforms.uCenter.x = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `y` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.uniforms.uCenter.y;\n  }\n  set centerY(value) {\n    this.uniforms.uCenter.y = value;\n  }\n  /**\n   * The speed about the shockwave ripples out. The unit is `pixel-per-second`\n   * @default 500\n   */\n  get speed() {\n    return this.uniforms.uSpeed;\n  }\n  set speed(value) {\n    this.uniforms.uSpeed = value;\n  }\n  /**\n   * The amplitude of the shockwave\n   * @default 30\n   */\n  get amplitude() {\n    return this.uniforms.uWave[0];\n  }\n  set amplitude(value) {\n    this.uniforms.uWave[0] = value;\n  }\n  /**\n   * The wavelength of the shockwave\n   * @default 160\n   */\n  get wavelength() {\n    return this.uniforms.uWave[1];\n  }\n  set wavelength(value) {\n    this.uniforms.uWave[1] = value;\n  }\n  /**\n   * The brightness of the shockwave\n   * @default 1\n   */\n  get brightness() {\n    return this.uniforms.uWave[2];\n  }\n  set brightness(value) {\n    this.uniforms.uWave[2] = value;\n  }\n  /**\n   * The maximum radius of shockwave. less than `0` means the max is an infinite distance\n   * @default -1\n   */\n  get radius() {\n    return this.uniforms.uWave[3];\n  }\n  set radius(value) {\n    this.uniforms.uWave[3] = value;\n  }\n};\n/** Default shockwave filter options */\n__publicField(_ShockwaveFilter, \"DEFAULT_OPTIONS\", {\n  /** The `x` and `y` center coordinates to change the position of the center of the circle of effect. */\n  center: { x: 0, y: 0 },\n  /** The speed about the shockwave ripples out. The unit is `pixel-per-second` */\n  speed: 500,\n  /** The amplitude of the shockwave */\n  amplitude: 30,\n  /** The wavelength of the shockwave */\n  wavelength: 160,\n  /** The brightness of the shockwave */\n  brightness: 1,\n  /** The maximum radius of shockwave. less than `0` means the max is an infinite distance */\n  radius: -1\n});\nlet ShockwaveFilter = _ShockwaveFilter;\n\nexport { ShockwaveFilter };\n//# sourceMappingURL=ShockwaveFilter.mjs.map\n","var source = \"\\nstruct ShockWaveUniforms {\\n    uTime: f32,\\n    uOffset: vec2<f32>,\\n    uSpeed: f32,\\n    uWave: vec4<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    let uTime = shockwaveUniforms.uTime;\\n    let uOffset = shockwaveUniforms.uOffset;\\n    let uSpeed = shockwaveUniforms.uSpeed;\\n    let uAmplitude = shockwaveUniforms.uWave[0];\\n    let uWavelength = shockwaveUniforms.uWave[1];\\n    let uBrightness = shockwaveUniforms.uWave[2];\\n    let uRadius = shockwaveUniforms.uWave[3];\\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\\n    var fade: f32 = 1.0;\\n    var returnColorOnly: bool = false;\\n    \\n    if (maxRadius > 0.0) {\\n        if (currentRadius > maxRadius) {\\n            returnColorOnly = true;\\n        }\\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\\n    }\\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\\n\\n    let dist:f32 = length(dir);\\n\\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\\n        returnColorOnly = true;\\n    }\\n\\n    let diffUV: vec2<f32> = normalize(dir);\\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\\n    // Do clamp :\\n    let coord: vec2<f32> = uv + offset;\\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\\n\\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\\n    \\n    if (boolVec2(coord, clampedCoord)) \\n    {\\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n    // No clamp :\\n    var finalColor = clampedColor;\\n\\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\\n}\\n\\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\\n{\\n    if (x.x == y.x && x.y == y.y)\\n    {\\n        return true;\\n    }\\n    \\n    return false;\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\\n\";\n\nexport { source as default };\n//# sourceMappingURL=shockwave.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main() {\\n    vec4 diffuseColor = texture(uTexture, vTextureCoord);\\n    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;\\n    vec4 light = texture(uMapTexture, lightCoord);\\n    vec3 ambient = uColor.rgb * uAlpha;\\n    vec3 intensity = ambient + light.rgb;\\n    vec3 color = diffuseColor.rgb * intensity;\\n    finalColor = vec4(color, diffuseColor.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=simple-lightmap.mjs.map\n","import { Texture, Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './simple-lightmap.mjs';\nimport source from './simple-lightmap2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _SimpleLightmapFilter = class _SimpleLightmapFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Texture) {\n      deprecation(\"6.0.0\", \"SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }\");\n      options = { lightMap: options };\n      if (args[1] !== void 0)\n        options.color = args[1];\n      if (args[2] !== void 0)\n        options.alpha = args[2];\n    }\n    options = { ..._SimpleLightmapFilter.DEFAULT_OPTIONS, ...options };\n    if (!options.lightMap)\n      throw Error(\"No light map texture source was provided to SimpleLightmapFilter\");\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"simple-lightmap-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        simpleLightmapUniforms: {\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        },\n        uMapTexture: options.lightMap.source,\n        uMapSampler: options.lightMap.source.style\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    __publicField(this, \"_lightMap\");\n    this.uniforms = this.resources.simpleLightmapUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /** A sprite where your lightmap is rendered */\n  get lightMap() {\n    return this._lightMap;\n  }\n  set lightMap(value) {\n    this._lightMap = value;\n    this.resources.uMapTexture = value.source;\n    this.resources.uMapSampler = value.source.style;\n  }\n  /**\n   * The color value of the ambient color\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n};\n/** Default values for options. */\n__publicField(_SimpleLightmapFilter, \"DEFAULT_OPTIONS\", {\n  lightMap: Texture.WHITE,\n  color: 0,\n  alpha: 1\n});\nlet SimpleLightmapFilter = _SimpleLightmapFilter;\n\nexport { SimpleLightmapFilter };\n//# sourceMappingURL=SimpleLightmapFilter.mjs.map\n","var source = \"struct SimpleLightmapUniforms {\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n  let uColor = simpleLightmapUniforms.uColor;\\n  let uAlpha = simpleLightmapUniforms.uAlpha;\\n  let uDimensions = simpleLightmapUniforms.uDimensions;\\n\\n  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;\\n  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);\\n  let ambient: vec3<f32> = uColor * uAlpha;\\n  let intensity: vec3<f32> = ambient + light.rgb;\\n  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;\\n  return vec4<f32>(finalColor, diffuseColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=simple-lightmap2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\nuniform float uNoiseScale;\\nuniform float uOffsetX;\\nuniform float uOffsetY;\\nuniform float uOffsetZ;\\nuniform float uStep;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\n//Noise from: https://www.shadertoy.com/view/4sc3z2\\nconst vec3 MOD3 = vec3(.1031,.11369,.13787);\\nvec3 hash33(vec3 p3)\\n{\\n\\tp3 = fract(p3 * MOD3);\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\\n}\\n\\nfloat simplex_noise(vec3 p)\\n{\\n    const float K1 = 0.333333333;\\n    const float K2 = 0.166666667;\\n    \\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n    \\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n\\tvec3 i1 = e * (1.0 - e.zxy);\\n\\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n    \\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\\n    \\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\\n    \\n    return dot(vec4(31.316), n);\\n}\\n\\nvoid main(void)\\n{\\n    float noise = simplex_noise(\\n                    vec3(vTextureCoord*uNoiseScale+vec2(uOffsetX, uOffsetY), uOffsetZ)\\n                ) * 0.5 + 0.5;\\n\\n    noise += 2.0 * uStrength - 1.0;\\n    noise = clamp(noise, 0.0, 1.0);\\n\\n    if (uStep > 0.0) {  //step > 0.5\\n        noise = 1.0 - step(noise, uStep);\\n    }\\n\\n    finalColor = texture(uTexture, vTextureCoord) * noise;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=simplex.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './simplex.mjs';\nimport source from './simplex2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _SimplexNoiseFilter = class _SimplexNoiseFilter extends Filter {\n  /**\n   * @param options - Options for the SimplexNoise constructor.\n   */\n  constructor(options) {\n    options = { ..._SimplexNoiseFilter.defaults, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"simplex-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        simplexUniforms: {\n          uStrength: { value: options?.strength ?? 0, type: \"f32\" },\n          uNoiseScale: { value: options?.noiseScale ?? 0, type: \"f32\" },\n          uOffsetX: { value: options?.offsetX ?? 0, type: \"f32\" },\n          uOffsetY: { value: options?.offsetY ?? 0, type: \"f32\" },\n          uOffsetZ: { value: options?.offsetZ ?? 0, type: \"f32\" },\n          uStep: { value: options?.step ?? 0, type: \"f32\" }\n        }\n      }\n    });\n  }\n  /**\n   * Strength of the noise (color = (noiseMap + strength) * texture)\n   * @default 0.5\n   */\n  get strength() {\n    return this.resources.simplexUniforms.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.resources.simplexUniforms.uniforms.uStrength = value;\n  }\n  /**\n   * Noise map scale.\n   * @default 10\n   */\n  get noiseScale() {\n    return this.resources.simplexUniforms.uniforms.uNoiseScale;\n  }\n  set noiseScale(value) {\n    this.resources.simplexUniforms.uniforms.uNoiseScale = value;\n  }\n  /**\n   * Horizontal offset for the noise map.\n   * @default 0\n   */\n  get offsetX() {\n    return this.resources.simplexUniforms.uniforms.uOffsetX;\n  }\n  set offsetX(value) {\n    this.resources.simplexUniforms.uniforms.uOffsetX = value;\n  }\n  /**\n   * Vertical offset for the noise map.\n   * @default 0\n   */\n  get offsetY() {\n    return this.resources.simplexUniforms.uniforms.uOffsetY;\n  }\n  set offsetY(value) {\n    this.resources.simplexUniforms.uniforms.uOffsetY = value;\n  }\n  /**\n   * Depth offset for the noise map.\n   * @default 0\n   */\n  get offsetZ() {\n    return this.resources.simplexUniforms.uniforms.uOffsetZ;\n  }\n  set offsetZ(value) {\n    this.resources.simplexUniforms.uniforms.uOffsetZ = value;\n  }\n  /**\n   * The threshold used with the step function to create a blocky effect in the noise pattern.\n   * When this is greater than 0, the step function is used to compare the noise value to this threshold.\n   * @default -1\n   */\n  get step() {\n    return this.resources.simplexUniforms.uniforms.uStep;\n  }\n  set step(value) {\n    this.resources.simplexUniforms.uniforms.uStep = value;\n  }\n};\n/** Default constructor options. */\n__publicField(_SimplexNoiseFilter, \"defaults\", {\n  strength: 0.5,\n  noiseScale: 10,\n  offsetX: 0,\n  offsetY: 0,\n  offsetZ: 0,\n  step: -1\n});\nlet SimplexNoiseFilter = _SimplexNoiseFilter;\n\nexport { SimplexNoiseFilter };\n//# sourceMappingURL=SimplexNoiseFilter.mjs.map\n","var source = \"struct SimplexUniforms {\\n  uStrength:f32,\\n  uNoiseScale:f32,\\n  uOffsetX:f32,\\n  uOffsetY:f32,\\n  uOffsetZ:f32,\\n  uStep:f32\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> simplexUniforms : SimplexUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  var noise: f32 = simplex_noise(vec3<f32>(uv * simplexUniforms.uNoiseScale + vec2<f32>(simplexUniforms.uOffsetX, simplexUniforms.uOffsetY), simplexUniforms.uOffsetZ)) * 0.5 + 0.5;\\n\\tnoise = noise + (2. * simplexUniforms.uStrength - 1.);\\n\\tnoise = clamp(noise, 0.0, 1.0);\\n\\tif (simplexUniforms.uStep > 0.0) {\\n\\t\\tnoise = 1. - step(noise, simplexUniforms.uStep);\\n\\t}\\n\\treturn textureSample(uTexture, uSampler, uv) * noise;\\n}\\n\\nconst MOD3: vec3<f32> = vec3<f32>(0.1031, 0.11369, 0.13787);\\nfn hash33(p3: vec3<f32>) -> vec3<f32> {\\n\\tvar p3_var = p3;\\n\\tp3_var = fract(p3_var * MOD3);\\n\\tp3_var = p3_var + (dot(p3_var, p3_var.yxz + 19.19));\\n\\treturn -1. + 2. * fract(vec3<f32>((p3_var.x + p3_var.y) * p3_var.z, (p3_var.x + p3_var.z) * p3_var.y, (p3_var.y + p3_var.z) * p3_var.x));\\n} \\n\\nfn simplex_noise(p: vec3<f32>) -> f32 {\\n\\tlet K1: f32 = 0.33333334;\\n\\tlet K2: f32 = 0.16666667;\\n\\tlet i: vec3<f32> = floor(p + (p.x + p.y + p.z) * K1);\\n\\tlet d0: vec3<f32> = p - (i - (i.x + i.y + i.z) * K2);\\n\\tlet e: vec3<f32> = step(vec3<f32>(0.), d0 - d0.yzx);\\n\\tlet i1: vec3<f32> = e * (1. - e.zxy);\\n\\tlet i2: vec3<f32> = 1. - e.zxy * (1. - e);\\n\\tlet d1: vec3<f32> = d0 - (i1 - 1. * K2);\\n\\tlet d2: vec3<f32> = d0 - (i2 - 2. * K2);\\n\\tlet d3: vec3<f32> = d0 - (1. - 3. * K2);\\n\\tlet h: vec4<f32> = max(vec4<f32>(0.6) - vec4<f32>(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), vec4<f32>(0.0));\\n\\tlet n: vec4<f32> = h * h * h * h * vec4<f32>(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.)));\\n\\treturn dot(vec4<f32>(31.316), n);\\n} \";\n\nexport { source as default };\n//# sourceMappingURL=simplex2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uBlur;\\nuniform vec2 uStart;\\nuniform vec2 uEnd;\\nuniform vec2 uDelta;\\nuniform vec4 uInputSize;\\n\\nfloat random(vec3 scale, float seed)\\n{\\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\n}\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n    float total = 0.0;\\n\\n    float blur = uBlur[0];\\n    float gradientBlur = uBlur[1];\\n\\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\\n    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));\\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uInputSize.xy - uStart, normal)) / gradientBlur) * blur;\\n\\n    for (float t = -30.0; t <= 30.0; t++)\\n    {\\n        float percent = (t + offset - 0.5) / 30.0;\\n        float weight = 1.0 - abs(percent);\\n        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uInputSize.xy * percent * radius);\\n        sample.rgb *= sample.a;\\n        color += sample * weight;\\n        total += weight;\\n    }\\n\\n    color /= total;\\n    color.rgb /= color.a + 0.00001;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=tilt-shift.mjs.map\n","import { Filter, ViewSystem, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './tilt-shift.mjs';\nimport source from './tilt-shift2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _TiltShiftAxisFilter = class _TiltShiftAxisFilter extends Filter {\n  constructor(options) {\n    const { width, height } = ViewSystem.defaultOptions;\n    options = {\n      ..._TiltShiftAxisFilter.DEFAULT_OPTIONS,\n      /** The position to start the effect at. */\n      start: { x: 0, y: height / 2 },\n      /** The position to end the effect at. */\n      end: { x: width, y: height / 2 },\n      ...options\n    };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"tilt-shift-axis-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        tiltShiftUniforms: {\n          uBlur: {\n            value: new Float32Array([\n              options.blur,\n              options.gradientBlur\n            ]),\n            type: \"vec2<f32>\"\n          },\n          uStart: { value: options.start, type: \"vec2<f32>\" },\n          uEnd: { value: options.end, type: \"vec2<f32>\" },\n          uDelta: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_tiltAxis\");\n    this.uniforms = this.resources.tiltShiftUniforms.uniforms;\n    this._tiltAxis = options.axis;\n  }\n  /**\n   * Updates the filter delta values.\n   * @ignore\n   */\n  updateDelta() {\n    this.uniforms.uDelta[0] = 0;\n    this.uniforms.uDelta[1] = 0;\n    if (this._tiltAxis === void 0)\n      return;\n    const end = this.uniforms.uEnd;\n    const start = this.uniforms.uStart;\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const d = Math.sqrt(dx * dx + dy * dy);\n    const isVert = this._tiltAxis === \"vertical\";\n    this.uniforms.uDelta[0] = !isVert ? dx / d : -dy / d;\n    this.uniforms.uDelta[1] = !isVert ? dy / d : dx / d;\n  }\n};\n/** Default values for options. */\n__publicField(_TiltShiftAxisFilter, \"DEFAULT_OPTIONS\", {\n  /** The strength of the blur. */\n  blur: 100,\n  /** The strength of the blur gradient */\n  gradientBlur: 600\n});\nlet TiltShiftAxisFilter = _TiltShiftAxisFilter;\n\nexport { TiltShiftAxisFilter };\n//# sourceMappingURL=TiltShiftAxisFilter.mjs.map\n","var source = \"struct TiltShiftUniforms {\\n  uBlur: vec2<f32>,\\n  uStart: vec2<f32>,\\n  uEnd: vec2<f32>,\\n  uDelta: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uBlur = tiltShiftUniforms.uBlur[0];\\n  let uBlurGradient = tiltShiftUniforms.uBlur[1];\\n  let uStart = tiltShiftUniforms.uStart;\\n  let uEnd = tiltShiftUniforms.uEnd;\\n  let uDelta = tiltShiftUniforms.uDelta;\\n\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n  var total: f32 = 0.0;\\n\\n  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);\\n  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));\\n  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * gfu.uInputSize.xy - uStart, normal)) / uBlurGradient) * uBlur;\\n\\n  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)\\n  {\\n    var percent: f32 = (t + offset - 0.5) / 30.0;\\n    var weight: f32 = 1.0 - abs(percent);\\n    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / gfu.uInputSize.xy * percent * radius);\\n    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a\\n    color += sample * weight;\\n    total += weight;\\n  }\\n\\n  color /= total;\\n  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001\\n\\n  return color;\\n}\\n\\n\\nfn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32\\n{\\n  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=tilt-shift2.mjs.map\n","import { TexturePool } from 'pixi.js';\nimport { TiltShiftAxisFilter } from './TiltShiftAxisFilter.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TiltShiftFilter extends TiltShiftAxisFilter {\n  /**\n   * @param options - Options for the TiltShiftFilter constructor.\n   */\n  constructor(options) {\n    options = { ...TiltShiftAxisFilter.DEFAULT_OPTIONS, ...options };\n    super({ ...options, axis: \"horizontal\" });\n    __publicField(this, \"_tiltShiftYFilter\");\n    this._tiltShiftYFilter = new TiltShiftAxisFilter({ ...options, axis: \"vertical\" });\n    this.updateDelta();\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const renderTarget = TexturePool.getSameSizeTexture(input);\n    filterManager.applyFilter(this, input, renderTarget, true);\n    filterManager.applyFilter(this._tiltShiftYFilter, renderTarget, output, clearMode);\n    TexturePool.returnTexture(renderTarget);\n  }\n  /** @ignore */\n  updateDelta() {\n    super.updateDelta();\n    this._tiltShiftYFilter.updateDelta();\n  }\n  /** The strength of the blur. */\n  get blur() {\n    return this.uniforms.uBlur[0];\n  }\n  set blur(value) {\n    this.uniforms.uBlur[0] = this._tiltShiftYFilter.uniforms.uBlur[0] = value;\n  }\n  /** The strength of the gradient blur. */\n  get gradientBlur() {\n    return this.uniforms.uBlur[1];\n  }\n  set gradientBlur(value) {\n    this.uniforms.uBlur[1] = this._tiltShiftYFilter.uniforms.uBlur[1] = value;\n  }\n  /** The position to start the effect at. */\n  get start() {\n    return this.uniforms.uStart;\n  }\n  set start(value) {\n    this.uniforms.uStart = this._tiltShiftYFilter.uniforms.uStart = value;\n    this.updateDelta();\n  }\n  /** The position to start the effect at on the `x` axis. */\n  get startX() {\n    return this.start.x;\n  }\n  set startX(value) {\n    this.start.x = value;\n    this.updateDelta();\n  }\n  /** The position to start the effect at on the `x` axis. */\n  get startY() {\n    return this.start.y;\n  }\n  set startY(value) {\n    this.start.y = value;\n    this.updateDelta();\n  }\n  /** The position to end the effect at. */\n  get end() {\n    return this.uniforms.uEnd;\n  }\n  set end(value) {\n    this.uniforms.uEnd = this._tiltShiftYFilter.uniforms.uEnd = value;\n    this.updateDelta();\n  }\n  /** The position to end the effect at on the `x` axis. */\n  get endX() {\n    return this.end.x;\n  }\n  set endX(value) {\n    this.end.x = value;\n    this.updateDelta();\n  }\n  /** The position to end the effect at on the `y` axis. */\n  get endY() {\n    return this.end.y;\n  }\n  set endY(value) {\n    this.end.y = value;\n    this.updateDelta();\n  }\n}\n\nexport { TiltShiftFilter };\n//# sourceMappingURL=TiltShiftFilter.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTwist;\\nuniform vec2 uOffset;\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 twist(vec2 coord)\\n{\\n    coord -= uOffset;\\n\\n    float dist = length(coord);\\n    float uRadius = uTwist[0];\\n    float uAngle = uTwist[1];\\n\\n    if (dist < uRadius)\\n    {\\n        float ratioDist = (uRadius - dist) / uRadius;\\n        float angleMod = ratioDist * ratioDist * uAngle;\\n        float s = sin(angleMod);\\n        float c = cos(angleMod);\\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\\n    }\\n\\n    coord += uOffset;\\n\\n    return coord;\\n}\\n\\nvoid main(void)\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n    coord = twist(coord);\\n    coord = unmapCoord(coord);\\n    finalColor = texture(uTexture, coord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=twist2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './twist2.mjs';\nimport source from './twist.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _TwistFilter = class _TwistFilter extends Filter {\n  /**\n   * @param options - Options for the TwistFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._TwistFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"twist-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        twistUniforms: {\n          uTwist: {\n            value: [options.radius ?? 0, options.angle ?? 0],\n            type: \"vec2<f32>\"\n          },\n          uOffset: {\n            value: options.offset,\n            type: \"vec2<f32>\"\n          }\n        }\n      },\n      ...options\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.twistUniforms.uniforms;\n  }\n  /**\n   * The radius of the twist\n   * @default 200\n   */\n  get radius() {\n    return this.uniforms.uTwist[0];\n  }\n  set radius(value) {\n    this.uniforms.uTwist[0] = value;\n  }\n  /**\n   * The angle of the twist\n   * @default 4\n   */\n  get angle() {\n    return this.uniforms.uTwist[1];\n  }\n  set angle(value) {\n    this.uniforms.uTwist[1] = value;\n  }\n  /**\n   * The `x` offset coordinate to change the position of the center of the circle of effect\n   * @default 0\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n  }\n  /**\n   * The `x` offset coordinate to change the position of the center of the circle of effect\n   * @default 0\n   */\n  get offsetX() {\n    return this.offset.x;\n  }\n  set offsetX(value) {\n    this.offset.x = value;\n  }\n  /**\n   * The `y` offset coordinate to change the position of the center of the circle of effect\n   * @default 0\n   */\n  get offsetY() {\n    return this.offset.y;\n  }\n  set offsetY(value) {\n    this.offset.y = value;\n  }\n};\n/** Default values for options. */\n__publicField(_TwistFilter, \"DEFAULT_OPTIONS\", {\n  padding: 20,\n  radius: 200,\n  angle: 4,\n  offset: { x: 0, y: 0 }\n});\nlet TwistFilter = _TwistFilter;\n\nexport { TwistFilter };\n//# sourceMappingURL=TwistFilter.mjs.map\n","var source = \"struct TwistUniforms {\\n  uTwist:vec2<f32>,\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord *= gfu.uInputSize.xy;\\n  mappedCoord += gfu.uOutputFrame.xy;\\n  return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord -= gfu.uOutputFrame.xy;\\n  mappedCoord /= gfu.uInputSize.xy;\\n  return mappedCoord;\\n}\\n\\nfn twist(coord: vec2<f32>) -> vec2<f32>\\n{\\n  var twistedCoord: vec2<f32> = coord;\\n  let uRadius = twistUniforms.uTwist[0];\\n  let uAngle = twistUniforms.uTwist[1];\\n  let uOffset = twistUniforms.uOffset;\\n\\n  twistedCoord -= uOffset;\\n  \\n  let dist = length(twistedCoord);\\n\\n  if (dist < uRadius)\\n  {\\n    let ratioDist: f32 = (uRadius - dist) / uRadius;\\n    let angleMod: f32 = ratioDist * ratioDist * uAngle;\\n    let s: f32 = sin(angleMod);\\n    let c: f32 = cos(angleMod);\\n    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);\\n  }\\n\\n  twistedCoord += uOffset;\\n  return twistedCoord;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=twist.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\nuniform vec2 uCenter;\\nuniform vec2 uRadii;\\n\\nuniform vec4 uInputSize;\\n\\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\\n\\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float rand(vec2 co, float seed) {\\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\\n    return fract(sin(sn) * c + seed);\\n}\\n\\nvoid main() {\\n    float minGradient = uRadii[0] * 0.3;\\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\\n\\n    float gradient = uRadii[1] * 0.3;\\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\\n\\n    float countLimit = MAX_KERNEL_SIZE;\\n\\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\\n\\n    float strength = uStrength;\\n\\n    float delta = 0.0;\\n    float gap;\\n    if (dist < innerRadius) {\\n        delta = innerRadius - dist;\\n        gap = minGradient;\\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\\n        delta = dist - radius;\\n        gap = gradient;\\n    }\\n\\n    if (delta > 0.0) {\\n        float normalCount = gap / uInputSize.x;\\n        delta = (normalCount - delta) / normalCount;\\n        countLimit *= delta;\\n        strength *= delta;\\n        if (countLimit < 1.0)\\n        {\\n            gl_FragColor = texture(uTexture, vTextureCoord);\\n            return;\\n        }\\n    }\\n\\n    // randomize the lookup values to hide the fixed number of samples\\n    float offset = rand(vTextureCoord, 0.0);\\n\\n    float total = 0.0;\\n    vec4 color = vec4(0.0);\\n\\n    dir *= strength;\\n\\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\\n        float weight = 4.0 * (percent - percent * percent);\\n        vec2 p = vTextureCoord + dir * percent;\\n        vec4 sample = texture(uTexture, p);\\n\\n        // switch to pre-multiplied alpha to correctly blur transparent images\\n        // sample.rgb *= sample.a;\\n\\n        color += sample * weight;\\n        total += weight;\\n\\n        if (t > countLimit){\\n            break;\\n        }\\n    }\\n\\n    color /= total;\\n    // switch back from pre-multiplied alpha\\n    // color.rgb /= color.a + 0.00001;\\n\\n    gl_FragColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=zoom-blur2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './zoom-blur2.mjs';\nimport source from './zoom-blur.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ZoomBlurFilter = class _ZoomBlurFilter extends Filter {\n  /**\n   * @param options - Options for the ZoomBlurFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._ZoomBlurFilter.DEFAULT_OPTIONS, ...options };\n    const kernelSize = options.maxKernelSize ?? 32;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: source.replace(\"${MAX_KERNEL_SIZE}\", kernelSize.toFixed(1)),\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(\"${MAX_KERNEL_SIZE}\", kernelSize.toFixed(1)),\n      name: \"zoom-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        zoomBlurUniforms: {\n          uStrength: { value: options.strength, type: \"f32\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uRadii: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.zoomBlurUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Sets the strength of the zoom blur effect\n   * @default 0.1\n   */\n  get strength() {\n    return this.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.uniforms.uStrength = value;\n  }\n  /**\n   * The center of the zoom\n   * @default [0,0]\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.uniforms.uCenter.x;\n  }\n  set centerX(value) {\n    this.uniforms.uCenter.x = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `y` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.uniforms.uCenter.y;\n  }\n  set centerY(value) {\n    this.uniforms.uCenter.y = value;\n  }\n  /**\n   * The inner radius of zoom. The part in inner circle won't apply zoom blur effect\n   * @default 0\n   */\n  get innerRadius() {\n    return this.uniforms.uRadii[0];\n  }\n  set innerRadius(value) {\n    this.uniforms.uRadii[0] = value;\n  }\n  /**\n   * Outer radius of the effect. less than `0` equates to infinity\n   * @default -1\n   */\n  get radius() {\n    return this.uniforms.uRadii[1];\n  }\n  set radius(value) {\n    this.uniforms.uRadii[1] = value < 0 || value === Infinity ? -1 : value;\n  }\n};\n/** Default values for options. */\n__publicField(_ZoomBlurFilter, \"DEFAULT_OPTIONS\", {\n  strength: 0.1,\n  center: { x: 0, y: 0 },\n  innerRadius: 0,\n  radius: -1,\n  maxKernelSize: 32\n});\nlet ZoomBlurFilter = _ZoomBlurFilter;\n\nexport { ZoomBlurFilter };\n//# sourceMappingURL=ZoomBlurFilter.mjs.map\n","var source = \"struct ZoomBlurUniforms {\\n    uStrength:f32,\\n    uCenter:vec2<f32>,\\n    uRadii:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uStrength = zoomBlurUniforms.uStrength;\\n  let uCenter = zoomBlurUniforms.uCenter;\\n  let uRadii = zoomBlurUniforms.uRadii;\\n\\n  let minGradient: f32 = uRadii[0] * 0.3;\\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\\n\\n  let gradient: f32 = uRadii[1] * 0.3;\\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\\n\\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\\n\\n  var countLimit: f32 = MAX_KERNEL_SIZE;\\n\\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\\n\\n  var strength: f32 = uStrength;\\n\\n  var delta: f32 = 0.0;\\n  var gap: f32;\\n\\n  if (dist < innerRadius) {\\n      delta = innerRadius - dist;\\n      gap = minGradient;\\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\\n      delta = dist - radius;\\n      gap = gradient;\\n  }\\n\\n  var returnColorOnly: bool = false;\\n\\n  if (delta > 0.0) {\\n    let normalCount: f32 = gap / gfu.uInputSize.x;\\n    delta = (normalCount - delta) / normalCount;\\n    countLimit *= delta;\\n    strength *= delta;\\n    \\n    if (countLimit < 1.0)\\n    {\\n      returnColorOnly = true;;\\n    }\\n  }\\n\\n  // randomize the lookup values to hide the fixed number of samples\\n  let offset: f32 = rand(uv, 0.0);\\n\\n  var total: f32 = 0.0;\\n  var color: vec4<f32> = vec4<f32>(0.);\\n\\n  dir *= strength;\\n\\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\\n    let weight: f32 = 4.0 * (percent - percent * percent);\\n    let p: vec2<f32> = uv + dir * percent;\\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\\n    \\n    if (t < countLimit)\\n    {\\n      color += sample * weight;\\n      total += weight;\\n    }\\n  }\\n\\n  color /= total;\\n\\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nfn rand(co: vec2<f32>, seed: f32) -> f32\\n{\\n  let a: f32 = 12.9898;\\n  let b: f32 = 78.233;\\n  let c: f32 = 43758.5453;\\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\\n  let sn: f32 = modulo(dt, 3.14159);\\n  return fract(sin(sn) * c + seed);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=zoom-blur.mjs.map\n"],"names":["vertex","wgslVertex","__defProp","Object","defineProperty","__publicField","obj","key","value","enumerable","configurable","writable","__defNormalProp","_AdjustmentFilter","Filter","constructor","options","DEFAULT_OPTIONS","super","gpuProgram","GpuProgram","from","source","entryPoint","fragment","glProgram","GlProgram","name","resources","adjustmentUniforms","uGamma","gamma","type","uContrast","contrast","uSaturation","saturation","uBrightness","brightness","uColor","red","green","blue","alpha","this","uniforms","AdjustmentFilter","_KawaseBlurFilter","args","Array","isArray","deprecation","strength","quality","clamp","kawaseBlurUniforms","uOffset","Float32Array","x","y","pixelSize","kernels","_blur","_clamp","apply","filterManager","input","output","clearMode","uvX","pixelSizeX","width","uvY","pixelSizeY","height","offset","_quality","_kernels","applyFilter","renderTarget","TexturePool","getSameSizeTexture","tmp","source2","target","last","i","returnTexture","_generateKernels","Math","max","round","length","_pixelSize","_updatePadding","padding","ceil","reduce","acc","v","blur","k","step","push","KawaseBlurFilter","_ExtractBrightnessFilter","extractBrightnessUniforms","uThreshold","threshold","ExtractBrightnessFilter","_AdvancedBloomFilter","advancedBloomUniforms","uBloomScale","bloomScale","uMapTexture","Texture","WHITE","_extractFilter","_blurFilter","assign","brightTarget","bloomTarget","AdvancedBloomFilter","_AsciiFilter","size","replaceColor","color","asciiUniforms","uSize","uReplaceColor","Number","_color","Color","setValue","r","g","b","toArray","AsciiFilter","BackdropBlurFilter","BlurFilter","blendRequired","_blendPass","uBackground","EMPTY","backTexture","_activeFilterData","blurredBackground","updatePadding","_BevelFilter","bevelUniforms","uLightColor","uLightAlpha","lightAlpha","uShadowColor","uShadowAlpha","shadowAlpha","uTransform","_lightColor","_shadowColor","lightColor","shadowColor","rotation","_rotation","DEG_TO_RAD","_updateTransform","thickness","_thickness","cos","sin","BevelFilter","_BloomFilter","AlphaFilter","resolution","kernelSize","_strength","_blurXFilter","BlurFilterPass","horizontal","strengthX","_blurYFilter","strengthY","blendMode","clear","_updateStrength","blurX","blurY","BloomFilter","_BulgePinchFilter","bulgePinchUniforms","uDimensions","uCenter","center","uRadius","radius","uStrength","frame","centerX","centerY","BulgePinchFilter","GradientParser","stringify","visitor","node","visit_gradient","orientation","visit","colorStops","visit_shape","result","at","style","visit_position","visit_em","visit_px","visit_literal","visit_color","visit_hex","visit_rgb","join","visit_rgba","resultColor","visit_angular","visit_directional","visit_array","elements","forEach","element","nodeVisitor","Error","root","parse","tokens","error","msg","err","getAST","ast","matchListing","matchDefinition","matchGradient","matchLinearOrientation","matchListRadialOrientations","gradientType","pattern","orientationMatcher","matchCall","captures","scan","matchColorStop","callback","match","radialOrientations","lookaheadCache","radialOrientation","matchRadialOrientation","radialType","circle","matchLength","matchExtentKeyword","matchCircle","ellipse","matchDistance","matchEllipse","matchAtPosition","extent","positionAt","defaultPosition","matchPositioning","positioning","location","matcher","matchNumber","captureIndex","regexp","blankCaptures","exec","consume","substr","code","toString","parseCssGradient","cssGradient","cssGradientNodes","trimCssGradient","cssGradientNode","typeFromCssType","stops","stopsFromCssStops","angle","angleFromCssOrientation","supportedTypes","offsets","offsetsFromCssColorStops","colorString","colorAsStringFromCssStop","rgbaColor","slice","stop","cssStop","stopOffset","parseFloat","findNextFixedStop","fromIndex","indexDelta","prevFixedOffset","nextFixed","stepSize","s","map","fixFloatRounding","substring","angleFromDirectionalValue","supportedValues","left","top","bottom","right","value_","replace","trim","_ColorGradientFilter","css","defaults","maxColors","baseUniforms","uOptions","uCounts","stopsUniforms","uColors","maxStops","uStops","_stops","sortedStops","sort","a","sortColorStops","indexStart","LINEAR","ColorGradientFilter","_ColorMapFilter","TextureSource","colorMap","nearest","mix","colorMapUniforms","uMix","uSliceSize","uSlicePixelSize","uSliceInnerSize","uMapSampler","colorSize","_size","_colorMap","scaleMode","_scaleMode","autoGenerateMipmaps","_sliceSize","_slicePixelSize","_sliceInnerSize","_nearest","texture","update","updateColorMap","destroy","ColorMapFilter","_ColorOverlayFilter","colorOverlayUniforms","uAlpha","ColorOverlayFilter","_ColorReplaceFilter","originalColor","targetColor","tolerance","colorReplaceUniforms","uOriginalColor","uTargetColor","uTolerance","_originalColor","_targetColor","newColor","epsilon","ColorReplaceFilter","_ConvolutionFilter","matrix","convolutionUniforms","uMatrix","uTexelSize","ConvolutionFilter","CrossHatchFilter","_CRTFilter","crtUniforms","uLine","uNoise","uVignette","uSeed","seed","uTime","time","curvature","lineWidth","lineContrast","verticalLine","noise","noiseSize","vignetting","vignettingAlpha","vignettingBlur","CRTFilter","_DotFilter","scale","grayscale","dotUniforms","uScale","uAngle","uGrayScale","DotFilter","_DropShadowFilter","dropShadowUniforms","_basePass","shadowOnly","offsetX","offsetY","offsetPadding","abs","DropShadowFilter","EmbossFilter","embossUniforms","_GlitchFilter","canvas","document","createElement","sampleSize","ImageSource","resource","glitchUniforms","uAspect","uFillMode","fillMode","uDirection","direction","uRed","uGreen","uBlue","uDisplacementMap","uDisplacementSampler","_canvas","_randomizeSizes","arr","_sizes","_slices","min","minSize","average","count","rest","averageWidth","w","random","ratio","sqrt","shuffle","rand","temp","_randomizeOffsets","_offsets","refresh","redraw","ctx","getContext","clearRect","floor","fillStyle","fillRect","sizes","len","slices","GlitchFilter","_GlowFilter","distance","toFixed","glowUniforms","uDistance","innerStrength","outerStrength","uQuality","uKnockout","knockout","GlowFilter","_GodrayFilter","godrayUniforms","uLight","uParallel","uRay","parallel","_angleLight","_center","_angle","radians","gain","lacunarity","GodrayFilter","GrayscaleFilter","_HslAdjustmentFilter","hslUniforms","uHsl","uColorize","colorize","hue","_hue","PI","lightness","HslAdjustmentFilter","_MotionBlurFilter","ObservablePoint","velocity","motionBlurUniforms","uVelocity","uKernelSize","trunc","_updateDirty","velocityX","velocityY","_kernelSize","MotionBlurFilter","_MultiColorReplaceFilter","replacements","multiColorReplaceUniforms","uOriginalColors","uTargetColors","_maxColors","originals","targets","colorCount","pair","_replacements","MultiColorReplaceFilter","_OldFilmFilter","oldFilmUniforms","uSepia","sepia","uScratch","uVignetting","scratch","scratchDensity","scratchWidth","OldFilmFilter","_OutlineFilter","getAngleStep","outlineUniforms","uThickness","uAngleStep","MAX_SAMPLES","MIN_SAMPLES","OutlineFilter","PixelateFilter","pixelateUniforms","Point","sizeX","sizeY","_RadialBlurFilter","radialBlurUniforms","uRadian","_updateKernelSize","Infinity","RadialBlurFilter","_ReflectionFilter","reflectionUniforms","uMirror","mirror","uBoundary","boundary","uAmplitude","amplitude","uWavelength","waveLength","amplitudeStart","amplitudeEnd","wavelengthStart","wavelengthEnd","alphaStart","alphaEnd","ReflectionFilter","_RGBSplitFilter","rgbSplitUniforms","redX","redY","greenX","greenY","blueX","blueY","RGBSplitFilter","_ShockwaveFilter","shockwaveUniforms","uSpeed","speed","uWave","wavelength","ShockwaveFilter","_SimpleLightmapFilter","lightMap","simpleLightmapUniforms","_lightMap","SimpleLightmapFilter","_SimplexNoiseFilter","simplexUniforms","uNoiseScale","noiseScale","uOffsetX","uOffsetY","uOffsetZ","offsetZ","uStep","SimplexNoiseFilter","_TiltShiftAxisFilter","ViewSystem","defaultOptions","start","end","tiltShiftUniforms","uBlur","gradientBlur","uStart","uEnd","uDelta","_tiltAxis","axis","updateDelta","dx","dy","d","isVert","TiltShiftAxisFilter","TiltShiftFilter","_tiltShiftYFilter","startX","startY","endX","endY","_TwistFilter","twistUniforms","uTwist","TwistFilter","_ZoomBlurFilter","maxKernelSize","zoomBlurUniforms","uRadii","innerRadius","ZoomBlurFilter"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121]}