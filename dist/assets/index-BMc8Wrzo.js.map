{"version":3,"file":"index-BMc8Wrzo.js","sources":["../../node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs","../../node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/const.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs","../../node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs","../../node_modules/pixi-filters/lib/defaults/default.mjs","../../node_modules/pixi-filters/lib/defaults/default2.mjs","../../node_modules/pixi-filters/lib/adjustment/AdjustmentFilter.mjs","../../node_modules/pixi-filters/lib/adjustment/adjustment2.mjs","../../node_modules/pixi-filters/lib/adjustment/adjustment.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs","../../node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs","../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/ExtractBrightnessFilter.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/extract-brightness2.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/extract-brightness.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/AdvancedBloomFilter.mjs","../../node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom2.mjs","../../node_modules/pixi-filters/lib/ascii/ascii.mjs","../../node_modules/pixi-filters/lib/ascii/AsciiFilter.mjs","../../node_modules/pixi-filters/lib/ascii/ascii2.mjs","../../node_modules/pixi-filters/lib/backdrop-blur/backdrop-blur-blend2.mjs","../../node_modules/pixi-filters/lib/backdrop-blur/BackdropBlurFilter.mjs","../../node_modules/pixi-filters/lib/backdrop-blur/backdrop-blur-blend.mjs","../../node_modules/pixi-filters/lib/bevel/bevel.mjs","../../node_modules/pixi-filters/lib/bevel/BevelFilter.mjs","../../node_modules/pixi-filters/lib/bevel/bevel2.mjs","../../node_modules/pixi-filters/lib/bloom/BloomFilter.mjs","../../node_modules/pixi-filters/lib/bulge-pinch/bulge-pinch.mjs","../../node_modules/pixi-filters/lib/bulge-pinch/BulgePinchFilter.mjs","../../node_modules/pixi-filters/lib/bulge-pinch/bulge-pinch2.mjs","../../node_modules/pixi-filters/lib/color-gradient/color-gradient2.mjs","../../node_modules/pixi-filters/lib/external/gradient-parser/build/node.mjs","../../node_modules/pixi-filters/lib/color-gradient/color-gradient3.mjs","../../node_modules/pixi-filters/lib/color-gradient/CssGradientParser.mjs","../../node_modules/pixi-filters/lib/color-gradient/ColorGradientFilter.mjs","../../node_modules/pixi-filters/lib/color-gradient/color-gradient.mjs","../../node_modules/pixi-filters/lib/color-map/color-map2.mjs","../../node_modules/pixi-filters/lib/color-map/ColorMapFilter.mjs","../../node_modules/pixi-filters/lib/color-map/color-map.mjs","../../node_modules/pixi-filters/lib/color-overlay/color-overlay2.mjs","../../node_modules/pixi-filters/lib/color-overlay/ColorOverlayFilter.mjs","../../node_modules/pixi-filters/lib/color-overlay/color-overlay.mjs","../../node_modules/pixi-filters/lib/color-replace/color-replace.mjs","../../node_modules/pixi-filters/lib/color-replace/ColorReplaceFilter.mjs","../../node_modules/pixi-filters/lib/color-replace/color-replace2.mjs","../../node_modules/pixi-filters/lib/convolution/convolution.mjs","../../node_modules/pixi-filters/lib/convolution/ConvolutionFilter.mjs","../../node_modules/pixi-filters/lib/convolution/convolution2.mjs","../../node_modules/pixi-filters/lib/cross-hatch/CrossHatchFilter.mjs","../../node_modules/pixi-filters/lib/cross-hatch/crosshatch2.mjs","../../node_modules/pixi-filters/lib/cross-hatch/crosshatch.mjs","../../node_modules/pixi-filters/lib/crt/crt2.mjs","../../node_modules/pixi-filters/lib/crt/CRTFilter.mjs","../../node_modules/pixi-filters/lib/crt/crt.mjs","../../node_modules/pixi-filters/lib/dot/dot.mjs","../../node_modules/pixi-filters/lib/dot/DotFilter.mjs","../../node_modules/pixi-filters/lib/dot/dot2.mjs","../../node_modules/pixi-filters/lib/drop-shadow/drop-shadow.mjs","../../node_modules/pixi-filters/lib/drop-shadow/DropShadowFilter.mjs","../../node_modules/pixi-filters/lib/drop-shadow/drop-shadow2.mjs","../../node_modules/pixi-filters/lib/emboss/emboss2.mjs","../../node_modules/pixi-filters/lib/emboss/EmbossFilter.mjs","../../node_modules/pixi-filters/lib/emboss/emboss.mjs","../../node_modules/pixi-filters/lib/glitch/glitch2.mjs","../../node_modules/pixi-filters/lib/glitch/GlitchFilter.mjs","../../node_modules/pixi-filters/lib/glitch/glitch.mjs","../../node_modules/pixi-filters/lib/glow/glow.mjs","../../node_modules/pixi-filters/lib/glow/GlowFilter.mjs","../../node_modules/pixi-filters/lib/glow/glow2.mjs","../../node_modules/pixi-filters/lib/godray/god-ray2.mjs","../../node_modules/pixi-filters/lib/godray/GodrayFilter.mjs","../../node_modules/pixi-filters/lib/godray/god-ray.mjs","../../node_modules/pixi-filters/lib/godray/perlin2.mjs","../../node_modules/pixi-filters/lib/godray/perlin.mjs","../../node_modules/pixi-filters/lib/grayscale/GrayscaleFilter.mjs","../../node_modules/pixi-filters/lib/grayscale/grayscale.mjs","../../node_modules/pixi-filters/lib/grayscale/grayscale2.mjs","../../node_modules/pixi-filters/lib/hsl-adjustment/hsladjustment.mjs","../../node_modules/pixi-filters/lib/hsl-adjustment/HslAdjustmentFilter.mjs","../../node_modules/pixi-filters/lib/hsl-adjustment/hsladjustment2.mjs","../../node_modules/pixi-filters/lib/motion-blur/motion-blur2.mjs","../../node_modules/pixi-filters/lib/motion-blur/MotionBlurFilter.mjs","../../node_modules/pixi-filters/lib/motion-blur/motion-blur.mjs","../../node_modules/pixi-filters/lib/multi-color-replace/multi-color-replace.mjs","../../node_modules/pixi-filters/lib/multi-color-replace/MultiColorReplaceFilter.mjs","../../node_modules/pixi-filters/lib/multi-color-replace/multi-color-replace2.mjs","../../node_modules/pixi-filters/lib/old-film/old-film.mjs","../../node_modules/pixi-filters/lib/old-film/OldFilmFilter.mjs","../../node_modules/pixi-filters/lib/old-film/old-film2.mjs","../../node_modules/pixi-filters/lib/outline/outline.mjs","../../node_modules/pixi-filters/lib/outline/OutlineFilter.mjs","../../node_modules/pixi-filters/lib/outline/outline2.mjs","../../node_modules/pixi-filters/lib/pixelate/PixelateFilter.mjs","../../node_modules/pixi-filters/lib/pixelate/pixelate.mjs","../../node_modules/pixi-filters/lib/pixelate/pixelate2.mjs","../../node_modules/pixi-filters/lib/radial-blur/radial-blur.mjs","../../node_modules/pixi-filters/lib/radial-blur/RadialBlurFilter.mjs","../../node_modules/pixi-filters/lib/radial-blur/radial-blur2.mjs","../../node_modules/pixi-filters/lib/reflection/reflection.mjs","../../node_modules/pixi-filters/lib/reflection/ReflectionFilter.mjs","../../node_modules/pixi-filters/lib/reflection/reflection2.mjs","../../node_modules/pixi-filters/lib/rgb-split/rgb-split2.mjs","../../node_modules/pixi-filters/lib/rgb-split/RGBSplitFilter.mjs","../../node_modules/pixi-filters/lib/rgb-split/rgb-split.mjs","../../node_modules/pixi-filters/lib/shockwave/shockwave2.mjs","../../node_modules/pixi-filters/lib/shockwave/ShockwaveFilter.mjs","../../node_modules/pixi-filters/lib/shockwave/shockwave.mjs","../../node_modules/pixi-filters/lib/simple-lightmap/simple-lightmap.mjs","../../node_modules/pixi-filters/lib/simple-lightmap/SimpleLightmapFilter.mjs","../../node_modules/pixi-filters/lib/simple-lightmap/simple-lightmap2.mjs","../../node_modules/pixi-filters/lib/simplex-noise/simplex.mjs","../../node_modules/pixi-filters/lib/simplex-noise/SimplexNoiseFilter.mjs","../../node_modules/pixi-filters/lib/simplex-noise/simplex2.mjs","../../node_modules/pixi-filters/lib/tilt-shift/tilt-shift.mjs","../../node_modules/pixi-filters/lib/tilt-shift/TiltShiftAxisFilter.mjs","../../node_modules/pixi-filters/lib/tilt-shift/tilt-shift2.mjs","../../node_modules/pixi-filters/lib/tilt-shift/TiltShiftFilter.mjs","../../node_modules/pixi-filters/lib/twist/twist2.mjs","../../node_modules/pixi-filters/lib/twist/TwistFilter.mjs","../../node_modules/pixi-filters/lib/twist/twist.mjs","../../node_modules/pixi-filters/lib/zoom-blur/zoom-blur2.mjs","../../node_modules/pixi-filters/lib/zoom-blur/ZoomBlurFilter.mjs","../../node_modules/pixi-filters/lib/zoom-blur/zoom-blur.mjs"],"sourcesContent":["var fragment = \"\\nin vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform float uAlpha;\\nuniform sampler2D uTexture;\\n\\nvoid main()\\n{\\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=alpha.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct AlphaUniforms {\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n \\n    var sample = textureSample(uTexture, uSampler, uv);\\n    \\n    return sample * alphaUniforms.uAlpha;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=alpha.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './alpha.frag.mjs';\nimport source from './alpha.wgsl.mjs';\n\n\"use strict\";\nconst _AlphaFilter = class _AlphaFilter extends Filter {\n  constructor(options) {\n    options = { ..._AlphaFilter.defaultOptions, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"alpha-filter\"\n    });\n    const { alpha, ...rest } = options;\n    const alphaUniforms = new UniformGroup({\n      uAlpha: { value: alpha, type: \"f32\" }\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        alphaUniforms\n      }\n    });\n  }\n  /**\n   * The alpha value of the filter.\n   * Controls the transparency of the filtered display object.\n   * @example\n   * ```ts\n   * // Create filter with initial alpha\n   * const filter = new AlphaFilter({ alpha: 0.5 });\n   *\n   * // Update alpha value dynamically\n   * filter.alpha = 0.8;\n   * ```\n   * @default 1\n   * @remarks\n   * - 0 = fully transparent\n   * - 1 = fully opaque\n   * - Values are clamped between 0 and 1\n   */\n  get alpha() {\n    return this.resources.alphaUniforms.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.resources.alphaUniforms.uniforms.uAlpha = value;\n  }\n};\n/**\n * Default options for the AlphaFilter.\n * @example\n * ```ts\n * AlphaFilter.defaultOptions = {\n *     alpha: 0.5, // Default alpha value\n * };\n * // Use default options\n * const filter = new AlphaFilter(); // Uses default alpha of 0.5\n * ```\n */\n_AlphaFilter.defaultOptions = {\n  /**\n   * Amount of alpha transparency to apply.\n   * - 0 = fully transparent\n   * - 1 = fully opaque (default)\n   * @default 1\n   */\n  alpha: 1\n};\nlet AlphaFilter = _AlphaFilter;\n\nexport { AlphaFilter };\n//# sourceMappingURL=AlphaFilter.mjs.map\n","\"use strict\";\nconst GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n};\n\nexport { GAUSSIAN_VALUES };\n//# sourceMappingURL=const.mjs.map\n","import { GAUSSIAN_VALUES } from '../const.mjs';\n\n\"use strict\";\nconst fragTemplate = [\n  \"in vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uTexture;\",\n  \"out vec4 finalColor;\",\n  \"void main(void)\",\n  \"{\",\n  \"    finalColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(\"\\n\");\nfunction generateBlurFragSource(kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  let fragSource = fragTemplate;\n  let blurLoop = \"\";\n  const template = \"finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;\";\n  let value;\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace(\"%index%\", i.toString());\n    value = i;\n    if (i >= halfLength) {\n      value = kernelSize - i - 1;\n    }\n    blur = blur.replace(\"%value%\", kernel[value].toString());\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  fragSource = fragSource.replace(\"%blur%\", blurLoop);\n  fragSource = fragSource.replace(\"%size%\", kernelSize.toString());\n  return fragSource;\n}\n\nexport { generateBlurFragSource };\n//# sourceMappingURL=generateBlurFragSource.mjs.map\n","import { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { generateBlurFragSource } from './generateBlurFragSource.mjs';\nimport { generateBlurVertSource } from './generateBlurVertSource.mjs';\n\n\"use strict\";\nfunction generateBlurGlProgram(horizontal, kernelSize) {\n  const vertex = generateBlurVertSource(kernelSize, horizontal);\n  const fragment = generateBlurFragSource(kernelSize);\n  return GlProgram.from({\n    vertex,\n    fragment,\n    name: `blur-${horizontal ? \"horizontal\" : \"vertical\"}-pass-filter`\n  });\n}\n\nexport { generateBlurGlProgram };\n//# sourceMappingURL=generateBlurGlProgram.mjs.map\n","\"use strict\";\nconst vertTemplate = `\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(kernelSize, x) {\n  const halfLength = Math.ceil(kernelSize / 2);\n  let vertSource = vertTemplate;\n  let blurLoop = \"\";\n  let template;\n  if (x) {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);\";\n  } else {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);\";\n  }\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace(\"%index%\", i.toString());\n    blur = blur.replace(\"%sampleIndex%\", `${i - (halfLength - 1)}.0`);\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  vertSource = vertSource.replace(\"%blur%\", blurLoop);\n  vertSource = vertSource.replace(\"%size%\", kernelSize.toString());\n  vertSource = vertSource.replace(\"%dimension%\", x ? \"z\" : \"w\");\n  return vertSource;\n}\n\nexport { generateBlurVertSource };\n//# sourceMappingURL=generateBlurVertSource.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../../rendering/renderers/types.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport { generateBlurGlProgram } from './gl/generateBlurGlProgram.mjs';\nimport { generateBlurProgram } from './gpu/generateBlurProgram.mjs';\n\n\"use strict\";\nconst _BlurFilterPass = class _BlurFilterPass extends Filter {\n  /**\n   * @param options\n   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n   * @param options.strength - The strength of the blur filter.\n   * @param options.quality - The quality of the blur filter.\n   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n   */\n  constructor(options) {\n    options = { ..._BlurFilterPass.defaultOptions, ...options };\n    const glProgram = generateBlurGlProgram(options.horizontal, options.kernelSize);\n    const gpuProgram = generateBlurProgram(options.horizontal, options.kernelSize);\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        blurUniforms: {\n          uStrength: { value: 0, type: \"f32\" }\n        }\n      },\n      ...options\n    });\n    this.horizontal = options.horizontal;\n    this._quality = 0;\n    this.quality = options.quality;\n    this.blur = options.strength;\n    this._uniforms = this.resources.blurUniforms.uniforms;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   */\n  apply(filterManager, input, output, clearMode) {\n    this._uniforms.uStrength = this.strength / this.passes;\n    if (this.passes === 1) {\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const tempTexture = TexturePool.getSameSizeTexture(input);\n      let flip = input;\n      let flop = tempTexture;\n      this._state.blend = false;\n      const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;\n      for (let i = 0; i < this.passes - 1; i++) {\n        filterManager.applyFilter(this, flip, flop, i === 0 ? true : shouldClear);\n        const temp = flop;\n        flop = flip;\n        flip = temp;\n      }\n      this._state.blend = true;\n      filterManager.applyFilter(this, flip, output, clearMode);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  /**\n   * Sets the strength of both the blur.\n   * @default 16\n   */\n  get blur() {\n    return this.strength;\n  }\n  set blur(value) {\n    this.padding = 1 + Math.abs(value) * 2;\n    this.strength = value;\n  }\n  /**\n   * Sets the quality of the blur by modifying the number of passes. More passes means higher\n   * quality blurring but the lower the performance.\n   * @default 4\n   */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.passes = value;\n  }\n};\n/** Default blur filter pass options */\n_BlurFilterPass.defaultOptions = {\n  /** The strength of the blur filter. */\n  strength: 8,\n  /** The quality of the blur filter. */\n  quality: 4,\n  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n  kernelSize: 5\n};\nlet BlurFilterPass = _BlurFilterPass;\n\nexport { BlurFilterPass };\n//# sourceMappingURL=BlurFilterPass.mjs.map\n","import { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { GAUSSIAN_VALUES } from '../const.mjs';\nimport source from './blur-template.wgsl.mjs';\n\n\"use strict\";\nfunction generateBlurProgram(horizontal, kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  const blurStructSource = [];\n  const blurOutSource = [];\n  const blurSamplingSource = [];\n  for (let i = 0; i < kernelSize; i++) {\n    blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;\n    if (horizontal) {\n      blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;\n    } else {\n      blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;\n    }\n    const kernelIndex = i < halfLength ? i : kernelSize - i - 1;\n    const kernelValue = kernel[kernelIndex].toString();\n    blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;\n  }\n  const blurStruct = blurStructSource.join(\"\\n\");\n  const blurOut = blurOutSource.join(\"\\n\");\n  const blurSampling = blurSamplingSource.join(\"\\n\");\n  const finalSource = source.replace(\"%blur-struct%\", blurStruct).replace(\"%blur-vertex-out%\", blurOut).replace(\"%blur-fragment-in%\", blurStruct).replace(\"%blur-sampling%\", blurSampling).replace(\"%dimension%\", horizontal ? \"z\" : \"w\");\n  return GpuProgram.from({\n    vertex: {\n      source: finalSource,\n      entryPoint: \"mainVertex\"\n    },\n    fragment: {\n      source: finalSource,\n      entryPoint: \"mainFragment\"\n    }\n  });\n}\n\nexport { generateBlurProgram };\n//# sourceMappingURL=generateBlurProgram.mjs.map\n","var source = \"\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct BlurUniforms {\\n  uStrength:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\\n\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    %blur-struct%\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n\\n  let filteredCord = filterTextureCoord(aPosition);\\n\\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\\n\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n    %blur-vertex-out%\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  %blur-fragment-in%\\n) -> @location(0) vec4<f32> {\\n\\n    var   finalColor = vec4(0.0);\\n\\n    %blur-sampling%\\n\\n    return finalColor;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=blur-template.wgsl.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../../rendering/renderers/types.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport { BlurFilterPass } from './BlurFilterPass.mjs';\n\n\"use strict\";\nclass BlurFilter extends Filter {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }\");\n      options = { strength: options };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.resolution = args[2] || \"inherit\";\n      if (args[3] !== void 0)\n        options.kernelSize = args[3];\n    }\n    options = { ...BlurFilterPass.defaultOptions, ...options };\n    const { strength, strengthX, strengthY, quality, ...rest } = options;\n    super({\n      ...rest,\n      compatibleRenderers: RendererType.BOTH,\n      resources: {}\n    });\n    this._repeatEdgePixels = false;\n    this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });\n    this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });\n    this.quality = quality;\n    this.strengthX = strengthX ?? strength;\n    this.strengthY = strengthY ?? strength;\n    this.repeatEdgePixels = false;\n  }\n  /**\n   * Applies the filter.\n   * @param filterManager - The manager.\n   * @param input - The input target.\n   * @param output - The output target.\n   * @param clearMode - How to clear\n   * @advanced\n   */\n  apply(filterManager, input, output, clearMode) {\n    const xStrength = Math.abs(this.blurXFilter.strength);\n    const yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      const tempTexture = TexturePool.getSameSizeTexture(input);\n      this.blurXFilter.blendMode = \"normal\";\n      this.blurXFilter.apply(filterManager, input, tempTexture, true);\n      this.blurYFilter.blendMode = this.blendMode;\n      this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);\n      TexturePool.returnTexture(tempTexture);\n    } else if (yStrength) {\n      this.blurYFilter.blendMode = this.blendMode;\n      this.blurYFilter.apply(filterManager, input, output, clearMode);\n    } else {\n      this.blurXFilter.blendMode = this.blendMode;\n      this.blurXFilter.apply(filterManager, input, output, clearMode);\n    }\n  }\n  updatePadding() {\n    if (this._repeatEdgePixels) {\n      this.padding = 0;\n    } else {\n      this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;\n    }\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously.\n   * Controls the overall intensity of the Gaussian blur effect.\n   * @example\n   * ```ts\n   * // Set equal blur strength for both axes\n   * filter.strength = 8;\n   *\n   * // Will throw error if X and Y are different\n   * filter.strengthX = 4;\n   * filter.strengthY = 8;\n   * filter.strength; // Error: BlurFilter's strengthX and strengthY are different\n   * ```\n   * @default 8\n   * @throws {Error} If strengthX and strengthY are different values\n   */\n  get strength() {\n    if (this.strengthX !== this.strengthY) {\n      throw new Error(\"BlurFilter's strengthX and strengthY are different\");\n    }\n    return this.strengthX;\n  }\n  set strength(value) {\n    this.blurXFilter.blur = this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the number of passes for blur. More passes means higher quality blurring.\n   * Controls the precision and smoothness of the blur effect at the cost of performance.\n   * @example\n   * ```ts\n   * // High quality blur (slower)\n   * filter.quality = 8;\n   *\n   * // Low quality blur (faster)\n   * filter.quality = 2;\n   * ```\n   * @default 4\n   * @remarks Higher values produce better quality but impact performance\n   */\n  get quality() {\n    return this.blurXFilter.quality;\n  }\n  set quality(value) {\n    this.blurXFilter.quality = this.blurYFilter.quality = value;\n  }\n  /**\n   * Sets the strength of horizontal blur.\n   * Controls the blur intensity along the x-axis independently.\n   * @example\n   * ```ts\n   * // Apply horizontal-only blur\n   * filter.strengthX = 8;\n   * filter.strengthY = 0;\n   *\n   * // Create motion blur effect\n   * filter.strengthX = 16;\n   * filter.strengthY = 2;\n   * ```\n   * @default 8\n   */\n  get strengthX() {\n    return this.blurXFilter.blur;\n  }\n  set strengthX(value) {\n    this.blurXFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the strength of the vertical blur.\n   * Controls the blur intensity along the y-axis independently.\n   * @example\n   * ```ts\n   * // Apply vertical-only blur\n   * filter.strengthX = 0;\n   * filter.strengthY = 8;\n   *\n   * // Create radial blur effect\n   * filter.strengthX = 8;\n   * filter.strengthY = 8;\n   * ```\n   * @default 8\n   */\n  get strengthY() {\n    return this.blurYFilter.blur;\n  }\n  set strengthY(value) {\n    this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strength\n   */\n  get blur() {\n    deprecation(\"8.3.0\", \"BlurFilter.blur is deprecated, please use BlurFilter.strength instead.\");\n    return this.strength;\n  }\n  set blur(value) {\n    deprecation(\"8.3.0\", \"BlurFilter.blur is deprecated, please use BlurFilter.strength instead.\");\n    this.strength = value;\n  }\n  /**\n   * Sets the strength of the blurX property\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strengthX\n   */\n  get blurX() {\n    deprecation(\"8.3.0\", \"BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.\");\n    return this.strengthX;\n  }\n  set blurX(value) {\n    deprecation(\"8.3.0\", \"BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.\");\n    this.strengthX = value;\n  }\n  /**\n   * Sets the strength of the blurY property\n   * @default 2\n   * @deprecated since 8.3.0\n   * @see BlurFilter.strengthY\n   */\n  get blurY() {\n    deprecation(\"8.3.0\", \"BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.\");\n    return this.strengthY;\n  }\n  set blurY(value) {\n    deprecation(\"8.3.0\", \"BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.\");\n    this.strengthY = value;\n  }\n  /**\n   * If set to true the edge of the target will be clamped\n   * @default false\n   */\n  get repeatEdgePixels() {\n    return this._repeatEdgePixels;\n  }\n  set repeatEdgePixels(value) {\n    this._repeatEdgePixels = value;\n    this.updatePadding();\n  }\n}\n/**\n * Default blur filter options\n * @example\n * ```ts\n * // Set default options for all BlurFilters\n * BlurFilter.defaultOptions = {\n *     strength: 10,       // Default blur strength\n *     quality: 2,        // Default blur quality\n *     kernelSize: 7      // Default kernel size\n * };\n * // Create a filter with these defaults\n * const filter = new BlurFilter(); // Uses default options\n * ```\n * @remarks\n * - These options are used when creating a new BlurFilter without specific parameters\n * - Can be overridden by passing options to the constructor\n * - Useful for setting global defaults for all blur filters in your application\n * @see {@link BlurFilterOptions} For detailed options\n * @see {@link BlurFilter} The filter that uses these options\n */\nBlurFilter.defaultOptions = {\n  /** The strength of the blur filter. */\n  strength: 8,\n  /** The quality of the blur filter. */\n  quality: 4,\n  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */\n  kernelSize: 5\n};\n\nexport { BlurFilter };\n//# sourceMappingURL=BlurFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=default.mjs.map\n","var wgslVertex = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\";\n\nexport { wgslVertex as default };\n//# sourceMappingURL=default2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './adjustment.mjs';\nimport source from './adjustment2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _AdjustmentFilter = class _AdjustmentFilter extends Filter {\n  /**\n   * @param options - The options of the adjustment filter.\n   */\n  constructor(options) {\n    options = { ..._AdjustmentFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"adjustment-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        adjustmentUniforms: {\n          uGamma: { value: options.gamma, type: \"f32\" },\n          uContrast: { value: options.contrast, type: \"f32\" },\n          uSaturation: { value: options.saturation, type: \"f32\" },\n          uBrightness: { value: options.brightness, type: \"f32\" },\n          uColor: {\n            value: [\n              options.red,\n              options.green,\n              options.blue,\n              options.alpha\n            ],\n            type: \"vec4<f32>\"\n          }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.adjustmentUniforms.uniforms;\n  }\n  /**\n   * Amount of luminance\n   * @default 1\n   */\n  get gamma() {\n    return this.uniforms.uGamma;\n  }\n  set gamma(value) {\n    this.uniforms.uGamma = value;\n  }\n  /**\n   * Amount of contrast\n   * @default 1\n   */\n  get contrast() {\n    return this.uniforms.uContrast;\n  }\n  set contrast(value) {\n    this.uniforms.uContrast = value;\n  }\n  /**\n   * Amount of color saturation\n   * @default 1\n   */\n  get saturation() {\n    return this.uniforms.uSaturation;\n  }\n  set saturation(value) {\n    this.uniforms.uSaturation = value;\n  }\n  /**\n   * The overall brightness\n   * @default 1\n   */\n  get brightness() {\n    return this.uniforms.uBrightness;\n  }\n  set brightness(value) {\n    this.uniforms.uBrightness = value;\n  }\n  /**\n   * The multiplied red channel\n   * @default 1\n   */\n  get red() {\n    return this.uniforms.uColor[0];\n  }\n  set red(value) {\n    this.uniforms.uColor[0] = value;\n  }\n  /**\n   * The multiplied blue channel\n   * @default 1\n   */\n  get green() {\n    return this.uniforms.uColor[1];\n  }\n  set green(value) {\n    this.uniforms.uColor[1] = value;\n  }\n  /**\n   * The multiplied green channel\n   * @default 1\n   */\n  get blue() {\n    return this.uniforms.uColor[2];\n  }\n  set blue(value) {\n    this.uniforms.uColor[2] = value;\n  }\n  /**\n   * The overall alpha channel\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uColor[3];\n  }\n  set alpha(value) {\n    this.uniforms.uColor[3] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_AdjustmentFilter, \"DEFAULT_OPTIONS\", {\n  gamma: 1,\n  contrast: 1,\n  saturation: 1,\n  brightness: 1,\n  red: 1,\n  green: 1,\n  blue: 1,\n  alpha: 1\n});\nlet AdjustmentFilter = _AdjustmentFilter;\n\nexport { AdjustmentFilter };\n//# sourceMappingURL=AdjustmentFilter.mjs.map\n","var source = \"struct AdjustmentUniforms {\\n  uGamma: f32,\\n  uContrast: f32,\\n  uSaturation: f32,\\n  uBrightness: f32,\\n  uColor: vec4<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  var sample = textureSample(uTexture, uSampler, uv);\\n  let color = adjustmentUniforms.uColor;\\n\\n  if (sample.a > 0.0) \\n  {\\n    sample = vec4<f32>(sample.rgb / sample.a, sample.a);\\n    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));\\n    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);\\n    rgb.r *= color.r;\\n    rgb.g *= color.g;\\n    rgb.b *= color.b;\\n    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);\\n    sample = vec4<f32>(sample.rgb * sample.a, sample.a);\\n  }\\n\\n  return sample * color.a;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=adjustment2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uGamma;\\nuniform float uContrast;\\nuniform float uSaturation;\\nuniform float uBrightness;\\nuniform vec4 uColor;\\n\\nvoid main()\\n{\\n    vec4 c = texture(uTexture, vTextureCoord);\\n\\n    if (c.a > 0.0) {\\n        c.rgb /= c.a;\\n\\n        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));\\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);\\n        rgb.r *= uColor.r;\\n        rgb.g *= uColor.g;\\n        rgb.b *= uColor.b;\\n        c.rgb = rgb * uBrightness;\\n\\n        c.rgb *= c.a;\\n    }\\n\\n    finalColor = c * uColor.a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=adjustment.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=kawase-blur.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './kawase-blur.mjs';\nimport source from './kawase-blur2.mjs';\nimport fragmentClamp from './kawase-blur-clamp2.mjs';\nimport sourceClamp from './kawase-blur-clamp.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _KawaseBlurFilter = class _KawaseBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }\");\n      options = { strength: options };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.clamp = args[2];\n    }\n    options = { ..._KawaseBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: options?.clamp ? sourceClamp : source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: options?.clamp ? fragmentClamp : fragment,\n      name: \"kawase-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        kawaseBlurUniforms: {\n          uOffset: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_pixelSize\", { x: 0, y: 0 });\n    __publicField(this, \"_clamp\");\n    __publicField(this, \"_kernels\", []);\n    __publicField(this, \"_blur\");\n    __publicField(this, \"_quality\");\n    this.uniforms = this.resources.kawaseBlurUniforms.uniforms;\n    this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };\n    if (Array.isArray(options.strength)) {\n      this.kernels = options.strength;\n    } else if (typeof options.strength === \"number\") {\n      this._blur = options.strength;\n      this.quality = options.quality ?? 3;\n    }\n    this._clamp = !!options.clamp;\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const uvX = this.pixelSizeX / input.source.width;\n    const uvY = this.pixelSizeY / input.source.height;\n    let offset;\n    if (this._quality === 1 || this._blur === 0) {\n      offset = this._kernels[0] + 0.5;\n      this.uniforms.uOffset[0] = offset * uvX;\n      this.uniforms.uOffset[1] = offset * uvY;\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const renderTarget = TexturePool.getSameSizeTexture(input);\n      let source2 = input;\n      let target = renderTarget;\n      let tmp;\n      const last = this._quality - 1;\n      for (let i = 0; i < last; i++) {\n        offset = this._kernels[i] + 0.5;\n        this.uniforms.uOffset[0] = offset * uvX;\n        this.uniforms.uOffset[1] = offset * uvY;\n        filterManager.applyFilter(this, source2, target, true);\n        tmp = source2;\n        source2 = target;\n        target = tmp;\n      }\n      offset = this._kernels[last] + 0.5;\n      this.uniforms.uOffset[0] = offset * uvX;\n      this.uniforms.uOffset[1] = offset * uvY;\n      filterManager.applyFilter(this, source2, output, clearMode);\n      TexturePool.returnTexture(renderTarget);\n    }\n  }\n  /**\n    * The amount of blur, value greater than `0`.\n    * @default 4\n    */\n  get strength() {\n    return this._blur;\n  }\n  set strength(value) {\n    this._blur = value;\n    this._generateKernels();\n  }\n  /**\n    * The quality of the filter, integer greater than `1`.\n    * @default 3\n    */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = Math.max(1, Math.round(value));\n    this._generateKernels();\n  }\n  /**\n    * The kernel size of the blur filter, for advanced usage\n    * @default [0]\n    */\n  get kernels() {\n    return this._kernels;\n  }\n  set kernels(value) {\n    if (Array.isArray(value) && value.length > 0) {\n      this._kernels = value;\n      this._quality = value.length;\n      this._blur = Math.max(...value);\n    } else {\n      this._kernels = [0];\n      this._quality = 1;\n    }\n  }\n  /**\n    * The size of the pixels. Large size is blurrier. For advanced usage.\n    * @default {x:1,y:1}\n    */\n  get pixelSize() {\n    return this._pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      this.pixelSizeX = this.pixelSizeY = value;\n      return;\n    }\n    if (Array.isArray(value)) {\n      this.pixelSizeX = value[0];\n      this.pixelSizeY = value[1];\n      return;\n    }\n    this._pixelSize = value;\n  }\n  /**\n    * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.\n    * @default 1\n    */\n  get pixelSizeX() {\n    return this.pixelSize.x;\n  }\n  set pixelSizeX(value) {\n    this.pixelSize.x = value;\n  }\n  /**\n    * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.\n    * @default 1\n    */\n  get pixelSizeY() {\n    return this.pixelSize.y;\n  }\n  set pixelSizeY(value) {\n    this.pixelSize.y = value;\n  }\n  /**\n    * Get the if the filter is clamped\n    * @default false\n    */\n  get clamp() {\n    return this._clamp;\n  }\n  /** Update padding based on kernel data */\n  _updatePadding() {\n    this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n  }\n  /** Auto generate kernels by blur & quality */\n  _generateKernels() {\n    const blur = this._blur;\n    const quality = this._quality;\n    const kernels = [blur];\n    if (blur > 0) {\n      let k = blur;\n      const step = blur / quality;\n      for (let i = 1; i < quality; i++) {\n        k -= step;\n        kernels.push(k);\n      }\n    }\n    this._kernels = kernels;\n    this._updatePadding();\n  }\n};\n/** Default values for options. */\n__publicField(_KawaseBlurFilter, \"DEFAULT_OPTIONS\", {\n  strength: 4,\n  quality: 3,\n  clamp: false,\n  pixelSize: { x: 1, y: 1 }\n});\nlet KawaseBlurFilter = _KawaseBlurFilter;\n\nexport { KawaseBlurFilter };\n//# sourceMappingURL=KawaseBlurFilter.mjs.map\n","var sourceClamp = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Average\\n  color *= 0.25;\\n    \\n  return color;\\n}\";\n\nexport { sourceClamp as default };\n//# sourceMappingURL=kawase-blur-clamp.mjs.map\n","var source = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\\n  // Average\\n  color *= 0.25;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=kawase-blur2.mjs.map\n","var fragmentClamp = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputClamp;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragmentClamp as default };\n//# sourceMappingURL=kawase-blur-clamp2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uBloomScale;\\nuniform float uBrightness;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    color.rgb *= uBrightness;\\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\\n    bloomColor.rgb *= uBloomScale;\\n    finalColor = color + bloomColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=advanced-bloom.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './extract-brightness.mjs';\nimport source from './extract-brightness2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ExtractBrightnessFilter = class _ExtractBrightnessFilter extends Filter {\n  constructor(options) {\n    options = { ..._ExtractBrightnessFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"extract-brightness-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        extractBrightnessUniforms: {\n          uThreshold: { value: options.threshold, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.extractBrightnessUniforms.uniforms;\n  }\n  /**\n   * Defines how bright a color needs to be extracted.\n   * @default 0.5\n   */\n  get threshold() {\n    return this.uniforms.uThreshold;\n  }\n  set threshold(value) {\n    this.uniforms.uThreshold = value;\n  }\n};\n/** Default values for options. */\n__publicField(_ExtractBrightnessFilter, \"DEFAULT_OPTIONS\", {\n  threshold: 0.5\n});\nlet ExtractBrightnessFilter = _ExtractBrightnessFilter;\n\nexport { ExtractBrightnessFilter };\n//# sourceMappingURL=ExtractBrightnessFilter.mjs.map\n","var source = \"struct ExtractBrightnessUniforms {\\n  uThreshold: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // A simple & fast algorithm for getting brightness.\\n  // It's inaccurate, but good enough for this feature.\\n  let max: f32 = max(max(color.r, color.g), color.b);\\n  let min: f32 = min(min(color.r, color.g), color.b);\\n  let brightness: f32 = (max + min) * 0.5;\\n\\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=extract-brightness2.mjs.map\n","var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uThreshold;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    // A simple & fast algorithm for getting brightness.\\n    // It's inaccuracy , but good enought for this feature.\\n    float _max = max(max(color.r, color.g), color.b);\\n    float _min = min(min(color.r, color.g), color.b);\\n    float brightness = (_max + _min) * 0.5;\\n\\n    if(brightness > uThreshold) {\\n        finalColor = color;\\n    } else {\\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=extract-brightness.mjs.map\n","import { Filter, GpuProgram, GlProgram, Texture, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter.mjs';\nimport fragment from './advanced-bloom.mjs';\nimport source from './advanced-bloom2.mjs';\nimport { ExtractBrightnessFilter } from './ExtractBrightnessFilter.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _AdvancedBloomFilter = class _AdvancedBloomFilter extends Filter {\n  /**\n   * @param options - Options for the AdvancedBloomFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._AdvancedBloomFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"advanced-bloom-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        advancedBloomUniforms: {\n          uBloomScale: { value: options.bloomScale, type: \"f32\" },\n          uBrightness: { value: options.brightness, type: \"f32\" }\n        },\n        uMapTexture: Texture.WHITE\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /** To adjust the strength of the bloom. Higher values is more intense brightness. */\n    __publicField(this, \"bloomScale\", 1);\n    /** The brightness, lower value is more subtle brightness, higher value is blown-out. */\n    __publicField(this, \"brightness\", 1);\n    __publicField(this, \"_extractFilter\");\n    __publicField(this, \"_blurFilter\");\n    this.uniforms = this.resources.advancedBloomUniforms.uniforms;\n    this._extractFilter = new ExtractBrightnessFilter({\n      threshold: options.threshold\n    });\n    this._blurFilter = new KawaseBlurFilter({\n      strength: options.kernels ?? options.blur,\n      quality: options.kernels ? void 0 : options.quality\n    });\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const brightTarget = TexturePool.getSameSizeTexture(input);\n    this._extractFilter.apply(filterManager, input, brightTarget, true);\n    const bloomTarget = TexturePool.getSameSizeTexture(input);\n    this._blurFilter.apply(filterManager, brightTarget, bloomTarget, true);\n    this.uniforms.uBloomScale = this.bloomScale;\n    this.uniforms.uBrightness = this.brightness;\n    this.resources.uMapTexture = bloomTarget.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n    TexturePool.returnTexture(bloomTarget);\n    TexturePool.returnTexture(brightTarget);\n  }\n  /**\n   * Defines how bright a color needs to be extracted.\n   * @default 0.5\n   */\n  get threshold() {\n    return this._extractFilter.threshold;\n  }\n  set threshold(value) {\n    this._extractFilter.threshold = value;\n  }\n  /** The kernels of the Blur Filter */\n  get kernels() {\n    return this._blurFilter.kernels;\n  }\n  set kernels(value) {\n    this._blurFilter.kernels = value;\n  }\n  /**\n   * The strength of the Blur properties simultaneously\n   * @default 2\n   */\n  get blur() {\n    return this._blurFilter.strength;\n  }\n  set blur(value) {\n    this._blurFilter.strength = value;\n  }\n  /**\n   * The quality of the Blur Filter\n   * @default 4\n   */\n  get quality() {\n    return this._blurFilter.quality;\n  }\n  set quality(value) {\n    this._blurFilter.quality = value;\n  }\n  /**\n   * The pixel size of the Kawase Blur filter\n   * @default {x:1,y:1}\n   */\n  get pixelSize() {\n    return this._blurFilter.pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this._blurFilter.pixelSize = value;\n  }\n  /**\n   * The horizontal pixelSize of the Kawase Blur filter\n   * @default 1\n   */\n  get pixelSizeX() {\n    return this._blurFilter.pixelSizeX;\n  }\n  set pixelSizeX(value) {\n    this._blurFilter.pixelSizeX = value;\n  }\n  /**\n   * The vertical pixel size of the Kawase Blur filter\n   * @default 1\n   */\n  get pixelSizeY() {\n    return this._blurFilter.pixelSizeY;\n  }\n  set pixelSizeY(value) {\n    this._blurFilter.pixelSizeY = value;\n  }\n};\n/** Default values for options. */\n__publicField(_AdvancedBloomFilter, \"DEFAULT_OPTIONS\", {\n  threshold: 0.5,\n  bloomScale: 1,\n  brightness: 1,\n  blur: 8,\n  quality: 4,\n  pixelSize: { x: 1, y: 1 }\n});\nlet AdvancedBloomFilter = _AdvancedBloomFilter;\n\nexport { AdvancedBloomFilter };\n//# sourceMappingURL=AdvancedBloomFilter.mjs.map\n","var source = \"struct AdvancedBloomUniforms {\\n  uBloomScale: f32,\\n  uBrightness: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color = textureSample(uTexture, uSampler, uv);\\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\\n\\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\\n  \\n  return color + bloomColor;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=advanced-bloom2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uSize;\\nuniform vec3 uColor;\\nuniform float uReplaceColor;\\n\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 pixelate(vec2 coord, vec2 size)\\n{\\n    return floor(coord / size) * size;\\n}\\n\\nvec2 getMod(vec2 coord, vec2 size)\\n{\\n    return mod(coord, size) / size;\\n}\\n\\nfloat character(float n, vec2 p)\\n{\\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\\n\\n    if (clamp(p.x, 0.0, 4.0) == p.x)\\n    {\\n        if (clamp(p.y, 0.0, 4.0) == p.y)\\n        {\\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\\n        }\\n    }\\n    return 0.0;\\n}\\n\\nvoid main()\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n\\n    // get the grid position\\n    vec2 pixCoord = pixelate(coord, vec2(uSize));\\n    pixCoord = unmapCoord(pixCoord);\\n\\n    // sample the color at grid position\\n    vec4 color = texture(uTexture, pixCoord);\\n\\n    // brightness of the color as it's perceived by the human eye\\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\\n\\n    // determine the character to use\\n    float n =  65536.0;             // .\\n    if (gray > 0.2) n = 65600.0;    // :\\n    if (gray > 0.3) n = 332772.0;   // *\\n    if (gray > 0.4) n = 15255086.0; // o\\n    if (gray > 0.5) n = 23385164.0; // &\\n    if (gray > 0.6) n = 15252014.0; // 8\\n    if (gray > 0.7) n = 13199452.0; // @\\n    if (gray > 0.8) n = 11512810.0; // #\\n\\n    // get the mod..\\n    vec2 modd = getMod(coord, vec2(uSize));\\n\\n    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=ascii.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './ascii.mjs';\nimport source from './ascii2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _AsciiFilter = class _AsciiFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }\");\n      options = { size: options };\n    }\n    const replaceColor = options?.color && options.replaceColor !== false;\n    options = { ..._AsciiFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"ascii-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        asciiUniforms: {\n          uSize: { value: options.size, type: \"f32\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uReplaceColor: { value: Number(replaceColor), type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.asciiUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 16777215;\n  }\n  /**\n   * The pixel size used by the filter.\n   * @default 8\n   */\n  get size() {\n    return this.uniforms.uSize;\n  }\n  set size(value) {\n    this.uniforms.uSize = value;\n  }\n  /**\n   * The resulting color of the ascii characters, as a 3 component RGB or numerical hex\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0xffffff\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Determine whether or not to replace the source colors with the provided.\n   */\n  get replaceColor() {\n    return this.uniforms.uReplaceColor > 0.5;\n  }\n  set replaceColor(value) {\n    this.uniforms.uReplaceColor = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_AsciiFilter, \"DEFAULT_OPTIONS\", {\n  size: 8,\n  color: 16777215,\n  replaceColor: false\n});\nlet AsciiFilter = _AsciiFilter;\n\nexport { AsciiFilter };\n//# sourceMappingURL=AsciiFilter.mjs.map\n","var source = \"struct AsciiUniforms {\\n    uSize: f32,\\n    uColor: vec3<f32>,\\n    uReplaceColor: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let pixelSize: f32 = asciiUniforms.uSize;\\n    let coord: vec2<f32> = mapCoord(uv);\\n\\n    // get the rounded color..\\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\\n    pixCoord = unmapCoord(pixCoord);\\n\\n    var color = textureSample(uTexture, uSampler, pixCoord);\\n\\n    // determine the character to use\\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\\n    \\n    var n: f32 = 65536.0; // .\\n    if (gray > 0.2) {\\n        n = 65600.0;    // :\\n    }\\n    if (gray > 0.3) {\\n        n = 332772.0;   // *\\n    }\\n    if (gray > 0.4) {\\n        n = 15255086.0; // o\\n    }\\n    if (gray > 0.5) {\\n        n = 23385164.0; // &\\n    }\\n    if (gray > 0.6) {\\n        n = 15252014.0; // 8\\n    }\\n    if (gray > 0.7) {\\n        n = 13199452.0; // @\\n    }\\n    if (gray > 0.8) {\\n        n = 11512810.0; // #\\n    }\\n\\n    // get the mod..\\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\\n}\\n\\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n    return floor( coord / size ) * size;\\n}\\n\\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n    return moduloVec2( coord , size) / size;\\n}\\n\\nfn character(n: f32, p: vec2<f32>) -> f32\\n{\\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\\n\\n    if (clamp(q.x, 0.0, 4.0) == q.x)\\n    {\\n        if (clamp(q.y, 0.0, 4.0) == q.y)\\n        {\\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\\n        {\\n            return 1.0;\\n        }\\n        }\\n    }\\n\\n    return 0.0;\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n    var mappedCoord: vec2<f32> = coord;\\n    mappedCoord *= gfu.uInputSize.xy;\\n    mappedCoord += gfu.uOutputFrame.xy;\\n    return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n    var mappedCoord: vec2<f32> = coord;\\n    mappedCoord -= gfu.uOutputFrame.xy;\\n    mappedCoord /= gfu.uInputSize.xy;\\n    return mappedCoord;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=ascii2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uBackground;\\n\\nvoid main(void){\\n    vec4 front = texture(uTexture, vTextureCoord);\\n    vec4 back = texture(uBackground, vTextureCoord);\\n\\n    if (front.a == 0.0) {\\n        discard;\\n    }\\n    \\n    vec3 color = mix(back.rgb, front.rgb / front.a, front.a);\\n\\n    finalColor = vec4(color, 1.0);\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=backdrop-blur-blend2.mjs.map\n","import { BlurFilter, Filter, GpuProgram, GlProgram, Texture, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './backdrop-blur-blend2.mjs';\nimport wgslFragment from './backdrop-blur-blend.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass BackdropBlurFilter extends BlurFilter {\n  /**\n   * @param options - The options of the blur filter.\n   */\n  constructor(options) {\n    super(options);\n    __publicField(this, \"_blendPass\");\n    this.blendRequired = true;\n    this.padding = 0;\n    this._blendPass = new Filter({\n      gpuProgram: GpuProgram.from({\n        vertex: {\n          source: wgslVertex,\n          entryPoint: \"mainVertex\"\n        },\n        fragment: {\n          source: wgslFragment,\n          entryPoint: \"mainFragment\"\n        }\n      }),\n      glProgram: GlProgram.from({\n        vertex,\n        fragment,\n        name: \"drop-shadow-filter\"\n      }),\n      resources: {\n        uBackground: Texture.EMPTY\n      }\n    });\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const backTexture = filterManager._activeFilterData.backTexture;\n    const blurredBackground = TexturePool.getSameSizeTexture(input);\n    super.apply(filterManager, backTexture, blurredBackground, true);\n    this._blendPass.resources.uBackground = blurredBackground.source;\n    this._blendPass.apply(filterManager, input, output, clearMode);\n    TexturePool.returnTexture(blurredBackground);\n  }\n  updatePadding() {\n    this.padding = 0;\n  }\n}\n\nexport { BackdropBlurFilter };\n//# sourceMappingURL=BackdropBlurFilter.mjs.map\n","var wgslFragment = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var uBackground: texture_2d<f32>; \\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    var front: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n    var back: vec4<f32> = textureSample(uBackground, uSampler, uv);\\n    \\n    if (front.a == 0.0) {\\n        discard;\\n    }\\n\\n    var color: vec3<f32> = mix(back.rgb, front.rgb / front.a, front.a);\\n\\n    return vec4<f32>(color, 1.0);\\n}\";\n\nexport { wgslFragment as default };\n//# sourceMappingURL=backdrop-blur-blend.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTransform;\\nuniform vec3 uLightColor;\\nuniform float uLightAlpha;\\nuniform vec3 uShadowColor;\\nuniform float uShadowAlpha;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void) {\\n    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    float light = texture(uTexture, vTextureCoord - transform).a;\\n    float shadow = texture(uTexture, vTextureCoord + transform).a;\\n\\n    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));\\n    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));\\n    finalColor = vec4(color.rgb * color.a, color.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=bevel.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color, DEG_TO_RAD } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './bevel.mjs';\nimport source from './bevel2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _BevelFilter = class _BevelFilter extends Filter {\n  /**\n   * @param options - Options for the BevelFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._BevelFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"bevel-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        bevelUniforms: {\n          uLightColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uLightAlpha: { value: options.lightAlpha, type: \"f32\" },\n          uShadowColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uShadowAlpha: { value: options.shadowAlpha, type: \"f32\" },\n          uTransform: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      },\n      // Workaround: https://github.com/pixijs/filters/issues/230\n      // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image\n      // To solve this problem, a padding of 1 put on the filter should suffice\n      padding: 1\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_thickness\");\n    __publicField(this, \"_rotation\");\n    __publicField(this, \"_lightColor\");\n    __publicField(this, \"_shadowColor\");\n    this.uniforms = this.resources.bevelUniforms.uniforms;\n    this._lightColor = new Color();\n    this._shadowColor = new Color();\n    this.lightColor = options.lightColor ?? 16777215;\n    this.shadowColor = options.shadowColor ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * The angle of the light in degrees\n   * @default 45\n   */\n  get rotation() {\n    return this._rotation / DEG_TO_RAD;\n  }\n  set rotation(value) {\n    this._rotation = value * DEG_TO_RAD;\n    this._updateTransform();\n  }\n  /**\n   * The thickness of the bevel\n   * @default 2\n   */\n  get thickness() {\n    return this._thickness;\n  }\n  set thickness(value) {\n    this._thickness = value;\n    this._updateTransform();\n  }\n  /**\n   * The color value of the left & top bevel.\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0xffffff\n   */\n  get lightColor() {\n    return this._lightColor.value;\n  }\n  set lightColor(value) {\n    this._lightColor.setValue(value);\n    const [r, g, b] = this._lightColor.toArray();\n    this.uniforms.uLightColor[0] = r;\n    this.uniforms.uLightColor[1] = g;\n    this.uniforms.uLightColor[2] = b;\n  }\n  /**\n   * The alpha value of the left & top bevel.\n   * @default 0.7\n   */\n  get lightAlpha() {\n    return this.uniforms.uLightAlpha;\n  }\n  set lightAlpha(value) {\n    this.uniforms.uLightAlpha = value;\n  }\n  /**\n   * The color value of the right & bottom bevel.\n   * @default 0xffffff\n   */\n  get shadowColor() {\n    return this._shadowColor.value;\n  }\n  set shadowColor(value) {\n    this._shadowColor.setValue(value);\n    const [r, g, b] = this._shadowColor.toArray();\n    this.uniforms.uShadowColor[0] = r;\n    this.uniforms.uShadowColor[1] = g;\n    this.uniforms.uShadowColor[2] = b;\n  }\n  /**\n   * The alpha value of the right & bottom bevel.\n   * @default 0.7\n   */\n  get shadowAlpha() {\n    return this.uniforms.uShadowAlpha;\n  }\n  set shadowAlpha(value) {\n    this.uniforms.uShadowAlpha = value;\n  }\n  /**\n   * Update the transform matrix of offset angle.\n   * @private\n   */\n  _updateTransform() {\n    this.uniforms.uTransform[0] = this.thickness * Math.cos(this._rotation);\n    this.uniforms.uTransform[1] = this.thickness * Math.sin(this._rotation);\n  }\n};\n/** Default values for options. */\n__publicField(_BevelFilter, \"DEFAULT_OPTIONS\", {\n  rotation: 45,\n  thickness: 2,\n  lightColor: 16777215,\n  lightAlpha: 0.7,\n  shadowColor: 0,\n  shadowAlpha: 0.7\n});\nlet BevelFilter = _BevelFilter;\n\nexport { BevelFilter };\n//# sourceMappingURL=BevelFilter.mjs.map\n","var source = \"struct BevelUniforms {\\n  uLightColor: vec3<f32>,\\n  uLightAlpha: f32,\\n  uShadowColor: vec3<f32>,\\n  uShadowAlpha: f32,\\n  uTransform: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;\\n  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;\\n\\n  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);\\n  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);\\n\\n  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);\\n  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);\\n  \\n  return vec4<f32>(color.rgb * color.a, color.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=bevel2.mjs.map\n","import { AlphaFilter, deprecation, BlurFilterPass, TexturePool } from 'pixi.js';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _BloomFilter = class _BloomFilter extends AlphaFilter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options) || \"x\" in options && \"y\" in options) {\n      deprecation(\"6.0.0\", \"BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }\");\n      let strength = options;\n      if (Array.isArray(strength))\n        strength = { x: strength[0], y: strength[1] };\n      options = { strength };\n      if (args[1] !== void 0)\n        options.quality = args[1];\n      if (args[2] !== void 0)\n        options.resolution = args[2];\n      if (args[3] !== void 0)\n        options.kernelSize = args[3];\n    }\n    options = { ..._BloomFilter.DEFAULT_OPTIONS, ...options };\n    super();\n    __publicField(this, \"_blurXFilter\");\n    __publicField(this, \"_blurYFilter\");\n    __publicField(this, \"_strength\");\n    this._strength = { x: 2, y: 2 };\n    if (options.strength) {\n      if (typeof options.strength === \"number\") {\n        this._strength.x = options.strength;\n        this._strength.y = options.strength;\n      } else {\n        this._strength.x = options.strength.x;\n        this._strength.y = options.strength.y;\n      }\n    }\n    this._blurXFilter = new BlurFilterPass({\n      ...options,\n      horizontal: true,\n      strength: this.strengthX\n    });\n    this._blurYFilter = new BlurFilterPass({\n      ...options,\n      horizontal: false,\n      strength: this.strengthY\n    });\n    this._blurYFilter.blendMode = \"screen\";\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clear) {\n    const renderTarget = TexturePool.getSameSizeTexture(input);\n    filterManager.applyFilter(this, input, output, clear);\n    this._blurXFilter.apply(filterManager, input, renderTarget, true);\n    this._blurYFilter.apply(filterManager, renderTarget, output, false);\n    TexturePool.returnTexture(renderTarget);\n  }\n  /**\n   * Sets the strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   */\n  get strength() {\n    return this._strength;\n  }\n  set strength(value) {\n    this._strength = typeof value === \"number\" ? { x: value, y: value } : value;\n    this._updateStrength();\n  }\n  /**\n   * Sets the strength of the blur on the `x` axis\n   * @default 2\n   */\n  get strengthX() {\n    return this.strength.x;\n  }\n  set strengthX(value) {\n    this.strength.x = value;\n    this._updateStrength();\n  }\n  /**\n   * Sets the strength of the blur on the `y` axis\n   * @default 2\n   */\n  get strengthY() {\n    return this.strength.y;\n  }\n  set strengthY(value) {\n    this.strength.y = value;\n    this._updateStrength();\n  }\n  _updateStrength() {\n    this._blurXFilter.blur = this.strengthX;\n    this._blurYFilter.blur = this.strengthY;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The strength of both the blurX and blurY properties simultaneously\n   * @default 2\n   * @see BloomFilter#strength\n   */\n  get blur() {\n    deprecation(\"6.0.0\", \"BloomFilter.blur is deprecated, please use BloomFilter.strength instead\");\n    return this.strengthX;\n  }\n  set blur(value) {\n    deprecation(\"6.0.0\", \"BloomFilter.blur is deprecated, please use BloomFilter.strength instead\");\n    this.strength = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The strength of the blurX property\n   * @default 2\n   * @see BloomFilter#strengthX\n   */\n  get blurX() {\n    deprecation(\"6.0.0\", \"BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead\");\n    return this.strengthX;\n  }\n  set blurX(value) {\n    deprecation(\"6.0.0\", \"BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead\");\n    this.strengthX = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The strength of the blurY property\n   * @default 2\n   * @see BloomFilter#strengthY\n   */\n  get blurY() {\n    deprecation(\"6.0.0\", \"BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead\");\n    return this.strengthY;\n  }\n  set blurY(value) {\n    deprecation(\"6.0.0\", \"BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead\");\n    this.strengthY = value;\n  }\n};\n/** Default values for options. */\n__publicField(_BloomFilter, \"DEFAULT_OPTIONS\", {\n  strength: { x: 2, y: 2 },\n  quality: 4,\n  resolution: 1,\n  kernelSize: 5\n});\nlet BloomFilter = _BloomFilter;\n\nexport { BloomFilter };\n//# sourceMappingURL=BloomFilter.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uDimensions;\\nuniform vec2 uCenter;\\nuniform float uRadius;\\nuniform float uStrength;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nvoid main()\\n{\\n    vec2 coord = vTextureCoord * uInputSize.xy;\\n    coord -= uCenter * uDimensions.xy;\\n    float distance = length(coord);\\n\\n    if (distance < uRadius) {\\n        float percent = distance / uRadius;\\n        if (uStrength > 0.0) {\\n            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);\\n        } else {\\n            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);\\n        }\\n    }\\n\\n    coord += uCenter * uDimensions.xy;\\n    coord /= uInputSize.xy;\\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    vec4 color = texture(uTexture, clampedCoord);\\n\\n    if (coord != clampedCoord) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=bulge-pinch.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './bulge-pinch.mjs';\nimport source from './bulge-pinch2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _BulgePinchFilter = class _BulgePinchFilter extends Filter {\n  /**\n   * @param options - Options for the BulgePinchFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._BulgePinchFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"bulge-pinch-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        bulgePinchUniforms: {\n          uDimensions: { value: [0, 0], type: \"vec2<f32>\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uRadius: { value: options.radius, type: \"f32\" },\n          uStrength: { value: options.strength, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.bulgePinchUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords.\n   * { x: 0, y: 0 } means top-left and { x: 1, y: 1 } mean bottom-right\n   * @default {x:0.5,y:0.5}\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.uniforms.uCenter.x;\n  }\n  set centerX(value) {\n    this.uniforms.uCenter.x = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `y` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.uniforms.uCenter.y;\n  }\n  set centerY(value) {\n    this.uniforms.uCenter.y = value;\n  }\n  /**\n   * The radius of the circle of effect\n   * @default 100\n   */\n  get radius() {\n    return this.uniforms.uRadius;\n  }\n  set radius(value) {\n    this.uniforms.uRadius = value;\n  }\n  /**\n   * A value between -1 and 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n   * @default 1\n   */\n  get strength() {\n    return this.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.uniforms.uStrength = value;\n  }\n};\n/** Default values for options. */\n__publicField(_BulgePinchFilter, \"DEFAULT_OPTIONS\", {\n  center: { x: 0.5, y: 0.5 },\n  radius: 100,\n  strength: 1\n});\nlet BulgePinchFilter = _BulgePinchFilter;\n\nexport { BulgePinchFilter };\n//# sourceMappingURL=BulgePinchFilter.mjs.map\n","var source = \"struct BulgePinchUniforms {\\n  uDimensions: vec2<f32>,\\n  uCenter: vec2<f32>,\\n  uRadius: f32,\\n  uStrength: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;\\n  let center: vec2<f32> = bulgePinchUniforms.uCenter;\\n  let radius: f32 = bulgePinchUniforms.uRadius;\\n  let strength: f32 = bulgePinchUniforms.uStrength;\\n  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;\\n\\n  let distance: f32 = length(coord);\\n\\n  if (distance < radius) {\\n      let percent: f32 = distance / radius;\\n      if (strength > 0.0) {\\n          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\\n      } else {\\n          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\\n      }\\n  }\\n    coord += (center * dimensions.xy);\\n    coord /= gfu.uInputSize.xy;\\n\\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\\n    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\\n    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    return color;\\n}\\n\\nfn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool\\n{\\n  if (x.x == y.x && x.y == y.y)\\n  {\\n    return true;\\n  }\\n\\n  return false;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=bulge-pinch2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nin vec2 vFilterCoord;\\nout vec4 finalColor;\\n\\nconst int TYPE_LINEAR = 0;\\nconst int TYPE_RADIAL = 1;\\nconst int TYPE_CONIC = 2;\\nconst int MAX_STOPS = 32;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uOptions;\\nuniform vec2 uCounts;\\nuniform vec3 uColors[MAX_STOPS];\\nuniform vec4 uStops[MAX_STOPS];\\n\\nconst float PI = 3.1415926538;\\nconst float PI_2 = PI*2.;\\n\\nstruct ColorStop {\\n    float offset;\\n    vec3 color;\\n    float alpha;\\n};\\n\\nmat2 rotate2d(float angle){\\n    return mat2(cos(angle), -sin(angle),\\n    sin(angle), cos(angle));\\n}\\n\\nfloat projectLinearPosition(vec2 pos, float angle){\\n    vec2 center = vec2(0.5);\\n    vec2 result = pos - center;\\n    result = rotate2d(angle) * result;\\n    result = result + center;\\n    return clamp(result.x, 0., 1.);\\n}\\n\\nfloat projectRadialPosition(vec2 pos) {\\n    float r = distance(pos, vec2(0.5));\\n    return clamp(2.*r, 0., 1.);\\n}\\n\\nfloat projectAnglePosition(vec2 pos, float angle) {\\n    vec2 center = pos - vec2(0.5);\\n    float polarAngle=atan(-center.y, center.x);\\n    return mod(polarAngle + angle, PI_2) / PI_2;\\n}\\n\\nfloat projectPosition(vec2 pos, int type, float angle) {\\n    if (type == TYPE_LINEAR) {\\n        return projectLinearPosition(pos, angle);\\n    } else if (type == TYPE_RADIAL) {\\n        return projectRadialPosition(pos);\\n    } else if (type == TYPE_CONIC) {\\n        return projectAnglePosition(pos, angle);\\n    }\\n\\n    return pos.y;\\n}\\n\\nvoid main(void) {\\n    int uType = int(uOptions[0]);\\n    float uAngle = uOptions[1];\\n    float uAlpha = uOptions[2];\\n    float uReplace = uOptions[3];\\n\\n    int uNumStops = int(uCounts[0]);\\n    float uMaxColors = uCounts[1];\\n\\n    // current/original color\\n    vec4 currentColor = texture(uTexture, vTextureCoord);\\n\\n    // skip calculations if gradient alpha is 0\\n    if (0.0 == uAlpha) {\\n        finalColor = currentColor;\\n        return;\\n    }\\n\\n    // project position\\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\\n\\n    // check gradient bounds\\n    float offsetMin = uStops[0][0];\\n    float offsetMax = 0.0;\\n\\n    int numStops = int(uNumStops);\\n\\n    for (int i = 0; i < MAX_STOPS; i++) {\\n        if (i == numStops-1){ // last index\\n            offsetMax = uStops[i][0];\\n        }\\n    }\\n\\n    if (y  < offsetMin || y > offsetMax) {\\n        finalColor = currentColor;\\n        return;\\n    }\\n\\n    // limit colors\\n    if (uMaxColors > 0.) {\\n        float stepSize = 1./uMaxColors;\\n        float stepNumber = float(floor(y/stepSize));\\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\\n    }\\n\\n    // find color stops\\n    ColorStop from;\\n    ColorStop to;\\n\\n    for (int i = 0; i < MAX_STOPS; i++) {\\n        if (y >= uStops[i][0]) {\\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\\n        }\\n\\n        if (i == numStops-1){ // last index\\n            break;\\n        }\\n    }\\n\\n    // mix colors from stops\\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\\n\\n    float segmentHeight = to.offset - from.offset;\\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\\n\\n    float gradientAlpha = uAlpha * currentColor.a;\\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\\n\\n    if (uReplace < 0.5) {\\n        // mix resulting color with current color\\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\\n    } else {\\n        // replace with gradient color\\n        finalColor = gradientColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-gradient2.mjs.map\n","// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.stringify = (function() {\n\n  var visitor = {\n\n    'visit_linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-linear-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_repeating-radial-gradient': function(node) {\n      return visitor.visit_gradient(node);\n    },\n\n    'visit_gradient': function(node) {\n      var orientation = visitor.visit(node.orientation);\n      if (orientation) {\n        orientation += ', ';\n      }\n\n      return node.type + '(' + orientation + visitor.visit(node.colorStops) + ')';\n    },\n\n    'visit_shape': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at),\n          style = visitor.visit(node.style);\n\n      if (style) {\n        result += ' ' + style;\n      }\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_default-radial': function(node) {\n      var result = '',\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += at;\n      }\n      return result;\n    },\n\n    'visit_extent-keyword': function(node) {\n      var result = node.value,\n          at = visitor.visit(node.at);\n\n      if (at) {\n        result += ' at ' + at;\n      }\n\n      return result;\n    },\n\n    'visit_position-keyword': function(node) {\n      return node.value;\n    },\n\n    'visit_position': function(node) {\n      return visitor.visit(node.value.x) + ' ' + visitor.visit(node.value.y);\n    },\n\n    'visit_%': function(node) {\n      return node.value + '%';\n    },\n\n    'visit_em': function(node) {\n      return node.value + 'em';\n    },\n\n    'visit_px': function(node) {\n      return node.value + 'px';\n    },\n\n    'visit_literal': function(node) {\n      return visitor.visit_color(node.value, node);\n    },\n\n    'visit_hex': function(node) {\n      return visitor.visit_color('#' + node.value, node);\n    },\n\n    'visit_rgb': function(node) {\n      return visitor.visit_color('rgb(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_rgba': function(node) {\n      return visitor.visit_color('rgba(' + node.value.join(', ') + ')', node);\n    },\n\n    'visit_color': function(resultColor, node) {\n      var result = resultColor,\n          length = visitor.visit(node.length);\n\n      if (length) {\n        result += ' ' + length;\n      }\n      return result;\n    },\n\n    'visit_angular': function(node) {\n      return node.value + 'deg';\n    },\n\n    'visit_directional': function(node) {\n      return 'to ' + node.value;\n    },\n\n    'visit_array': function(elements) {\n      var result = '',\n          size = elements.length;\n\n      elements.forEach(function(element, i) {\n        result += visitor.visit(element);\n        if (i < size - 1) {\n          result += ', ';\n        }\n      });\n\n      return result;\n    },\n\n    'visit': function(element) {\n      if (!element) {\n        return '';\n      }\n      var result = '';\n\n      if (element instanceof Array) {\n        return visitor.visit_array(element, result);\n      } else if (element.type) {\n        var nodeVisitor = visitor['visit_' + element.type];\n        if (nodeVisitor) {\n          return nodeVisitor(element);\n        } else {\n          throw Error('Missing visitor visit_' + element.type);\n        }\n      } else {\n        throw Error('Invalid node.');\n      }\n    }\n\n  };\n\n  return function(root) {\n    return visitor.visit(root);\n  };\n})();\n\n// Copyright (c) 2014 Rafael Caricio. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nvar GradientParser = (GradientParser || {});\n\nGradientParser.parse = (function() {\n\n  var tokens = {\n    linearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(linear\\-gradient)/i,\n    repeatingLinearGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-linear\\-gradient)/i,\n    radialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(radial\\-gradient)/i,\n    repeatingRadialGradient: /^(\\-(webkit|o|ms|moz)\\-)?(repeating\\-radial\\-gradient)/i,\n    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,\n    extentKeywords: /^(closest\\-side|closest\\-corner|farthest\\-side|farthest\\-corner|contain|cover)/,\n    positionKeywords: /^(left|center|right|top|bottom)/i,\n    pixelValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))px/,\n    percentageValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))\\%/,\n    emValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))em/,\n    angleValue: /^(-?(([0-9]*\\.[0-9]+)|([0-9]+\\.?)))deg/,\n    startCall: /^\\(/,\n    endCall: /^\\)/,\n    comma: /^,/,\n    hexColor: /^\\#([0-9a-fA-F]+)/,\n    literalColor: /^([a-zA-Z]+)/,\n    rgbColor: /^rgb/i,\n    rgbaColor: /^rgba/i,\n    number: /^(([0-9]*\\.[0-9]+)|([0-9]+\\.?))/\n  };\n\n  var input = '';\n\n  function error(msg) {\n    var err = new Error(input + ': ' + msg);\n    err.source = input;\n    throw err;\n  }\n\n  function getAST() {\n    var ast = matchListDefinitions();\n\n    if (input.length > 0) {\n      error('Invalid input not EOF');\n    }\n\n    return ast;\n  }\n\n  function matchListDefinitions() {\n    return matchListing(matchDefinition);\n  }\n\n  function matchDefinition() {\n    return matchGradient(\n            'linear-gradient',\n            tokens.linearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'repeating-linear-gradient',\n            tokens.repeatingLinearGradient,\n            matchLinearOrientation) ||\n\n          matchGradient(\n            'radial-gradient',\n            tokens.radialGradient,\n            matchListRadialOrientations) ||\n\n          matchGradient(\n            'repeating-radial-gradient',\n            tokens.repeatingRadialGradient,\n            matchListRadialOrientations);\n  }\n\n  function matchGradient(gradientType, pattern, orientationMatcher) {\n    return matchCall(pattern, function(captures) {\n\n      var orientation = orientationMatcher();\n      if (orientation) {\n        if (!scan(tokens.comma)) {\n          error('Missing comma before color stops');\n        }\n      }\n\n      return {\n        type: gradientType,\n        orientation: orientation,\n        colorStops: matchListing(matchColorStop)\n      };\n    });\n  }\n\n  function matchCall(pattern, callback) {\n    var captures = scan(pattern);\n\n    if (captures) {\n      if (!scan(tokens.startCall)) {\n        error('Missing (');\n      }\n\n      var result = callback(captures);\n\n      if (!scan(tokens.endCall)) {\n        error('Missing )');\n      }\n\n      return result;\n    }\n  }\n\n  function matchLinearOrientation() {\n    return matchSideOrCorner() ||\n      matchAngle();\n  }\n\n  function matchSideOrCorner() {\n    return match('directional', tokens.sideOrCorner, 1);\n  }\n\n  function matchAngle() {\n    return match('angular', tokens.angleValue, 1);\n  }\n\n  function matchListRadialOrientations() {\n    var radialOrientations,\n        radialOrientation = matchRadialOrientation(),\n        lookaheadCache;\n\n    if (radialOrientation) {\n      radialOrientations = [];\n      radialOrientations.push(radialOrientation);\n\n      lookaheadCache = input;\n      if (scan(tokens.comma)) {\n        radialOrientation = matchRadialOrientation();\n        if (radialOrientation) {\n          radialOrientations.push(radialOrientation);\n        } else {\n          input = lookaheadCache;\n        }\n      }\n    }\n\n    return radialOrientations;\n  }\n\n  function matchRadialOrientation() {\n    var radialType = matchCircle() ||\n      matchEllipse();\n\n    if (radialType) {\n      radialType.at = matchAtPosition();\n    } else {\n      var extent = matchExtentKeyword();\n      if (extent) {\n        radialType = extent;\n        var positionAt = matchAtPosition();\n        if (positionAt) {\n          radialType.at = positionAt;\n        }\n      } else {\n        var defaultPosition = matchPositioning();\n        if (defaultPosition) {\n          radialType = {\n            type: 'default-radial',\n            at: defaultPosition\n          };\n        }\n      }\n    }\n\n    return radialType;\n  }\n\n  function matchCircle() {\n    var circle = match('shape', /^(circle)/i, 0);\n\n    if (circle) {\n      circle.style = matchLength() || matchExtentKeyword();\n    }\n\n    return circle;\n  }\n\n  function matchEllipse() {\n    var ellipse = match('shape', /^(ellipse)/i, 0);\n\n    if (ellipse) {\n      ellipse.style =  matchDistance() || matchExtentKeyword();\n    }\n\n    return ellipse;\n  }\n\n  function matchExtentKeyword() {\n    return match('extent-keyword', tokens.extentKeywords, 1);\n  }\n\n  function matchAtPosition() {\n    if (match('position', /^at/, 0)) {\n      var positioning = matchPositioning();\n\n      if (!positioning) {\n        error('Missing positioning value');\n      }\n\n      return positioning;\n    }\n  }\n\n  function matchPositioning() {\n    var location = matchCoordinates();\n\n    if (location.x || location.y) {\n      return {\n        type: 'position',\n        value: location\n      };\n    }\n  }\n\n  function matchCoordinates() {\n    return {\n      x: matchDistance(),\n      y: matchDistance()\n    };\n  }\n\n  function matchListing(matcher) {\n    var captures = matcher(),\n      result = [];\n\n    if (captures) {\n      result.push(captures);\n      while (scan(tokens.comma)) {\n        captures = matcher();\n        if (captures) {\n          result.push(captures);\n        } else {\n          error('One extra comma');\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function matchColorStop() {\n    var color = matchColor();\n\n    if (!color) {\n      error('Expected color definition');\n    }\n\n    color.length = matchDistance();\n    return color;\n  }\n\n  function matchColor() {\n    return matchHexColor() ||\n      matchRGBAColor() ||\n      matchRGBColor() ||\n      matchLiteralColor();\n  }\n\n  function matchLiteralColor() {\n    return match('literal', tokens.literalColor, 0);\n  }\n\n  function matchHexColor() {\n    return match('hex', tokens.hexColor, 1);\n  }\n\n  function matchRGBColor() {\n    return matchCall(tokens.rgbColor, function() {\n      return  {\n        type: 'rgb',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchRGBAColor() {\n    return matchCall(tokens.rgbaColor, function() {\n      return  {\n        type: 'rgba',\n        value: matchListing(matchNumber)\n      };\n    });\n  }\n\n  function matchNumber() {\n    return scan(tokens.number)[1];\n  }\n\n  function matchDistance() {\n    return match('%', tokens.percentageValue, 1) ||\n      matchPositionKeyword() ||\n      matchLength();\n  }\n\n  function matchPositionKeyword() {\n    return match('position-keyword', tokens.positionKeywords, 1);\n  }\n\n  function matchLength() {\n    return match('px', tokens.pixelValue, 1) ||\n      match('em', tokens.emValue, 1);\n  }\n\n  function match(type, pattern, captureIndex) {\n    var captures = scan(pattern);\n    if (captures) {\n      return {\n        type: type,\n        value: captures[captureIndex]\n      };\n    }\n  }\n\n  function scan(regexp) {\n    var captures,\n        blankCaptures;\n\n    blankCaptures = /^[\\n\\r\\t\\s]+/.exec(input);\n    if (blankCaptures) {\n        consume(blankCaptures[0].length);\n    }\n\n    captures = regexp.exec(input);\n    if (captures) {\n        consume(captures[0].length);\n    }\n\n    return captures;\n  }\n\n  function consume(size) {\n    input = input.substr(size);\n  }\n\n  return function(code) {\n    input = code.toString();\n    return getAST();\n  };\n})();\n\nvar parse = GradientParser.parse;\nGradientParser.stringify;\n\nexport { parse };\n//# sourceMappingURL=node.mjs.map\n","var source = \"struct BaseUniforms {\\n  uOptions: vec4<f32>,\\n  uCounts: vec2<f32>,\\n};\\n\\nstruct StopsUniforms {\\n  uColors: array<vec3<f32>, MAX_STOPS>,\\n  uStops: array<vec4<f32>, MAX_STOPS>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n  @location(1) coord : vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\\n{\\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   vTextureCoord,\\n   filterCoord(vTextureCoord),\\n  );\\n}\\n\\nstruct ColorStop {\\n  offset: f32,\\n  color: vec3<f32>,\\n  alpha: f32,\\n};\\n\\nfn rotate2d(angle: f32) -> mat2x2<f32>{\\n  return mat2x2(cos(angle), -sin(angle),\\n  sin(angle), cos(angle));\\n}\\n\\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\\n  var center: vec2<f32> = vec2<f32>(0.5);\\n  var result: vec2<f32> = pos - center;\\n  result = rotate2d(angle) * result;\\n  result = result + center;\\n  return clamp(result.x, 0.0, 1.0);\\n}\\n\\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\\n  var r: f32 = distance(pos, vec2<f32>(0.5));\\n  return clamp(2.0 * r, 0.0, 1.0);\\n}\\n\\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\\n  var polarAngle: f32 = atan2(-center.y, center.x);\\n  return ((polarAngle + angle) % PI_2) / PI_2;\\n}\\n\\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\\n  if (gradientType == TYPE_LINEAR) {\\n      return projectLinearPosition(pos, angle);\\n  } else if (gradientType == TYPE_RADIAL) {\\n      return projectRadialPosition(pos);\\n  } else if (gradientType == TYPE_CONIC) {\\n      return projectAnglePosition(pos, angle);\\n  }\\n\\n  return pos.y;\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n  @location(1) coord : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\\n  let uAngle: f32 = baseUniforms.uOptions[1];\\n  let uAlpha: f32 = baseUniforms.uOptions[2];\\n  let uReplace: f32 = baseUniforms.uOptions[3];\\n\\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\\n\\n  // current/original color\\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // skip calculations if gradient alpha is 0\\n  if (uAlpha == 0.0) { return currentColor; }\\n\\n  // project position\\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\\n\\n  // check gradient bounds\\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\\n  var offsetMax: f32 = 0.0;\\n\\n  let numStops: i32 = uNumStops;\\n\\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\\n      if (i == numStops - 1) { // last index\\n          offsetMax = stopsUniforms.uStops[i][0];\\n      }\\n  }\\n\\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\\n\\n  // limit colors\\n  if (uMaxColors > 0.0) {\\n      var stepSize: f32 = 1.0 / uMaxColors;\\n      var stepNumber: f32 = floor(y / stepSize);\\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\\n  }\\n\\n  // find color stops\\n  var stopFrom: ColorStop;\\n  var stopTo: ColorStop;\\n\\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\\n      if (y >= stopsUniforms.uStops[i][0]) {\\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\\n      }\\n\\n      if (i == numStops - 1) { // last index\\n          break;\\n      }\\n  }\\n\\n  // mix colors from stops\\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\\n\\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\\n\\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\\n\\n  if (uReplace < 0.5) {\\n      // mix resulting color with current color\\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\\n  } else {\\n      // replace with gradient color\\n      return gradientColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\\nconst PI_2: f32 = PI * 2.0;\\n\\nconst TYPE_LINEAR: i32 = 0;\\nconst TYPE_RADIAL: i32 = 1;\\nconst TYPE_CONIC: i32 = 2;\\nconst MAX_STOPS: i32 = 32;\";\n\nexport { source as default };\n//# sourceMappingURL=color-gradient3.mjs.map\n","import { parse } from '../external/gradient-parser/build/node.mjs';\nimport { Color } from 'pixi.js';\n\nfunction parseCssGradient(cssGradient) {\n  const cssGradientNodes = parse(trimCssGradient(cssGradient));\n  if (cssGradientNodes.length === 0) {\n    throw new Error(\"Invalid CSS gradient.\");\n  } else if (cssGradientNodes.length !== 1) {\n    throw new Error(\"Unsupported CSS gradient (multiple gradients is not supported).\");\n  }\n  const cssGradientNode = cssGradientNodes[0];\n  const type = typeFromCssType(cssGradientNode.type);\n  const stops = stopsFromCssStops(cssGradientNode.colorStops);\n  const angle = angleFromCssOrientation(cssGradientNode.orientation);\n  return {\n    type,\n    stops,\n    angle\n  };\n}\nfunction typeFromCssType(type) {\n  const supportedTypes = {\n    \"linear-gradient\": 0,\n    \"radial-gradient\": 1\n  };\n  if (!(type in supportedTypes)) {\n    throw new Error(`Unsupported gradient type \"${type}\"`);\n  }\n  return supportedTypes[type];\n}\nfunction stopsFromCssStops(stops) {\n  const offsets = offsetsFromCssColorStops(stops);\n  const result = [];\n  const color = new Color();\n  for (let i = 0; i < stops.length; i++) {\n    const colorString = colorAsStringFromCssStop(stops[i]);\n    const rgbaColor = color.setValue(colorString).toArray();\n    result.push({\n      offset: offsets[i],\n      color: rgbaColor.slice(0, 3),\n      alpha: rgbaColor[3]\n    });\n  }\n  return result;\n}\nfunction colorAsStringFromCssStop(stop) {\n  switch (stop.type) {\n    case \"hex\":\n      return `#${stop.value}`;\n    case \"literal\":\n      return stop.value;\n    default:\n      return `${stop.type}(${stop.value.join(\",\")})`;\n  }\n}\nfunction offsetsFromCssColorStops(stops) {\n  const offsets = [];\n  const dynamicOffset = -1;\n  for (let i = 0; i < stops.length; i++) {\n    const cssStop = stops[i];\n    let stopOffset = dynamicOffset;\n    if (cssStop.type === \"literal\") {\n      if (cssStop.length && \"type\" in cssStop.length && cssStop.length.type === \"%\" && \"value\" in cssStop.length) {\n        stopOffset = parseFloat(cssStop.length.value) / 100;\n      }\n    }\n    offsets.push(stopOffset);\n  }\n  const findNextFixedStop = (fromIndex) => {\n    for (let k = fromIndex; k < offsets.length; k++) {\n      if (offsets[k] !== dynamicOffset) {\n        return {\n          indexDelta: k - fromIndex,\n          offset: offsets[k]\n        };\n      }\n    }\n    return {\n      indexDelta: offsets.length - 1 - fromIndex,\n      offset: 1\n    };\n  };\n  let prevFixedOffset = 0;\n  for (let i = 0; i < offsets.length; i++) {\n    const offset = offsets[i];\n    if (offset !== dynamicOffset) {\n      prevFixedOffset = offset;\n    } else if (i === 0) {\n      offsets[i] = 0;\n    } else if (i + 1 === offsets.length) {\n      offsets[i] = 1;\n    } else {\n      const nextFixed = findNextFixedStop(i);\n      const offsetDelta = nextFixed.offset - prevFixedOffset;\n      const stepSize = offsetDelta / (1 + nextFixed.indexDelta);\n      for (let s = 0; s <= nextFixed.indexDelta; s++) {\n        offsets[i + s] = prevFixedOffset + (s + 1) * stepSize;\n      }\n      i += nextFixed.indexDelta;\n      prevFixedOffset = offsets[i];\n    }\n  }\n  return offsets.map(fixFloatRounding);\n}\nfunction fixFloatRounding(value) {\n  const maxLength = 6;\n  if (value.toString().length > maxLength) {\n    return parseFloat(value.toString().substring(0, maxLength));\n  }\n  return value;\n}\nfunction angleFromCssOrientation(orientation) {\n  if (typeof orientation === \"undefined\") {\n    return 0;\n  }\n  if (\"type\" in orientation && \"value\" in orientation) {\n    switch (orientation.type) {\n      case \"angular\":\n        return parseFloat(orientation.value);\n      case \"directional\":\n        return angleFromDirectionalValue(orientation.value);\n    }\n  }\n  return 0;\n}\nfunction angleFromDirectionalValue(value) {\n  const supportedValues = {\n    left: 270,\n    top: 0,\n    bottom: 180,\n    right: 90,\n    \"left top\": 315,\n    \"top left\": 315,\n    \"left bottom\": 225,\n    \"bottom left\": 225,\n    \"right top\": 45,\n    \"top right\": 45,\n    \"right bottom\": 135,\n    \"bottom right\": 135\n  };\n  if (!(value in supportedValues)) {\n    throw new Error(`Unsupported directional value \"${value}\"`);\n  }\n  return supportedValues[value];\n}\nfunction trimCssGradient(value) {\n  let value_ = value.replace(/\\s{2,}/gu, \" \");\n  value_ = value_.replace(/;/g, \"\");\n  value_ = value_.replace(/ ,/g, \",\");\n  value_ = value_.replace(/\\( /g, \"(\");\n  value_ = value_.replace(/ \\)/g, \")\");\n  return value_.trim();\n}\n\nexport { angleFromCssOrientation, angleFromDirectionalValue, colorAsStringFromCssStop, offsetsFromCssColorStops, parseCssGradient, stopsFromCssStops, trimCssGradient, typeFromCssType };\n//# sourceMappingURL=CssGradientParser.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport fragment from './color-gradient2.mjs';\nimport vertex from './color-gradient.mjs';\nimport source from './color-gradient3.mjs';\nimport { parseCssGradient } from './CssGradientParser.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst ANGLE_OFFSET = 90;\nfunction sortColorStops(stops) {\n  return [...stops].sort((a, b) => a.offset - b.offset);\n}\nconst _ColorGradientFilter = class _ColorGradientFilter extends Filter {\n  /**\n   * @param options - Options for the ColorGradientFilter constructor.\n   */\n  constructor(options) {\n    if (options && \"css\" in options) {\n      options = {\n        ...parseCssGradient(options.css || \"\"),\n        alpha: options.alpha ?? _ColorGradientFilter.defaults.alpha,\n        maxColors: options.maxColors ?? _ColorGradientFilter.defaults.maxColors\n      };\n    } else {\n      options = { ..._ColorGradientFilter.defaults, ...options };\n    }\n    if (!options.stops || options.stops.length < 2) {\n      throw new Error(\"ColorGradientFilter requires at least 2 color stops.\");\n    }\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-gradient-filter\"\n    });\n    const maxStops = 32;\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        baseUniforms: {\n          uOptions: {\n            value: [\n              // Gradient Type\n              options.type,\n              // Gradient Angle\n              options.angle ?? ANGLE_OFFSET,\n              // Master Alpha\n              options.alpha,\n              // Replace Base Color\n              options.replace ? 1 : 0\n            ],\n            type: \"vec4<f32>\"\n          },\n          uCounts: {\n            value: [\n              // Number of Stops\n              options.stops.length,\n              // Max Gradient Colors\n              options.maxColors\n            ],\n            type: \"vec2<f32>\"\n          }\n        },\n        stopsUniforms: {\n          uColors: { value: new Float32Array(maxStops * 3), type: \"vec3<f32>\", size: maxStops },\n          // We only need vec2, but we need to pad to eliminate the WGSL warning, TODO: @Mat ?\n          uStops: { value: new Float32Array(maxStops * 4), type: \"vec4<f32>\", size: maxStops }\n        }\n      }\n    });\n    __publicField(this, \"baseUniforms\");\n    __publicField(this, \"stopsUniforms\");\n    __publicField(this, \"_stops\", []);\n    this.baseUniforms = this.resources.baseUniforms.uniforms;\n    this.stopsUniforms = this.resources.stopsUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  get stops() {\n    return this._stops;\n  }\n  set stops(stops) {\n    const sortedStops = sortColorStops(stops);\n    const color = new Color();\n    let r;\n    let g;\n    let b;\n    for (let i = 0; i < sortedStops.length; i++) {\n      color.setValue(sortedStops[i].color);\n      const indexStart = i * 3;\n      [r, g, b] = color.toArray();\n      this.stopsUniforms.uColors[indexStart] = r;\n      this.stopsUniforms.uColors[indexStart + 1] = g;\n      this.stopsUniforms.uColors[indexStart + 2] = b;\n      this.stopsUniforms.uStops[i * 4] = sortedStops[i].offset;\n      this.stopsUniforms.uStops[i * 4 + 1] = sortedStops[i].alpha;\n    }\n    this.baseUniforms.uCounts[0] = sortedStops.length;\n    this._stops = sortedStops;\n  }\n  /**\n  * The type of gradient\n  * @default ColorGradientFilter.LINEAR\n  */\n  get type() {\n    return this.baseUniforms.uOptions[0];\n  }\n  set type(value) {\n    this.baseUniforms.uOptions[0] = value;\n  }\n  /**\n  * The angle of the gradient in degrees\n  * @default 90\n  */\n  get angle() {\n    return this.baseUniforms.uOptions[1] + ANGLE_OFFSET;\n  }\n  set angle(value) {\n    this.baseUniforms.uOptions[1] = value - ANGLE_OFFSET;\n  }\n  /**\n  * The alpha value of the gradient (0-1)\n  * @default 1\n  */\n  get alpha() {\n    return this.baseUniforms.uOptions[2];\n  }\n  set alpha(value) {\n    this.baseUniforms.uOptions[2] = value;\n  }\n  /**\n  * The maximum number of colors to render (0 = no limit)\n  * @default 0\n  */\n  get maxColors() {\n    return this.baseUniforms.uCounts[1];\n  }\n  set maxColors(value) {\n    this.baseUniforms.uCounts[1] = value;\n  }\n  /**\n   * If true, the gradient will replace the existing color, otherwise it\n   * will be multiplied with it\n   * @default false\n   */\n  get replace() {\n    return this.baseUniforms.uOptions[3] > 0.5;\n  }\n  set replace(value) {\n    this.baseUniforms.uOptions[3] = value ? 1 : 0;\n  }\n};\n/** Gradient types */\n__publicField(_ColorGradientFilter, \"LINEAR\", 0);\n__publicField(_ColorGradientFilter, \"RADIAL\", 1);\n__publicField(_ColorGradientFilter, \"CONIC\", 2);\n/** Default constructor options */\n__publicField(_ColorGradientFilter, \"defaults\", {\n  type: _ColorGradientFilter.LINEAR,\n  stops: [\n    { offset: 0, color: 16711680, alpha: 1 },\n    { offset: 1, color: 255, alpha: 1 }\n  ],\n  alpha: 1,\n  angle: 90,\n  maxColors: 0,\n  replace: false\n});\nlet ColorGradientFilter = _ColorGradientFilter;\n\nexport { ColorGradientFilter };\n//# sourceMappingURL=ColorGradientFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=color-gradient.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uMix;\\nuniform float uSize;\\nuniform float uSliceSize;\\nuniform float uSlicePixelSize;\\nuniform float uSliceInnerSize;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord.xy);\\n    vec4 adjusted;\\n\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n        float innerWidth = uSize - 1.0;\\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\\n        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;\\n        float s0 = xOffset + (zSlice0 * uSliceSize);\\n        float s1 = xOffset + (zSlice1 * uSliceSize);\\n        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);\\n        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));\\n        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));\\n        float zOffset = fract(color.b * innerWidth);\\n        adjusted = mix(slice0Color, slice1Color, zOffset);\\n\\n        color.rgb *= color.a;\\n    }\\n\\n    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);\\n\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-map2.mjs.map\n","import { Texture, Filter, TextureSource, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './color-map2.mjs';\nimport source from './color-map.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ColorMapFilter = class _ColorMapFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Texture || options instanceof TextureSource) {\n      deprecation(\"6.0.0\", \"ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }\");\n      options = { colorMap: options };\n      if (args[1] !== void 0)\n        options.nearest = args[1];\n      if (args[2] !== void 0)\n        options.mix = args[2];\n    }\n    options = { ..._ColorMapFilter.DEFAULT_OPTIONS, ...options };\n    if (!options.colorMap)\n      throw Error(\"No color map texture source was provided to ColorMapFilter\");\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-map-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorMapUniforms: {\n          uMix: { value: options.mix, type: \"f32\" },\n          uSize: { value: 0, type: \"f32\" },\n          uSliceSize: { value: 0, type: \"f32\" },\n          uSlicePixelSize: { value: 0, type: \"f32\" },\n          uSliceInnerSize: { value: 0, type: \"f32\" }\n        },\n        uMapTexture: options.colorMap.source,\n        uMapSampler: options.colorMap.source.style\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_size\", 0);\n    __publicField(this, \"_sliceSize\", 0);\n    __publicField(this, \"_slicePixelSize\", 0);\n    __publicField(this, \"_sliceInnerSize\", 0);\n    __publicField(this, \"_nearest\", false);\n    __publicField(this, \"_scaleMode\", \"linear\");\n    __publicField(this, \"_colorMap\");\n    this.uniforms = this.resources.colorMapUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /** The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image. */\n  get mix() {\n    return this.uniforms.uMix;\n  }\n  set mix(value) {\n    this.uniforms.uMix = value;\n  }\n  /**\n   * The size of one color slice.\n   * @readonly\n   */\n  get colorSize() {\n    return this._size;\n  }\n  /** The colorMap texture. */\n  get colorMap() {\n    return this._colorMap;\n  }\n  set colorMap(value) {\n    if (!value || value === this.colorMap)\n      return;\n    const source2 = value instanceof Texture ? value.source : value;\n    source2.style.scaleMode = this._scaleMode;\n    source2.autoGenerateMipmaps = false;\n    this._size = source2.height;\n    this._sliceSize = 1 / this._size;\n    this._slicePixelSize = this._sliceSize / this._size;\n    this._sliceInnerSize = this._slicePixelSize * (this._size - 1);\n    this.uniforms.uSize = this._size;\n    this.uniforms.uSliceSize = this._sliceSize;\n    this.uniforms.uSlicePixelSize = this._slicePixelSize;\n    this.uniforms.uSliceInnerSize = this._sliceInnerSize;\n    this.resources.uMapTexture = source2;\n    this._colorMap = value;\n  }\n  /** Whether use NEAREST for colorMap texture. */\n  get nearest() {\n    return this._nearest;\n  }\n  set nearest(nearest) {\n    this._nearest = nearest;\n    this._scaleMode = nearest ? \"nearest\" : \"linear\";\n    const texture = this._colorMap;\n    if (texture && texture.source) {\n      texture.source.scaleMode = this._scaleMode;\n      texture.source.autoGenerateMipmaps = false;\n      texture.source.style.update();\n      texture.source.update();\n    }\n  }\n  /**\n   * If the colorMap is based on canvas,\n   * and the content of canvas has changed, then call `updateColorMap` for update texture.\n   */\n  updateColorMap() {\n    const texture = this._colorMap;\n    if (texture?.source) {\n      texture.source.update();\n      this.colorMap = texture;\n    }\n  }\n  /**\n   * Destroys this filter\n   * @default false\n   */\n  destroy() {\n    this._colorMap?.destroy(\n      /** true | TODO: Should base texture be destroyed? **/\n    );\n    super.destroy();\n  }\n};\n/** Default values for options. */\n__publicField(_ColorMapFilter, \"DEFAULT_OPTIONS\", {\n  colorMap: Texture.WHITE,\n  nearest: false,\n  mix: 1\n});\nlet ColorMapFilter = _ColorMapFilter;\n\nexport { ColorMapFilter };\n//# sourceMappingURL=ColorMapFilter.mjs.map\n","var source = \"struct ColorMapUniforms {\\n  uMix: f32,\\n  uSize: f32,\\n  uSliceSize: f32,\\n  uSlicePixelSize: f32,\\n  uSliceInnerSize: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  var adjusted: vec4<f32>;\\n\\n  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);\\n  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;\\n  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);\\n  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);\\n  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;\\n  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);\\n  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);\\n  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);\\n  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));\\n  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));\\n  let zOffset: f32 = fract(color.b * innerWidth);\\n  adjusted = mix(slice0Color, slice1Color, zOffset);\\n  altColor = vec4<f32>(color.rgb * color.a, color.a);\\n\\n  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);\\n\\n  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=color-map.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\n\\nvoid main(void) {\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    finalColor = vec4(mix(c.rgb, uColor * c.a, uAlpha), c.a);\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-overlay2.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './color-overlay2.mjs';\nimport source from './color-overlay.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ColorOverlayFilter = class _ColorOverlayFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options) || options instanceof Float32Array) {\n      deprecation(\"6.0.0\", \"ColorOverlayFilter constructor params are now options object. See params: { color, alpha }\");\n      options = { color: options };\n      if (args[1] !== void 0)\n        options.alpha = args[1];\n    }\n    options = { ..._ColorOverlayFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-overlay-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorOverlayUniforms: {\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.colorOverlayUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 0;\n  }\n  /**\n   * The over color source\n   * @member {number|Array<number>|Float32Array}\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * The alpha value of the color\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n};\n/** Default shockwave filter options */\n__publicField(_ColorOverlayFilter, \"DEFAULT_OPTIONS\", {\n  /** The color of the overlay */\n  color: 0,\n  /** The alpha of the overlay */\n  alpha: 1\n});\nlet ColorOverlayFilter = _ColorOverlayFilter;\n\nexport { ColorOverlayFilter };\n//# sourceMappingURL=ColorOverlayFilter.mjs.map\n","var source = \"struct ColorOverlayUniforms {\\n    uColor: vec3<f32>,\\n    uAlpha: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    let c = textureSample(uTexture, uSampler, uv);\\n    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb * c.a, colorOverlayUniforms.uAlpha), c.a);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=color-overlay.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uOriginalColor;\\nuniform vec3 uTargetColor;\\nuniform float uTolerance;\\n\\nvoid main(void) {\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));\\n    float colorDistance = length(colorDiff);\\n    float doReplace = step(colorDistance, uTolerance);\\n    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=color-replace.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './color-replace.mjs';\nimport source from './color-replace2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ColorReplaceFilter = class _ColorReplaceFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\" || Array.isArray(options) || options instanceof Float32Array) {\n      deprecation(\"6.0.0\", \"ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }\");\n      options = { originalColor: options };\n      if (args[1] !== void 0)\n        options.targetColor = args[1];\n      if (args[2] !== void 0)\n        options.tolerance = args[2];\n    }\n    options = { ..._ColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"color-replace-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        colorReplaceUniforms: {\n          uOriginalColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uTargetColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uTolerance: { value: options.tolerance, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_originalColor\");\n    __publicField(this, \"_targetColor\");\n    this.uniforms = this.resources.colorReplaceUniforms.uniforms;\n    this._originalColor = new Color();\n    this._targetColor = new Color();\n    this.originalColor = options.originalColor ?? 16711680;\n    this.targetColor = options.targetColor ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * The color that will be changed.\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0xff0000\n   */\n  get originalColor() {\n    return this._originalColor.value;\n  }\n  set originalColor(value) {\n    this._originalColor.setValue(value);\n    const [r, g, b] = this._originalColor.toArray();\n    this.uniforms.uOriginalColor[0] = r;\n    this.uniforms.uOriginalColor[1] = g;\n    this.uniforms.uOriginalColor[2] = b;\n  }\n  /**\n    * The resulting color.\n    * @example [1.0, 1.0, 1.0] = 0xffffff\n    * @default 0x000000\n    */\n  get targetColor() {\n    return this._targetColor.value;\n  }\n  set targetColor(value) {\n    this._targetColor.setValue(value);\n    const [r, g, b] = this._targetColor.toArray();\n    this.uniforms.uTargetColor[0] = r;\n    this.uniforms.uTargetColor[1] = g;\n    this.uniforms.uTargetColor[2] = b;\n  }\n  /**\n    * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n    * @default 0.4\n    */\n  get tolerance() {\n    return this.uniforms.uTolerance;\n  }\n  set tolerance(value) {\n    this.uniforms.uTolerance = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]\n   * @member {number|Array<number>|Float32Array}\n   * @default 0x000000\n   * @see ColorReplaceFilter#targetColor\n   */\n  set newColor(value) {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead\");\n    this.targetColor = value;\n  }\n  get newColor() {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead\");\n    return this.targetColor;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n   * @default 0.4\n   * @see ColorReplaceFilter#tolerance\n   */\n  set epsilon(value) {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead\");\n    this.tolerance = value;\n  }\n  get epsilon() {\n    deprecation(\"6.0.0\", \"ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead\");\n    return this.tolerance;\n  }\n};\n/** Default values for options. */\n__publicField(_ColorReplaceFilter, \"DEFAULT_OPTIONS\", {\n  originalColor: 16711680,\n  targetColor: 0,\n  tolerance: 0.4\n});\nlet ColorReplaceFilter = _ColorReplaceFilter;\n\nexport { ColorReplaceFilter };\n//# sourceMappingURL=ColorReplaceFilter.mjs.map\n","var source = \"struct ColorReplaceUniforms {\\n  uOriginalColor: vec3<f32>,\\n  uTargetColor: vec3<f32>,\\n  uTolerance: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;\\n\\n@fragment\\nfn mainFragment(\\n   @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));\\n  let colorDistance: f32 = length(colorDiff);\\n  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);\\n\\n  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=color-replace2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTexelSize;\\nuniform mat3 uMatrix;\\n\\nvoid main(void)\\n{\\n    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left\\n    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center\\n    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right\\n\\n    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left\\n    vec4 c22 = texture(uTexture, vTextureCoord); // mid center\\n    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right\\n\\n    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left\\n    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center\\n    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right\\n\\n    finalColor =\\n        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +\\n        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +\\n        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];\\n\\n    finalColor.a = c22.a;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=convolution.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './convolution.mjs';\nimport source from './convolution2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ConvolutionFilter = class _ConvolutionFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }\");\n      options = { matrix: options };\n      if (args[1] !== void 0)\n        options.width = args[1];\n      if (args[2] !== void 0)\n        options.height = args[2];\n    }\n    options = { ..._ConvolutionFilter.DEFAULT_OPTIONS, ...options };\n    const width = options.width ?? 200;\n    const height = options.height ?? 200;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"convolution-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        convolutionUniforms: {\n          uMatrix: { value: options.matrix, type: \"mat3x3<f32>\" },\n          uTexelSize: { value: { x: 1 / width, y: 1 / height }, type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.convolutionUniforms.uniforms;\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * An array of values used for matrix transformation, specified as a 9 point Array\n   * @example\n   * const matrix = new Float32Array(9); // 9 elements of value 0\n   * const matrix = [0,0.5,0,0.5,1,0.5,0,0.5,0];\n   * @default [0,0,0,0,0,0,0,0,0]\n   */\n  get matrix() {\n    return this.uniforms.uMatrix;\n  }\n  set matrix(matrix) {\n    matrix.forEach((v, i) => {\n      this.uniforms.uMatrix[i] = v;\n    });\n  }\n  /**\n   * Width of the object you are transforming\n   * @default 200\n   */\n  get width() {\n    return 1 / this.uniforms.uTexelSize.x;\n  }\n  set width(value) {\n    this.uniforms.uTexelSize.x = 1 / value;\n  }\n  /**\n   * Height of the object you are transforming\n   * @default 200\n   */\n  get height() {\n    return 1 / this.uniforms.uTexelSize.y;\n  }\n  set height(value) {\n    this.uniforms.uTexelSize.y = 1 / value;\n  }\n};\n/** Default values for options. */\n__publicField(_ConvolutionFilter, \"DEFAULT_OPTIONS\", {\n  matrix: new Float32Array(9),\n  width: 200,\n  height: 200\n});\nlet ConvolutionFilter = _ConvolutionFilter;\n\nexport { ConvolutionFilter };\n//# sourceMappingURL=ConvolutionFilter.mjs.map\n","var source = \"struct ConvolutionUniforms {\\n    uMatrix: mat3x3<f32>,\\n    uTexelSize: vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let texelSize = convolutionUniforms.uTexelSize;\\n    let matrix = convolutionUniforms.uMatrix;\\n\\n    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left\\n    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center\\n    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right\\n\\n    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left\\n    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center\\n    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right\\n\\n    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left\\n    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center\\n    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right\\n\\n    var finalColor: vec4<f32> = vec4<f32>(\\n        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +\\n        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +\\n        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]\\n    );\\n\\n    finalColor.a = c22.a;\\n\\n    return finalColor;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=convolution2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './crosshatch.mjs';\nimport source from './crosshatch2.mjs';\n\nclass CrossHatchFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"cross-hatch-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {}\n    });\n  }\n}\n\nexport { CrossHatchFilter };\n//# sourceMappingURL=CrossHatchFilter.mjs.map\n","var source = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n    @location(0) uv: vec2<f32>,\\n    @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let lum: f32 = length(textureSample(uTexture, uSampler, uv).rgb);\\n\\n    if (lum < 1.00)\\n    {\\n        if (modulo(position.x + position.y, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (modulo(position.x - position.y, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (modulo(position.x + position.y - 5.0, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (modulo(position.x - position.y - 5.0, 10.0) == 0.0)\\n        {\\n            return vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    return vec4<f32>(1.0);\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=crosshatch2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void)\\n{\\n    float lum = length(texture(uTexture, vTextureCoord.xy).rgb);\\n\\n    finalColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n    if (lum < 1.00)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.75)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.50)\\n    {\\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n\\n    if (lum < 0.3)\\n    {\\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\\n        {\\n            finalColor = vec4(0.0, 0.0, 0.0, 1.0);\\n        }\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=crosshatch.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uLine;\\nuniform vec2 uNoise;\\nuniform vec3 uVignette;\\nuniform float uSeed;\\nuniform float uTime;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nconst float SQRT_2 = 1.414213;\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfloat vignette(vec3 co, vec2 coord)\\n{\\n    float outter = SQRT_2 - uVignette[0] * SQRT_2;\\n    vec2 dir = vec2(0.5) - coord;\\n    dir.y *= uDimensions.y / uDimensions.x;\\n    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\\n    return darker + (1.0 - darker) * (1.0 - uVignette[1]);\\n}\\n\\nfloat noise(vec2 coord)\\n{\\n    vec2 pixelCoord = coord * uInputSize.xy;\\n    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\\n\\nvec3 interlaceLines(vec3 co, vec2 coord)\\n{\\n    vec3 color = co;\\n\\n    float curvature = uLine[0];\\n    float lineWidth = uLine[1];\\n    float lineContrast = uLine[2];\\n    float verticalLine = uLine[3];\\n\\n    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);\\n\\n    float _c = curvature > 0. ? curvature : 1.;\\n    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\\n    vec2 uv = dir * k;\\n    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;\\n    v *= min(1.0, 2.0 / lineWidth ) / _c;\\n    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;\\n    color *= j;\\n\\n    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);\\n    color *= 0.99 + ceil(segment) * 0.015;\\n\\n    return color;\\n}\\n\\nvoid main(void)\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\\n\\n    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n    {\\n        float n = noise(vTextureCoord);\\n        finalColor += vec4(n, n, n, finalColor.a);\\n    }\\n\\n    if (uVignette[0] > 0.)\\n    {\\n        float v = vignette(finalColor.rgb, coord);\\n        finalColor *= vec4(v, v, v, finalColor.a);\\n    }\\n\\n    if (uLine[1] > 0.0)\\n    {\\n        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  \\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=crt2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './crt2.mjs';\nimport source from './crt.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _CRTFilter = class _CRTFilter extends Filter {\n  /**\n   * @param options - Options for the CRTFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._CRTFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"crt-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        crtUniforms: {\n          uLine: { value: new Float32Array(4), type: \"vec4<f32>\" },\n          uNoise: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uVignette: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uSeed: { value: options.seed, type: \"f32\" },\n          uTime: { value: options.time, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    __publicField(this, \"seed\");\n    /**\n     * Opacity/intensity of the noise effect between `0` and `1`\n     * @default 0.3\n     */\n    __publicField(this, \"time\");\n    this.uniforms = this.resources.crtUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    this.uniforms.uSeed = this.seed;\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Bend of interlaced lines, higher value means more bend\n   * @default 1\n   */\n  get curvature() {\n    return this.uniforms.uLine[0];\n  }\n  set curvature(value) {\n    this.uniforms.uLine[0] = value;\n  }\n  /**\n   * Width of interlaced lines\n   * @default 1\n   */\n  get lineWidth() {\n    return this.uniforms.uLine[1];\n  }\n  set lineWidth(value) {\n    this.uniforms.uLine[1] = value;\n  }\n  /**\n   * Contrast of interlaced lines\n   * @default 0.25\n   */\n  get lineContrast() {\n    return this.uniforms.uLine[2];\n  }\n  set lineContrast(value) {\n    this.uniforms.uLine[2] = value;\n  }\n  /**\n   * The orientation of the line:\n   *\n   * `true` create vertical lines, `false` creates horizontal lines\n   * @default false\n   */\n  get verticalLine() {\n    return this.uniforms.uLine[3] > 0.5;\n  }\n  set verticalLine(value) {\n    this.uniforms.uLine[3] = value ? 1 : 0;\n  }\n  /**\n   * Opacity/intensity of the noise effect between `0` and `1`\n   * @default 0.3\n   */\n  get noise() {\n    return this.uniforms.uNoise[0];\n  }\n  set noise(value) {\n    this.uniforms.uNoise[0] = value;\n  }\n  /**\n   * The size of the noise particles\n   * @default 0\n   */\n  get noiseSize() {\n    return this.uniforms.uNoise[1];\n  }\n  set noiseSize(value) {\n    this.uniforms.uNoise[1] = value;\n  }\n  /**\n   * The radius of the vignette effect, smaller values produces a smaller vignette\n   * @default 0.3\n   */\n  get vignetting() {\n    return this.uniforms.uVignette[0];\n  }\n  set vignetting(value) {\n    this.uniforms.uVignette[0] = value;\n  }\n  /**\n   * Amount of opacity of vignette\n   * @default 1\n   */\n  get vignettingAlpha() {\n    return this.uniforms.uVignette[1];\n  }\n  set vignettingAlpha(value) {\n    this.uniforms.uVignette[1] = value;\n  }\n  /**\n   * Blur intensity of the vignette\n   * @default 0.3\n   */\n  get vignettingBlur() {\n    return this.uniforms.uVignette[2];\n  }\n  set vignettingBlur(value) {\n    this.uniforms.uVignette[2] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_CRTFilter, \"DEFAULT_OPTIONS\", {\n  curvature: 1,\n  lineWidth: 1,\n  lineContrast: 0.25,\n  verticalLine: false,\n  noise: 0,\n  noiseSize: 1,\n  vignetting: 0.3,\n  vignettingAlpha: 1,\n  vignettingBlur: 0.3,\n  time: 0,\n  seed: 0\n});\nlet CRTFilter = _CRTFilter;\n\nexport { CRTFilter };\n//# sourceMappingURL=CRTFilter.mjs.map\n","var source = \"struct CRTUniforms {\\n    uLine: vec4<f32>,\\n    uNoise: vec2<f32>,\\n    uVignette: vec3<f32>,\\n    uSeed: f32,\\n    uTime: f32,\\n    uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    \\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\\n\\n  let uNoise = crtUniforms.uNoise;\\n\\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n  {\\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\\n  }\\n\\n  if (crtUniforms.uVignette[0] > 0.)\\n  {\\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\\n  }\\n\\n  if (crtUniforms.uLine[1] > 0.0)\\n  {\\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \\n  }\\n\\n  return color;\\n}\\n\\nconst SQRT_2: f32 = 1.414213;\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn rand(co: vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\\n{\\n  let uVignette = crtUniforms.uVignette;\\n  let uDimensions = crtUniforms.uDimensions;\\n  \\n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\\n  dir.y *= uDimensions.y / uDimensions.x;\\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\\n}\\n\\nfn noise(coord: vec2<f32>) -> f32\\n{\\n  let uNoise = crtUniforms.uNoise;\\n  let uSeed = crtUniforms.uSeed;\\n\\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\\n\\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\\n{\\n  var color = co;\\n\\n  let uDimensions = crtUniforms.uDimensions;\\n\\n  let curvature: f32 = crtUniforms.uLine[0];\\n  let lineWidth: f32 = crtUniforms.uLine[1];\\n  let lineContrast: f32 = crtUniforms.uLine[2];\\n  let verticalLine: f32 = crtUniforms.uLine[3];\\n\\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\\n\\n  let _c: f32 = select(1., curvature, curvature > 0.);\\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\\n  let uv: vec2<f32> = dir * k;\\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\\n  color *= j;\\n\\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\\n  color *= 0.99 + ceil(segment) * 0.015;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=crt.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uAngle;\\nuniform float uScale;\\nuniform bool uGrayScale;\\n\\nuniform vec4 uInputSize;\\n\\nfloat pattern()\\n{\\n    float s = sin(uAngle), c = cos(uAngle);\\n    vec2 tex = vTextureCoord * uInputSize.xy;\\n    vec2 point = vec2(\\n        c * tex.x - s * tex.y,\\n        s * tex.x + c * tex.y\\n    ) * uScale;\\n    return (sin(point.x) * sin(point.y)) * 4.0;\\n    }\\n\\n    void main()\\n    {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    vec3 colorRGB = vec3(color);\\n\\n    if (uGrayScale)\\n    {\\n        colorRGB = vec3(color.r + color.g + color.b) / 3.0;\\n    }\\n\\n    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=dot.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './dot.mjs';\nimport source from './dot2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _DotFilter = class _DotFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"DotFilter constructor params are now options object. See params: { scale, angle, grayscale }\");\n      options = { scale: options };\n      if (args[1] !== void 0)\n        options.angle = args[1];\n      if (args[2] !== void 0)\n        options.grayscale = args[2];\n    }\n    options = { ..._DotFilter.DEFAULT_OPTIONS, ...options };\n    const dotUniforms = {\n      uScale: { value: options.scale, type: \"f32\" },\n      uAngle: { value: options.angle, type: \"f32\" },\n      uGrayScale: { value: options.grayscale ? 1 : 0, type: \"f32\" }\n    };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"dot-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        dotUniforms\n      }\n    });\n  }\n  /**\n   * The scale of the effect.\n   * @default 1\n   */\n  get scale() {\n    return this.resources.dotUniforms.uniforms.uScale;\n  }\n  set scale(value) {\n    this.resources.dotUniforms.uniforms.uScale = value;\n  }\n  /**\n  * The radius of the effect.\n  * @default 5\n  */\n  get angle() {\n    return this.resources.dotUniforms.uniforms.uAngle;\n  }\n  set angle(value) {\n    this.resources.dotUniforms.uniforms.uAngle = value;\n  }\n  /**\n  * Whether to rendering it in gray scale.\n  * @default true\n  */\n  get grayscale() {\n    return this.resources.dotUniforms.uniforms.uGrayScale === 1;\n  }\n  set grayscale(value) {\n    this.resources.dotUniforms.uniforms.uGrayScale = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_DotFilter, \"DEFAULT_OPTIONS\", {\n  scale: 1,\n  angle: 5,\n  grayscale: true\n});\nlet DotFilter = _DotFilter;\n\nexport { DotFilter };\n//# sourceMappingURL=DotFilter.mjs.map\n","var source = \"struct DotUniforms {\\n  uScale:f32,\\n  uAngle:f32,\\n  uGrayScale:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \\n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\\n\\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\\n}\\n\\nfn pattern(uv: vec2<f32>) -> f32\\n{\\n  let s: f32 = sin(dotUniforms.uAngle);\\n  let c: f32 = cos(dotUniforms.uAngle);\\n  \\n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\\n  \\n  let p: vec2<f32> = vec2<f32>(\\n      c * tex.x - s * tex.y,\\n      s * tex.x + c * tex.y\\n  ) * dotUniforms.uScale;\\n\\n  return (sin(p.x) * sin(p.y)) * 4.0;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=dot2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uAlpha;\\nuniform vec3 uColor;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void){\\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\\n\\n    // Premultiply alpha\\n    sample.rgb = uColor.rgb * sample.a;\\n\\n    // alpha user alpha\\n    sample *= uAlpha;\\n\\n    finalColor = sample;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=drop-shadow.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color, TexturePool } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter.mjs';\nimport fragment from './drop-shadow.mjs';\nimport source from './drop-shadow2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _DropShadowFilter = class _DropShadowFilter extends Filter {\n  /**\n   * @param options - Options for the DropShadowFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._DropShadowFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"drop-shadow-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        dropShadowUniforms: {\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uOffset: { value: options.offset, type: \"vec2<f32>\" }\n        }\n      },\n      resolution: options.resolution\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * Hide the contents, only show the shadow.\n     * @default false\n     */\n    __publicField(this, \"shadowOnly\", false);\n    __publicField(this, \"_color\");\n    __publicField(this, \"_blurFilter\");\n    __publicField(this, \"_basePass\");\n    this.uniforms = this.resources.dropShadowUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 0;\n    this._blurFilter = new KawaseBlurFilter({\n      strength: options.kernels ?? options.blur,\n      quality: options.kernels ? void 0 : options.quality\n    });\n    this._basePass = new Filter({\n      gpuProgram: GpuProgram.from({\n        vertex: {\n          source: wgslVertex,\n          entryPoint: \"mainVertex\"\n        },\n        fragment: {\n          source: `\n                    @group(0) @binding(1) var uTexture: texture_2d<f32>; \n                    @group(0) @binding(2) var uSampler: sampler;\n                    @fragment\n                    fn mainFragment(\n                        @builtin(position) position: vec4<f32>,\n                        @location(0) uv : vec2<f32>\n                    ) -> @location(0) vec4<f32> {\n                        return textureSample(uTexture, uSampler, uv);\n                    }\n                    `,\n          entryPoint: \"mainFragment\"\n        }\n      }),\n      glProgram: GlProgram.from({\n        vertex,\n        fragment: `\n                in vec2 vTextureCoord;\n                out vec4 finalColor;\n                uniform sampler2D uTexture;\n\n                void main(void){\n                    finalColor = texture(uTexture, vTextureCoord);\n                }\n                `,\n        name: \"drop-shadow-filter\"\n      }),\n      resources: {}\n    });\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const renderTarget = TexturePool.getSameSizeTexture(input);\n    filterManager.applyFilter(this, input, renderTarget, true);\n    this._blurFilter.apply(filterManager, renderTarget, output, clearMode);\n    if (!this.shadowOnly) {\n      filterManager.applyFilter(this._basePass, input, output, false);\n    }\n    TexturePool.returnTexture(renderTarget);\n  }\n  /**\n   * Set the offset position of the drop-shadow relative to the original image.\n   * @default [4,4]\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n    this._updatePadding();\n  }\n  /**\n   * Set the offset position of the drop-shadow relative to the original image on the `x` axis\n   * @default 4\n   */\n  get offsetX() {\n    return this.offset.x;\n  }\n  set offsetX(value) {\n    this.offset.x = value;\n    this._updatePadding();\n  }\n  /**\n   * Set the offset position of the drop-shadow relative to the original image on the `y` axis\n   * @default 4\n   */\n  get offsetY() {\n    return this.offset.y;\n  }\n  set offsetY(value) {\n    this.offset.y = value;\n    this._updatePadding();\n  }\n  /**\n   * The color value of shadow.\n   * @example [0.0, 0.0, 0.0] = 0x000000\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n   * The strength of the shadow's blur.\n   * @default 2\n   */\n  get blur() {\n    return this._blurFilter.strength;\n  }\n  set blur(value) {\n    this._blurFilter.strength = value;\n    this._updatePadding();\n  }\n  /**\n   * Sets the quality of the Blur Filter\n   * @default 4\n   */\n  get quality() {\n    return this._blurFilter.quality;\n  }\n  set quality(value) {\n    this._blurFilter.quality = value;\n    this._updatePadding();\n  }\n  /** Sets the kernels of the Blur Filter */\n  get kernels() {\n    return this._blurFilter.kernels;\n  }\n  set kernels(value) {\n    this._blurFilter.kernels = value;\n  }\n  /**\n   * Sets the pixelSize of the Kawase Blur filter\n   * @default [1,1]\n   */\n  get pixelSize() {\n    return this._blurFilter.pixelSize;\n  }\n  set pixelSize(value) {\n    if (typeof value === \"number\") {\n      value = { x: value, y: value };\n    }\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this._blurFilter.pixelSize = value;\n  }\n  /**\n   * Sets the pixelSize of the Kawase Blur filter on the `x` axis\n   * @default 1\n   */\n  get pixelSizeX() {\n    return this._blurFilter.pixelSizeX;\n  }\n  set pixelSizeX(value) {\n    this._blurFilter.pixelSizeX = value;\n  }\n  /**\n   * Sets the pixelSize of the Kawase Blur filter on the `y` axis\n   * @default 1\n   */\n  get pixelSizeY() {\n    return this._blurFilter.pixelSizeY;\n  }\n  set pixelSizeY(value) {\n    this._blurFilter.pixelSizeY = value;\n  }\n  /**\n   * Recalculate the proper padding amount.\n   * @private\n   */\n  _updatePadding() {\n    const offsetPadding = Math.max(\n      Math.abs(this.offsetX),\n      Math.abs(this.offsetY)\n    );\n    this.padding = offsetPadding + this.blur * 2 + this.quality * 4;\n  }\n};\n/** Default values for options. */\n__publicField(_DropShadowFilter, \"DEFAULT_OPTIONS\", {\n  offset: { x: 4, y: 4 },\n  color: 0,\n  alpha: 0.5,\n  shadowOnly: false,\n  kernels: void 0,\n  blur: 2,\n  quality: 3,\n  pixelSize: { x: 1, y: 1 },\n  resolution: 1\n});\nlet DropShadowFilter = _DropShadowFilter;\n\nexport { DropShadowFilter };\n//# sourceMappingURL=DropShadowFilter.mjs.map\n","var source = \"struct DropShadowUniforms {\\n  uAlpha: f32,\\n  uColor: vec3<f32>,\\n  uOffset: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\\n\\n  // Premultiply alpha\\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\\n  // alpha user alpha\\n  color *= dropShadowUniforms.uAlpha;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=drop-shadow2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main(void)\\n{\\n\\tvec2 onePixel = vec2(1.0 / uInputSize);\\n\\n\\tvec4 color;\\n\\n\\tcolor.rgb = vec3(0.5);\\n\\n\\tcolor -= texture(uTexture, vTextureCoord - onePixel) * uStrength;\\n\\tcolor += texture(uTexture, vTextureCoord + onePixel) * uStrength;\\n\\n\\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\\n\\n\\tfloat alpha = texture(uTexture, vTextureCoord).a;\\n\\n\\tfinalColor = vec4(color.rgb * alpha, alpha);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=emboss2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './emboss2.mjs';\nimport source from './emboss.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EmbossFilter extends Filter {\n  /**\n   * @param {number} [strength=5] - Strength of the emboss.\n   */\n  constructor(strength = 5) {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"emboss-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        embossUniforms: {\n          uStrength: { value: strength, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.embossUniforms.uniforms;\n  }\n  /**\n   * Strength of the emboss\n   * @default 5\n   */\n  get strength() {\n    return this.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.uniforms.uStrength = value;\n  }\n}\n\nexport { EmbossFilter };\n//# sourceMappingURL=EmbossFilter.mjs.map\n","var source = \"struct EmbossUniforms {\\n  uStrength:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> embossUniforms : EmbossUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let onePixel: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\tvar color: vec3<f32> = vec3<f32>(0.5);\\n\\n\\tcolor -= (textureSample(uTexture, uSampler, uv - onePixel) * embossUniforms.uStrength).rgb;\\n\\tcolor += (textureSample(uTexture, uSampler, uv + onePixel) * embossUniforms.uStrength).rgb;\\n\\n\\tcolor = vec3<f32>((color.r + color.g + color.b) / 3.0);\\n\\n\\tlet blendColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n\\treturn vec4<f32>(color.rgb * blendColor.a, blendColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=emboss.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uDisplacementMap;\\nuniform float uSeed;\\nuniform vec2 uDimensions;\\nuniform float uAspect;\\nuniform float uFillMode;\\nuniform float uOffset;\\nuniform float uDirection;\\nuniform vec2 uRed;\\nuniform vec2 uGreen;\\nuniform vec2 uBlue;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst int TRANSPARENT = 0;\\nconst int ORIGINAL = 1;\\nconst int LOOP = 2;\\nconst int CLAMP = 3;\\nconst int MIRROR = 4;\\n\\nvoid main(void)\\n{\\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n        return;\\n    }\\n\\n    float sinDir = sin(uDirection);\\n    float cosDir = cos(uDirection);\\n\\n    float cx = coord.x - 0.5;\\n    float cy = (coord.y - 0.5) * uAspect;\\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\\n\\n    // displacementMap: repeat\\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\\n\\n    // displacementMap: mirror\\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\\n\\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\\n\\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\\n\\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\\n\\n    int fillMode = int(uFillMode);\\n\\n    if (fillMode == CLAMP) {\\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    } else {\\n        if( coord.x > uInputClamp.z ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x -= uInputClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x = uInputClamp.z * 2.0 - coord.x;\\n            }\\n        } else if( coord.x < uInputClamp.x ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x += uInputClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x *= -uInputClamp.z;\\n            }\\n        }\\n\\n        if( coord.y > uInputClamp.w ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y -= uInputClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y = uInputClamp.w * 2.0 - coord.y;\\n            }\\n        } else if( coord.y < uInputClamp.y ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y += uInputClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y *= -uInputClamp.w;\\n            }\\n        }\\n    }\\n\\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\\n    finalColor.a = texture(uTexture, coord).a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glitch2.mjs.map\n","import { Filter, GpuProgram, GlProgram, Texture, ImageSource, DEG_TO_RAD } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './glitch2.mjs';\nimport source from './glitch.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GlitchFilter = class _GlitchFilter extends Filter {\n  /**\n   * @param options - Options for the GlitchFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GlitchFilter.defaults, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"glitch-filter\"\n    });\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 4;\n    canvas.height = options.sampleSize ?? 512;\n    const texture = new Texture({\n      source: new ImageSource({ resource: canvas })\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        glitchUniforms: {\n          uSeed: { value: options?.seed ?? 0, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uAspect: { value: 1, type: \"f32\" },\n          uFillMode: { value: options?.fillMode ?? 0, type: \"f32\" },\n          uOffset: { value: options?.offset ?? 100, type: \"f32\" },\n          uDirection: { value: options?.direction ?? 0, type: \"f32\" },\n          uRed: { value: options.red, type: \"vec2<f32>\" },\n          uGreen: { value: options.green, type: \"vec2<f32>\" },\n          uBlue: { value: options.blue, type: \"vec2<f32>\" }\n        },\n        uDisplacementMap: texture.source,\n        uDisplacementSampler: texture.source.style\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     */\n    __publicField(this, \"average\", false);\n    /** Minimum size of slices as a portion of the `sampleSize` */\n    __publicField(this, \"minSize\", 8);\n    /** Height of the displacement map canvas. */\n    __publicField(this, \"sampleSize\", 512);\n    /** Internally generated canvas. */\n    __publicField(this, \"_canvas\");\n    /**\n     * The displacement map is used to generate the bands.\n     * If using your own texture, `slices` will be ignored.\n     *\n     * @member {Texture}\n     * @readonly\n     */\n    __publicField(this, \"texture\");\n    /** Internal number of slices */\n    __publicField(this, \"_slices\", 0);\n    __publicField(this, \"_sizes\", new Float32Array(1));\n    __publicField(this, \"_offsets\", new Float32Array(1));\n    this.uniforms = this.resources.glitchUniforms.uniforms;\n    this._canvas = canvas;\n    this.texture = texture;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in Filter\n   * @private\n   */\n  apply(filterManager, input, output, clearMode) {\n    const { width, height } = input.frame;\n    this.uniforms.uDimensions[0] = width;\n    this.uniforms.uDimensions[1] = height;\n    this.uniforms.uAspect = height / width;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Randomize the slices size (heights).\n   *\n   * @private\n   */\n  _randomizeSizes() {\n    const arr = this._sizes;\n    const last = this._slices - 1;\n    const size = this.sampleSize;\n    const min = Math.min(this.minSize / size, 0.9 / this._slices);\n    if (this.average) {\n      const count = this._slices;\n      let rest = 1;\n      for (let i = 0; i < last; i++) {\n        const averageWidth = rest / (count - i);\n        const w = Math.max(averageWidth * (1 - Math.random() * 0.6), min);\n        arr[i] = w;\n        rest -= w;\n      }\n      arr[last] = rest;\n    } else {\n      let rest = 1;\n      const ratio = Math.sqrt(1 / this._slices);\n      for (let i = 0; i < last; i++) {\n        const w = Math.max(ratio * rest * Math.random(), min);\n        arr[i] = w;\n        rest -= w;\n      }\n      arr[last] = rest;\n    }\n    this.shuffle();\n  }\n  /**\n   * Shuffle the sizes of the slices, advanced usage.\n   */\n  shuffle() {\n    const arr = this._sizes;\n    const last = this._slices - 1;\n    for (let i = last; i > 0; i--) {\n      const rand = Math.random() * i >> 0;\n      const temp = arr[i];\n      arr[i] = arr[rand];\n      arr[rand] = temp;\n    }\n  }\n  /**\n   * Randomize the values for offset from -1 to 1\n   *\n   * @private\n   */\n  _randomizeOffsets() {\n    for (let i = 0; i < this._slices; i++) {\n      this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);\n    }\n  }\n  /**\n   * Regenerating random size, offsets for slices.\n   */\n  refresh() {\n    this._randomizeSizes();\n    this._randomizeOffsets();\n    this.redraw();\n  }\n  /**\n   * Redraw displacement bitmap texture, advanced usage.\n   */\n  redraw() {\n    const size = this.sampleSize;\n    const texture = this.texture;\n    const ctx = this._canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, 8, size);\n    let offset;\n    let y = 0;\n    for (let i = 0; i < this._slices; i++) {\n      offset = Math.floor(this._offsets[i] * 256);\n      const height = this._sizes[i] * size;\n      const red = offset > 0 ? offset : 0;\n      const green = offset < 0 ? -offset : 0;\n      ctx.fillStyle = `rgba(${red}, ${green}, 0, 1)`;\n      ctx.fillRect(0, y >> 0, size, height + 1 >> 0);\n      y += height;\n    }\n    texture.source.update();\n  }\n  /**\n   * Manually custom slices size (height) of displacement bitmap\n   *\n   * @member {number[]|Float32Array}\n   */\n  set sizes(sizes) {\n    const len = Math.min(this._slices, sizes.length);\n    for (let i = 0; i < len; i++) {\n      this._sizes[i] = sizes[i];\n    }\n  }\n  get sizes() {\n    return this._sizes;\n  }\n  /**\n   * Manually set custom slices offset of displacement bitmap, this is\n   * a collection of values from -1 to 1. To change the max offset value\n   * set `offset`.\n   *\n   * @member {number[]|Float32Array}\n   */\n  set offsets(offsets) {\n    const len = Math.min(this._slices, offsets.length);\n    for (let i = 0; i < len; i++) {\n      this._offsets[i] = offsets[i];\n    }\n  }\n  get offsets() {\n    return this._offsets;\n  }\n  /**\n   * The count of slices.\n   * @default 5\n   */\n  get slices() {\n    return this._slices;\n  }\n  set slices(value) {\n    if (this._slices === value)\n      return;\n    this._slices = value;\n    this._sizes = new Float32Array(value);\n    this._offsets = new Float32Array(value);\n    this.refresh();\n  }\n  /**\n   * The maximum offset amount of slices.\n   * @default 100\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n  }\n  /**\n   * A seed value for randomizing glitch effect.\n   * @default 0\n   */\n  get seed() {\n    return this.uniforms.uSeed;\n  }\n  set seed(value) {\n    this.uniforms.uSeed = value;\n  }\n  /**\n   * The fill mode of the space after the offset.\n   * @default FILL_MODES.TRANSPARENT\n   */\n  get fillMode() {\n    return this.uniforms.uFillMode;\n  }\n  set fillMode(value) {\n    this.uniforms.uFillMode = value;\n  }\n  /**\n   * The angle in degree of the offset of slices.\n   * @default 0\n   */\n  get direction() {\n    return this.uniforms.uDirection / DEG_TO_RAD;\n  }\n  set direction(value) {\n    this.uniforms.uDirection = value * DEG_TO_RAD;\n  }\n  /**\n   * Red channel offset.\n   * @default {x:0,y:0}\n   */\n  get red() {\n    return this.uniforms.uRed;\n  }\n  set red(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uRed = value;\n  }\n  /**\n   * Green channel offset.\n   * @default {x:0,y:0}\n   */\n  get green() {\n    return this.uniforms.uGreen;\n  }\n  set green(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uGreen = value;\n  }\n  /**\n   * Blue offset.\n   * @default {x:0,y:0}\n   */\n  get blue() {\n    return this.uniforms.uBlue;\n  }\n  set blue(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uBlue = value;\n  }\n  /**\n   * Removes all references\n   */\n  destroy() {\n    this.texture?.destroy(true);\n    this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;\n  }\n};\n/** Default constructor options. */\n__publicField(_GlitchFilter, \"defaults\", {\n  slices: 5,\n  offset: 100,\n  direction: 0,\n  fillMode: 0,\n  average: false,\n  seed: 0,\n  red: { x: 0, y: 0 },\n  green: { x: 0, y: 0 },\n  blue: { x: 0, y: 0 },\n  minSize: 8,\n  sampleSize: 512\n});\nlet GlitchFilter = _GlitchFilter;\n\nexport { GlitchFilter };\n//# sourceMappingURL=GlitchFilter.mjs.map\n","var source = \"struct GlitchUniforms {\\n  uSeed: f32,\\n  uDimensions: vec2<f32>,\\n  uAspect: f32,\\n  uFillMode: f32,\\n  uOffset: f32,\\n  uDirection: f32,\\n  uRed: vec2<f32>,\\n  uGreen: vec2<f32>,\\n  uBlue: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;\\n@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; \\n@group(1) @binding(2) var uDisplacementSampler: sampler; \\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uSeed: f32 = glitchUniforms.uSeed;\\n  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;\\n  let uAspect: f32 = glitchUniforms.uAspect;\\n  let uOffset: f32 = glitchUniforms.uOffset;\\n  let uDirection: f32 = glitchUniforms.uDirection;\\n  let uRed: vec2<f32> = glitchUniforms.uRed;\\n  let uGreen: vec2<f32> = glitchUniforms.uGreen;\\n  let uBlue: vec2<f32> = glitchUniforms.uBlue;\\n\\n  let uInputSize: vec4<f32> = gfu.uInputSize;\\n  let uInputClamp: vec4<f32> = gfu.uInputClamp;\\n\\n  var discarded: bool = false;\\n  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n      discarded = true;\\n    }\\n\\n    let sinDir: f32 = sin(uDirection);\\n    let cosDir: f32 = cos(uDirection);\\n\\n    let cx: f32 = coord.x - 0.5;\\n    let cy: f32 = (coord.y - 0.5) * uAspect;\\n    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\\n\\n    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);\\n\\n    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));\\n\\n    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);\\n\\n    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);\\n\\n    let fillMode: i32 = i32(glitchUniforms.uFillMode);\\n\\n    if (fillMode == CLAMP) {\\n      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    } else {\\n      if (coord.x > uInputClamp.z) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.x = coord.x - uInputClamp.z;\\n        } else if (fillMode == MIRROR) {\\n          coord.x = uInputClamp.z * 2.0 - coord.x;\\n        }\\n      } else if (coord.x < uInputClamp.x) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.x = coord.x + uInputClamp.z;\\n        } else if (fillMode == MIRROR) {\\n          coord.x = coord.x * -uInputClamp.z;\\n        }\\n      }\\n\\n      if (coord.y > uInputClamp.w) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.y = coord.y - uInputClamp.w;\\n        } else if (fillMode == MIRROR) {\\n          coord.y = uInputClamp.w * 2.0 - coord.y;\\n        }\\n      } else if (coord.y < uInputClamp.y) {\\n        if (fillMode == TRANSPARENT) {\\n          discarded = true;\\n        } else if (fillMode == LOOP) {\\n          coord.y = coord.y + uInputClamp.w;\\n        } else if (fillMode == MIRROR) {\\n          coord.y = coord.y * -uInputClamp.w;\\n        }\\n      }\\n    }\\n\\n    let seedR: f32 = 1.0 - uSeed * 0.4;\\n    let seedG: f32 = 1.0 - uSeed * 0.3;\\n    let seedB: f32 = 1.0 - uSeed * 0.2;\\n\\n    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);\\n    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);\\n    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);\\n\\n    let r = textureSample(uTexture, uSampler, coord + offsetR).r;\\n    let g = textureSample(uTexture, uSampler, coord + offsetG).g;\\n    let b = textureSample(uTexture, uSampler, coord + offsetB).b;\\n    let a = textureSample(uTexture, uSampler, coord).a;\\n\\n    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);\\n}\\n\\nconst TRANSPARENT: i32 = 0;\\nconst ORIGINAL: i32 = 1;\\nconst LOOP: i32 = 2;\\nconst CLAMP: i32 = 3;\\nconst MIRROR: i32 = 4;\";\n\nexport { source as default };\n//# sourceMappingURL=glitch.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uStrength;\\nuniform vec3 uColor;\\nuniform float uKnockout;\\nuniform float uAlpha;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159265358979323846264;\\n\\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\\nconst float DIST = __DIST__;\\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\\n\\nvoid main(void) {\\n    vec2 px = vec2(1.) / uInputSize.xy;\\n\\n    float totalAlpha = 0.;\\n\\n    vec2 direction;\\n    vec2 displaced;\\n    vec4 curColor;\\n\\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\\n      direction = vec2(cos(angle), sin(angle)) * px;\\n\\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\\n          curColor = texture(uTexture, displaced);\\n          totalAlpha += (DIST - curDistance) * curColor.a;\\n      }\\n    }\\n    \\n    curColor = texture(uTexture, vTextureCoord);\\n\\n    vec4 glowColor = vec4(uColor, uAlpha);\\n    bool knockout = uKnockout > .5;\\n    float innerStrength = uStrength[0];\\n    float outerStrength = uStrength[1];\\n\\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\\n    float innerGlowStrength = min(1., innerGlowAlpha);\\n    \\n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\\n\\n    if (knockout) {\\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\\n    }\\n    else {\\n      finalColor = innerColor + outerGlowColor;\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=glow.mjs.map\n","import { Filter, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './glow.mjs';\nimport source from './glow2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GlowFilter = class _GlowFilter extends Filter {\n  /**\n   * @param options - Options for the GlowFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GlowFilter.DEFAULT_OPTIONS, ...options };\n    const distance = options.distance ?? 10;\n    const quality = options.quality ?? 0.1;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / quality / distance).toFixed(7)}`).replace(/__DIST__/gi, `${distance.toFixed(0)}.0`),\n      name: \"glow-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        glowUniforms: {\n          uDistance: { value: distance, type: \"f32\" },\n          uStrength: { value: [options.innerStrength, options.outerStrength], type: \"vec2<f32>\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uQuality: { value: quality, type: \"f32\" },\n          uKnockout: { value: options?.knockout ?? false ? 1 : 0, type: \"f32\" }\n        }\n      },\n      padding: distance\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.glowUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 16777215;\n  }\n  /**\n   * Only draw the glow, not the texture itself\n   * @default false\n   */\n  get distance() {\n    return this.uniforms.uDistance;\n  }\n  set distance(value) {\n    this.uniforms.uDistance = this.padding = value;\n  }\n  /**\n  * The strength of the glow inward from the edge of the sprite.\n  * @default 0\n  */\n  get innerStrength() {\n    return this.uniforms.uStrength[0];\n  }\n  set innerStrength(value) {\n    this.uniforms.uStrength[0] = value;\n  }\n  /**\n  * The strength of the glow outward from the edge of the sprite.\n  * @default 4\n  */\n  get outerStrength() {\n    return this.uniforms.uStrength[1];\n  }\n  set outerStrength(value) {\n    this.uniforms.uStrength[1] = value;\n  }\n  /**\n  * The color of the glow.\n  * @default 0xFFFFFF\n  */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n  * The alpha of the glow\n  * @default 1\n  */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n  * A number between 0 and 1 that describes the quality of the glow. The higher the number the less performant\n  * @default 0.1\n  */\n  get quality() {\n    return this.uniforms.uQuality;\n  }\n  set quality(value) {\n    this.uniforms.uQuality = value;\n  }\n  /**\n  * Only draw the glow, not the texture itself\n  * @default false\n  */\n  get knockout() {\n    return this.uniforms.uKnockout === 1;\n  }\n  set knockout(value) {\n    this.uniforms.uKnockout = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_GlowFilter, \"DEFAULT_OPTIONS\", {\n  distance: 10,\n  outerStrength: 4,\n  innerStrength: 0,\n  color: 16777215,\n  alpha: 1,\n  quality: 0.1,\n  knockout: false\n});\nlet GlowFilter = _GlowFilter;\n\nexport { GlowFilter };\n//# sourceMappingURL=GlowFilter.mjs.map\n","var source = \"struct GlowUniforms {\\n  uDistance: f32,\\n  uStrength: vec2<f32>,\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uQuality: f32,\\n  uKnockout: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let quality = glowUniforms.uQuality;\\n  let distance = glowUniforms.uDistance;\\n\\n  let dist: f32 = glowUniforms.uDistance;\\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\\n\\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\\n\\n  var totalAlpha: f32 = 0.0;\\n\\n  var direction: vec2<f32>;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n      curColor = textureSample(uTexture, uSampler, displaced);\\n      totalAlpha += (dist - curDistance) * curColor.a;\\n    }\\n  }\\n    \\n  curColor = textureSample(uTexture, uSampler, uv);\\n\\n  let glowColorRGB = glowUniforms.uColor;\\n  let glowAlpha = glowUniforms.uAlpha;\\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\\n  let innerStrength = glowUniforms.uStrength[0];\\n  let outerStrength = glowUniforms.uStrength[1];\\n\\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\\n  \\n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\\n  \\n  if (knockout) {\\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\\n  }\\n  else {\\n    return innerColor + outerGlowColor;\\n  }\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\";\n\nexport { source as default };\n//# sourceMappingURL=glow2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uDimensions;\\nuniform float uParallel;\\nuniform vec2 uLight;\\nuniform float uAspect;\\nuniform float uTime;\\nuniform vec3 uRay;\\n\\nuniform vec4 uInputSize;\\n\\n${PERLIN}\\n\\nvoid main(void) {\\n    vec2 uDimensions = uDimensions;\\n    bool uParallel = uParallel > 0.5;\\n    vec2 uLight = uLight;\\n    float uAspect = uAspect;\\n\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\\n\\n    float d;\\n\\n    if (uParallel) {\\n        float _cos = uLight.x;\\n        float _sin = uLight.y;\\n        d = (_cos * coord.x) + (_sin * coord.y * uAspect);\\n    } else {\\n        float dx = coord.x - uLight.x / uDimensions.x;\\n        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;\\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\\n        d = dy / dis;\\n    }\\n\\n    float uTime = uTime;\\n    vec3 uRay = uRay;\\n\\n    float gain = uRay[0];\\n    float lacunarity = uRay[1];\\n    float alpha = uRay[2];\\n\\n    vec3 dir = vec3(d, d, 0.0);\\n    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\\n    noise = mix(noise, 0.0, 0.3);\\n    //fade vertically.\\n    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);\\n    mist.a = 1.0;\\n    // apply user alpha\\n    mist *= alpha;\\n\\n    finalColor = texture(uTexture, vTextureCoord) + mist;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=god-ray2.mjs.map\n","import { Filter, GpuProgram, GlProgram, DEG_TO_RAD } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './god-ray2.mjs';\nimport source from './god-ray.mjs';\nimport perlin from './perlin.mjs';\nimport sourcePerlin from './perlin2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _GodrayFilter = class _GodrayFilter extends Filter {\n  /**\n   * @param options - Options for the GodrayFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._GodrayFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: source.replace(\"${PERLIN}\", sourcePerlin),\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(\"${PERLIN}\", perlin),\n      name: \"god-ray-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        godrayUniforms: {\n          uLight: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uParallel: { value: 0, type: \"f32\" },\n          uAspect: { value: 0, type: \"f32\" },\n          uTime: { value: options.time, type: \"f32\" },\n          uRay: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * The current time position\n     * @default 0\n     */\n    __publicField(this, \"time\", 0);\n    __publicField(this, \"_angleLight\", [0, 0]);\n    __publicField(this, \"_angle\", 0);\n    __publicField(this, \"_center\");\n    this.uniforms = this.resources.godrayUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in Filter\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const width = input.frame.width;\n    const height = input.frame.height;\n    this.uniforms.uLight[0] = this.parallel ? this._angleLight[0] : this._center.x;\n    this.uniforms.uLight[1] = this.parallel ? this._angleLight[1] : this._center.y;\n    this.uniforms.uDimensions[0] = width;\n    this.uniforms.uDimensions[1] = height;\n    this.uniforms.uAspect = height / width;\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The angle/light-source of the rays in degrees. For instance,\n   * a value of 0 is vertical rays, values of 90 or -90 produce horizontal rays\n   * @default 30\n   */\n  get angle() {\n    return this._angle;\n  }\n  set angle(value) {\n    this._angle = value;\n    const radians = value * DEG_TO_RAD;\n    this._angleLight[0] = Math.cos(radians);\n    this._angleLight[1] = Math.sin(radians);\n  }\n  /**\n   * `true` if light rays are parallel (uses angle), `false` to use the focal `center` point\n   * @default true\n   */\n  get parallel() {\n    return this.uniforms.uParallel > 0.5;\n  }\n  set parallel(value) {\n    this.uniforms.uParallel = value ? 1 : 0;\n  }\n  /**\n   * Focal point for non-parallel rays, to use this `parallel` must be set to `false`.\n   * @default {x:0,y:0}\n   */\n  get center() {\n    return this._center;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this._center = value;\n  }\n  /**\n   * Focal point for non-parallel rays on the `x` axis, to use this `parallel` must be set to `false`.\n   * @default 0\n   */\n  get centerX() {\n    return this.center.x;\n  }\n  set centerX(value) {\n    this.center.x = value;\n  }\n  /**\n   * Focal point for non-parallel rays on the `y` axis, to use this `parallel` must be set to `false`.\n   * @default 0\n   */\n  get centerY() {\n    return this.center.y;\n  }\n  set centerY(value) {\n    this.center.y = value;\n  }\n  /**\n   * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n   * where a value closer to 0 will produce a subtler effect\n   * @default 0.5\n   */\n  get gain() {\n    return this.uniforms.uRay[0];\n  }\n  set gain(value) {\n    this.uniforms.uRay[0] = value;\n  }\n  /**\n   * The density of the fractal noise.\n   * A higher amount produces more rays and a smaller amount produces fewer waves\n   * @default 2.5\n   */\n  get lacunarity() {\n    return this.uniforms.uRay[1];\n  }\n  set lacunarity(value) {\n    this.uniforms.uRay[1] = value;\n  }\n  /**\n   * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uRay[2];\n  }\n  set alpha(value) {\n    this.uniforms.uRay[2] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_GodrayFilter, \"DEFAULT_OPTIONS\", {\n  angle: 30,\n  gain: 0.5,\n  lacunarity: 2.5,\n  parallel: true,\n  time: 0,\n  center: { x: 0, y: 0 },\n  alpha: 1\n});\nlet GodrayFilter = _GodrayFilter;\n\nexport { GodrayFilter };\n//# sourceMappingURL=GodrayFilter.mjs.map\n","var source = \"struct GodrayUniforms {\\n  uLight: vec2<f32>,\\n  uParallel: f32,\\n  uAspect: f32,\\n  uTime: f32,\\n  uRay: vec3<f32>,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;\\n  let uParallel: bool = godrayUniforms.uParallel > 0.5;\\n  let uLight: vec2<f32> = godrayUniforms.uLight;\\n  let uAspect: f32 = godrayUniforms.uAspect;\\n\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;\\n\\n  var d: f32;\\n\\n  if (uParallel) {\\n    let _cos: f32 = uLight.x;\\n    let _sin: f32 = uLight.y;\\n    d = (_cos * coord.x) + (_sin * coord.y * uAspect);\\n  } else {\\n    let dx: f32 = coord.x - uLight.x / uDimensions.x;\\n    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;\\n    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;\\n    d = dy / dis;\\n  }\\n\\n  let uTime: f32 = godrayUniforms.uTime;\\n  let uRay: vec3<f32> = godrayUniforms.uRay;\\n  \\n  let gain = uRay[0];\\n  let lacunarity = uRay[1];\\n  let alpha = uRay[2];\\n\\n  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);\\n  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);\\n  noise = mix(noise, 0.0, 0.3);\\n  //fade vertically.\\n  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);\\n  mist.a = 1.0;\\n  // apply user alpha\\n  mist *= alpha;\\n  return textureSample(uTexture, uSampler, uv) + mist;\\n}\\n\\n${PERLIN}\";\n\nexport { source as default };\n//# sourceMappingURL=god-ray.mjs.map\n","var sourcePerlin = \"// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\\n\\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\\n{\\n  return x - y * floor(x/y);\\n}\\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nfn permute4(x: vec4<f32>) -> vec4<f32>\\n{\\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\\n}\\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nfn fade3(t: vec3<f32>) -> vec3<f32>\\n{\\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\\n}\\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\\n\\nfn perlinNoise2(P: vec2<f32>) -> f32 {\\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\\n  let ix = Pi.xzxz;\\n  let iy = Pi.yyww;\\n  let fx = Pf.xzxz;\\n  let fy = Pf.yyww;\\n  let i = permute4(permute4(ix) + iy);\\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\\n  let gy = abs(gx) - 0.5;\\n  let tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\\n  let norm = 1.79284291400159 - 0.85373472095314 *\\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\\n  g00 = g00 * norm.x;\\n  g01 = g01 * norm.y;\\n  g10 = g10 * norm.z;\\n  g11 = g11 * norm.w;\\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\\n  let fade_xy = fade2(Pf.xy);\\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return 2.3 * n_xy;\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\\n{\\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289Vec3(Pi0);\\n    Pi1 = mod289Vec3(Pi1);\\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\\n    let iz0: vec4<f32> = Pi0.zzzz;\\n    let iz1: vec4<f32> = Pi1.zzzz;\\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n    let n000: f32 = dot(g000, Pf0);\\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\\n    let n111: f32 = dot(g111, Pf1);\\n    let fade_xyz: vec3<f32> = fade3(Pf0);\\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n}\\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\\n{\\n    var sum: f32 = 0.0;\\n    var sc: f32 = 1.0;\\n    var totalgain: f32 = 1.0;\\n    for (var i = 0.0; i < 6.0; i += 1)\\n    {\\n        sum += totalgain * perlinNoise3(P * sc, rep);\\n        sc *= lacunarity;\\n        totalgain *= gain;\\n    }\\n    return abs(sum);\\n}\";\n\nexport { sourcePerlin as default };\n//# sourceMappingURL=perlin2.mjs.map\n","var perlin = \"vec3 mod289(vec3 x)\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 mod289(vec4 x)\\n{\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 permute(vec4 x)\\n{\\n    return mod289(((x * 34.0) + 1.0) * x);\\n}\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec3 fade(vec3 t)\\n{\\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\\n}\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec3 P, vec3 rep)\\n{\\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = Pi0.zzzz;\\n    vec4 iz1 = Pi1.zzzz;\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n    vec4 sz0 = step(gz0, vec4(0.0));\\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n    vec4 sz1 = step(gz1, vec4(0.0));\\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n    float n000 = dot(g000, Pf0);\\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n    float n111 = dot(g111, Pf1);\\n    vec3 fade_xyz = fade(Pf0);\\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n}\\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\\n{\\n    float sum = 0.0;\\n    float sc = 1.0;\\n    float totalgain = 1.0;\\n    for (float i = 0.0; i < 6.0; i++)\\n    {\\n        sum += totalgain * pnoise(P * sc, rep);\\n        sc *= lacunarity;\\n        totalgain *= gain;\\n    }\\n    return abs(sum);\\n}\\n\";\n\nexport { perlin as default };\n//# sourceMappingURL=perlin.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './grayscale2.mjs';\nimport source from './grayscale.mjs';\n\nclass GrayscaleFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"grayscale-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {}\n    });\n  }\n}\n\nexport { GrayscaleFilter };\n//# sourceMappingURL=GrayscaleFilter.mjs.map\n","var source = \"@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let g: f32 = dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114));\\n  return vec4<f32>(vec3<f32>(g), 1.);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=grayscale.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\n\\n// https://en.wikipedia.org/wiki/Luma_(video)\\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\\n\\nvoid main()\\n{\\n    vec4 c = texture(uTexture, vTextureCoord);\\n    finalColor = vec4(\\n        vec3(c.r * weight.r + c.g * weight.g  + c.b * weight.b),\\n        c.a\\n    );\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=grayscale2.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uHsl;\\nuniform float uAlpha;\\nuniform float uColorize;\\n\\n// https://en.wikipedia.org/wiki/Luma_(video)\\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\\n\\nfloat getWeightedAverage(vec3 rgb) {\\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\\n}\\n\\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\\n\\nvec3 hueShift(vec3 color, float angle) {\\n    float cosAngle = cos(angle);\\n    return vec3(\\n    color * cosAngle +\\n    cross(k, color) * sin(angle) +\\n    k * dot(k, color) * (1.0 - cosAngle)\\n    );\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    vec3 resultRGB = color.rgb;\\n\\n    float hue = uHsl[0];\\n    float saturation = uHsl[1];\\n    float lightness = uHsl[2];\\n\\n    // colorize\\n    if (uColorize > 0.5) {\\n        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);\\n    }\\n\\n    // hue\\n    resultRGB = hueShift(resultRGB, hue);\\n\\n    // saturation\\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\\n    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\\n\\n    if (saturation > 0.) {\\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\\n    } else {\\n        resultRGB -= (average - resultRGB) * saturation;\\n    }\\n\\n    // lightness\\n    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));\\n\\n    // alpha\\n    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=hsladjustment.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './hsladjustment.mjs';\nimport source from './hsladjustment2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _HslAdjustmentFilter = class _HslAdjustmentFilter extends Filter {\n  /**\n   * @param options - Options for the HslAdjustmentFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._HslAdjustmentFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"hsl-adjustment-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        hslUniforms: {\n          uHsl: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uColorize: { value: options.colorize ? 1 : 0, type: \"f32\" },\n          uAlpha: { value: options.alpha, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_hue\");\n    this.uniforms = this.resources.hslUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * The amount of hue in degrees (-180 to 180)\n   * @default 0\n   */\n  get hue() {\n    return this._hue;\n  }\n  set hue(value) {\n    this._hue = value;\n    this.uniforms.uHsl[0] = value * (Math.PI / 180);\n  }\n  /**\n   * The amount of lightness (-1 to 1)\n   * @default 0\n   */\n  get saturation() {\n    return this.uniforms.uHsl[1];\n  }\n  set saturation(value) {\n    this.uniforms.uHsl[1] = value;\n  }\n  /**\n   * The amount of lightness (-1 to 1)\n   * @default 0\n   */\n  get lightness() {\n    return this.uniforms.uHsl[2];\n  }\n  set lightness(value) {\n    this.uniforms.uHsl[2] = value;\n  }\n  /**\n   * Whether to colorize the image\n   * @default false\n   */\n  get colorize() {\n    return this.uniforms.uColorize === 1;\n  }\n  set colorize(value) {\n    this.uniforms.uColorize = value ? 1 : 0;\n  }\n  /**\n   * The amount of alpha (0 to 1)\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n};\n/** Default values for options. */\n__publicField(_HslAdjustmentFilter, \"DEFAULT_OPTIONS\", {\n  hue: 0,\n  saturation: 0,\n  lightness: 0,\n  colorize: false,\n  alpha: 1\n});\nlet HslAdjustmentFilter = _HslAdjustmentFilter;\n\nexport { HslAdjustmentFilter };\n//# sourceMappingURL=HslAdjustmentFilter.mjs.map\n","var source = \"struct HslUniforms {\\n  uHsl:vec3<f32>,\\n  uColorize:f32,\\n  uAlpha:f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n    var resultRGB: vec3<f32> = color.rgb;\\n\\n    let hue: f32 = hslUniforms.uHsl[0];\\n    let saturation: f32 = hslUniforms.uHsl[1];\\n    let lightness: f32 = hslUniforms.uHsl[2];\\n\\n    // colorize\\n    if (hslUniforms.uColorize > 0.5) {\\n        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);\\n    }\\n\\n    // hue\\n    resultRGB = hueShift(resultRGB, hue);\\n\\n    // saturation\\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\\n    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\\n\\n    if (saturation > 0.) {\\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\\n    } else {\\n        resultRGB -= (average - resultRGB) * saturation;\\n    }\\n\\n    // lightness\\n    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));\\n\\n    // alpha\\n    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);\\n}\\n\\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\\nconst k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);\\n\\nfn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> \\n{\\n    let cosAngle: f32 = cos(angle);\\n    return vec3<f32>(\\n    color * cosAngle +\\n    cross(k, color) * sin(angle) +\\n    k * dot(k, color) * (1.0 - cosAngle)\\n    );\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=hsladjustment2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uVelocity;\\nuniform int uKernelSize;\\nuniform float uOffset;\\n\\nuniform vec4 uInputSize;\\n\\nconst int MAX_KERNEL_SIZE = 2048;\\n\\n// Notice:\\n// the perfect way:\\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\\n// So use uKernelSize directly.\\n\\nvoid main(void)\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    if (uKernelSize == 0)\\n    {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    vec2 velocity = uVelocity / uInputSize.xy;\\n    float offset = -uOffset / length(uVelocity) - 0.5;\\n    int k = uKernelSize - 1;\\n\\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\\n        if (i == k) {\\n            break;\\n        }\\n        vec2 bias = velocity * (float(i) / float(k) + offset);\\n        color += texture(uTexture, vTextureCoord + bias);\\n    }\\n    finalColor = color / float(uKernelSize);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=motion-blur2.mjs.map\n","import { Filter, ObservablePoint, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './motion-blur2.mjs';\nimport source from './motion-blur.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _MotionBlurFilter = class _MotionBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options) || \"x\" in options && \"y\" in options || options instanceof ObservablePoint) {\n      deprecation(\"6.0.0\", \"MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }\");\n      const x = \"x\" in options ? options.x : options[0];\n      const y = \"y\" in options ? options.y : options[1];\n      options = { velocity: { x, y } };\n      if (args[1] !== void 0)\n        options.kernelSize = args[1];\n      if (args[2] !== void 0)\n        options.offset = args[2];\n    }\n    options = { ..._MotionBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"motion-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        motionBlurUniforms: {\n          uVelocity: { value: options.velocity, type: \"vec2<f32>\" },\n          uKernelSize: { value: Math.trunc(options.kernelSize ?? 5), type: \"i32\" },\n          uOffset: { value: options.offset, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_kernelSize\");\n    this.uniforms = this.resources.motionBlurUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Sets the velocity of the motion for blur effect\n   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n   * once defined in the constructor\n   * @default {x:0,y:0}\n   */\n  get velocity() {\n    return this.uniforms.uVelocity;\n  }\n  set velocity(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uVelocity = value;\n    this._updateDirty();\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get velocityX() {\n    return this.velocity.x;\n  }\n  set velocityX(value) {\n    this.velocity.x = value;\n    this._updateDirty();\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get velocityY() {\n    return this.velocity.y;\n  }\n  set velocityY(value) {\n    this.velocity.y = value;\n    this._updateDirty();\n  }\n  /**\n   * The kernelSize of the blur filter. Must be odd number >= 5\n   * @default 5\n   */\n  get kernelSize() {\n    return this._kernelSize;\n  }\n  set kernelSize(value) {\n    this._kernelSize = value;\n    this._updateDirty();\n  }\n  /**\n   * The offset of the blur filter\n   * @default 0\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n  }\n  _updateDirty() {\n    this.padding = (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) >> 0) + 1;\n    this.uniforms.uKernelSize = this.velocityX !== 0 || this.velocityY !== 0 ? this._kernelSize : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_MotionBlurFilter, \"DEFAULT_OPTIONS\", {\n  velocity: { x: 0, y: 0 },\n  kernelSize: 5,\n  offset: 0\n});\nlet MotionBlurFilter = _MotionBlurFilter;\n\nexport { MotionBlurFilter };\n//# sourceMappingURL=MotionBlurFilter.mjs.map\n","var source = \"struct MotionBlurUniforms {\\n  uVelocity: vec2<f32>,\\n  uKernelSize: i32,\\n  uOffset: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uVelocity = motionBlurUniforms.uVelocity;\\n  let uKernelSize = motionBlurUniforms.uKernelSize;\\n  let uOffset = motionBlurUniforms.uOffset;\\n\\n  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;\\n  let offset: f32 = -uOffset / length(uVelocity) - 0.5;\\n  let k: i32 = min(uKernelSize - 1, MAX_KERNEL_SIZE - 1);\\n\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  for(var i: i32 = 0; i < k; i += 1) {\\n    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);\\n    color += textureSample(uTexture, uSampler, uv + bias);\\n  }\\n  \\n  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);\\n}\\n\\nconst MAX_KERNEL_SIZE: i32 = 2048;\";\n\nexport { source as default };\n//# sourceMappingURL=motion-blur.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nconst int MAX_COLORS = ${MAX_COLORS};\\n\\nuniform sampler2D uTexture;\\nuniform vec3 uOriginalColors[MAX_COLORS];\\nuniform vec3 uTargetColors[MAX_COLORS];\\nuniform float uTolerance;\\n\\nvoid main(void)\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n\\n    float alpha = finalColor.a;\\n    if (alpha < 0.0001)\\n    {\\n      return;\\n    }\\n\\n    vec3 color = finalColor.rgb / alpha;\\n\\n    for(int i = 0; i < MAX_COLORS; i++)\\n    {\\n      vec3 origColor = uOriginalColors[i];\\n      if (origColor.r < 0.0)\\n      {\\n        break;\\n      }\\n      vec3 colorDiff = origColor - color;\\n      if (length(colorDiff) < uTolerance)\\n      {\\n        vec3 targetColor = uTargetColors[i];\\n        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);\\n        return;\\n      }\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=multi-color-replace.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './multi-color-replace.mjs';\nimport source from './multi-color-replace2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _MultiColorReplaceFilter = class _MultiColorReplaceFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options)) {\n      deprecation(\"6.0.0\", \"MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }\");\n      options = { replacements: options };\n      if (args[1])\n        options.tolerance = args[1];\n      if (args[2])\n        options.maxColors = args[2];\n    }\n    options = { ..._MultiColorReplaceFilter.DEFAULT_OPTIONS, ...options };\n    const maxColors = options.maxColors ?? options.replacements.length;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: source.replace(/\\$\\{MAX_COLORS\\}/g, maxColors.toFixed(0)),\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/\\$\\{MAX_COLORS\\}/g, maxColors.toFixed(0)),\n      name: \"multi-color-replace-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        multiColorReplaceUniforms: {\n          uOriginalColors: {\n            value: new Float32Array(3 * maxColors),\n            type: \"vec3<f32>\",\n            size: maxColors\n          },\n          uTargetColors: {\n            value: new Float32Array(3 * maxColors),\n            type: \"vec3<f32>\",\n            size: maxColors\n          },\n          uTolerance: { value: options.tolerance, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_replacements\", []);\n    __publicField(this, \"_maxColors\");\n    this._maxColors = maxColors;\n    this.uniforms = this.resources.multiColorReplaceUniforms.uniforms;\n    this.replacements = options.replacements;\n  }\n  /**\n   * The collection of replacement items. Each item is color-pair\n   * (an array length is 2). In the pair, the first value is original color , the second value is target color\n   */\n  set replacements(replacements) {\n    const originals = this.uniforms.uOriginalColors;\n    const targets = this.uniforms.uTargetColors;\n    const colorCount = replacements.length;\n    const color = new Color();\n    if (colorCount > this._maxColors) {\n      throw new Error(`Length of replacements (${colorCount}) exceeds the maximum colors length (${this._maxColors})`);\n    }\n    originals[colorCount * 3] = -1;\n    let r;\n    let g;\n    let b;\n    for (let i = 0; i < colorCount; i++) {\n      const pair = replacements[i];\n      color.setValue(pair[0]);\n      [r, g, b] = color.toArray();\n      originals[i * 3] = r;\n      originals[i * 3 + 1] = g;\n      originals[i * 3 + 2] = b;\n      color.setValue(pair[1]);\n      [r, g, b] = color.toArray();\n      targets[i * 3] = r;\n      targets[i * 3 + 1] = g;\n      targets[i * 3 + 2] = b;\n    }\n    this._replacements = replacements;\n  }\n  get replacements() {\n    return this._replacements;\n  }\n  /**\n    * Should be called after changing any of the contents of the replacements.\n    * This is a convenience method for resetting the `replacements`.\n    * @todo implement nested proxy to remove the need for this function\n    */\n  refresh() {\n    this.replacements = this._replacements;\n  }\n  /**\n    * The maximum number of color replacements supported by this filter. Can be changed\n    * _only_ during construction.\n    * @readonly\n    */\n  get maxColors() {\n    return this._maxColors;\n  }\n  /**\n    * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n    * @default 0.05\n    */\n  get tolerance() {\n    return this.uniforms.uTolerance;\n  }\n  set tolerance(value) {\n    this.uniforms.uTolerance = value;\n  }\n  /**\n   * @deprecated since 6.0.0\n   *\n   * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n   * @default 0.05\n   */\n  set epsilon(value) {\n    deprecation(\"6.0.0\", \"MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead\");\n    this.tolerance = value;\n  }\n  get epsilon() {\n    deprecation(\"6.0.0\", \"MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead\");\n    return this.tolerance;\n  }\n};\n/** Default values for options. */\n__publicField(_MultiColorReplaceFilter, \"DEFAULT_OPTIONS\", {\n  replacements: [[16711680, 255]],\n  tolerance: 0.05,\n  maxColors: void 0\n});\nlet MultiColorReplaceFilter = _MultiColorReplaceFilter;\n\nexport { MultiColorReplaceFilter };\n//# sourceMappingURL=MultiColorReplaceFilter.mjs.map\n","var source = \"struct MultiColorReplaceUniforms {\\n  uOriginalColors: array<vec3<f32>, MAX_COLORS>,\\n  uTargetColors: array<vec3<f32>, MAX_COLORS>,\\n  uTolerance:f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;\\n  let uTargetColors = multiColorReplaceUniforms.uTargetColors;\\n  let uTolerance = multiColorReplaceUniforms.uTolerance;\\n\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  let alpha: f32 = color.a;\\n\\n  if (alpha > 0.0001)\\n  {\\n    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;\\n\\n    for(var i: i32 = 0; i < MAX_COLORS; i += 1)\\n    {\\n      let origColor: vec3<f32> = uOriginalColors[i];\\n      if (origColor.r < 0.0)\\n      {\\n        break;\\n      }\\n      let colorDiff: vec3<f32> = origColor - modColor;\\n      \\n      if (length(colorDiff) < uTolerance)\\n      {\\n        let targetColor: vec3<f32> = uTargetColors[i];\\n        color = vec4((targetColor + colorDiff) * alpha, alpha);\\n        return color;\\n      }\\n    }\\n  }\\n\\n  return color;\\n}\\n\\nconst MAX_COLORS: i32 = ${MAX_COLORS};\";\n\nexport { source as default };\n//# sourceMappingURL=multi-color-replace2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uSepia;\\nuniform vec2 uNoise;\\nuniform vec3 uScratch;\\nuniform vec3 uVignetting;\\nuniform float uSeed;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nconst float SQRT_2 = 1.414213;\\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvec3 Overlay(vec3 src, vec3 dst)\\n{\\n    // if (dst <= 0.5) then: 2 * src * dst\\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\\n}\\n\\n\\nvoid main()\\n{\\n    finalColor = texture(uTexture, vTextureCoord);\\n    vec3 color = finalColor.rgb;\\n\\n    if (uSepia > 0.0)\\n    {\\n        float gray = (color.x + color.y + color.z) / 3.0;\\n        vec3 grayscale = vec3(gray);\\n\\n        color = Overlay(SEPIA_RGB, grayscale);\\n\\n        color = grayscale + uSepia * (color - grayscale);\\n    }\\n\\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;\\n\\n    float vignette = uVignetting[0];\\n    float vignetteAlpha = uVignetting[1];\\n    float vignetteBlur = uVignetting[2];\\n\\n    if (vignette > 0.0)\\n    {\\n        float outter = SQRT_2 - vignette * SQRT_2;\\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\\n        dir.y *= uDimensions.y / uDimensions.x;\\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);\\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);\\n    }\\n\\n    float scratch = uScratch[0];\\n    float scratchDensity = uScratch[1];\\n    float scratchWidth = uScratch[2];\\n\\n    if (scratchDensity > uSeed && scratch != 0.0)\\n    {\\n        float phase = uSeed * 256.0;\\n        float s = mod(floor(phase), 2.0);\\n        float dist = 1.0 / scratchDensity;\\n        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));\\n        if (d < uSeed * 0.6 + 0.4)\\n        {\\n            highp float period = scratchDensity * 10.0;\\n\\n            float xx = coord.x * period + phase;\\n            float aa = abs(mod(xx, 0.5) * 4.0);\\n            float bb = mod(floor(xx / 0.5), 2.0);\\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\\n\\n            float kk = 2.0 * period;\\n            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);\\n            float dh = dw * kk;\\n\\n            float tine = (yy - (2.0 - dh));\\n\\n            if (tine > 0.0) {\\n                float _sign = sign(scratch);\\n\\n                tine = s * tine / period + scratch + 0.1;\\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\\n\\n                color.rgb *= tine;\\n            }\\n        }\\n    }\\n\\n    float noise = uNoise[0];\\n    float noiseSize = uNoise[1];\\n\\n    if (noise > 0.0 && noiseSize > 0.0)\\n    {\\n        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);\\n        // float _noise = snoise(d) * 0.5;\\n        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;\\n        color += _noise * noise;\\n    }\\n\\n    finalColor.rgb = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=old-film.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './old-film.mjs';\nimport source from './old-film2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _OldFilmFilter = class _OldFilmFilter extends Filter {\n  /**\n   * @param options - Options for the OldFilmFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._OldFilmFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"old-film-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        oldFilmUniforms: {\n          uSepia: { value: options.sepia, type: \"f32\" },\n          uNoise: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uScratch: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uVignetting: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uSeed: { value: options.seed, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * A seed value to apply to the random noise generation\n     * @default 0\n     */\n    __publicField(this, \"seed\");\n    this.uniforms = this.resources.oldFilmUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    this.uniforms.uSeed = this.seed;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The amount of saturation of sepia effect,\n   * a value of `1` is more saturation and closer to `0` is less, and a value of `0` produces no sepia effect\n   * @default 0.3\n   */\n  get sepia() {\n    return this.uniforms.uSepia;\n  }\n  set sepia(value) {\n    this.uniforms.uSepia = value;\n  }\n  /**\n   * Opacity/intensity of the noise effect between `0` and `1`\n   * @default 0.3\n   */\n  get noise() {\n    return this.uniforms.uNoise[0];\n  }\n  set noise(value) {\n    this.uniforms.uNoise[0] = value;\n  }\n  /**\n   * The size of the noise particles\n   * @default 1\n   */\n  get noiseSize() {\n    return this.uniforms.uNoise[1];\n  }\n  set noiseSize(value) {\n    this.uniforms.uNoise[1] = value;\n  }\n  /**\n   * How often scratches appear\n   * @default 0.5\n   */\n  get scratch() {\n    return this.uniforms.uScratch[0];\n  }\n  set scratch(value) {\n    this.uniforms.uScratch[0] = value;\n  }\n  /**\n   * The density of the number of scratches\n   * @default 0.3\n   */\n  get scratchDensity() {\n    return this.uniforms.uScratch[1];\n  }\n  set scratchDensity(value) {\n    this.uniforms.uScratch[1] = value;\n  }\n  /**\n   * The width of the scratches\n   * @default 1\n   */\n  get scratchWidth() {\n    return this.uniforms.uScratch[2];\n  }\n  set scratchWidth(value) {\n    this.uniforms.uScratch[2] = value;\n  }\n  /**\n   * The radius of the vignette effect, smaller values produces a smaller vignette\n   * @default 0.3\n   */\n  get vignetting() {\n    return this.uniforms.uVignetting[0];\n  }\n  set vignetting(value) {\n    this.uniforms.uVignetting[0] = value;\n  }\n  /**\n   * Amount of opacity on the vignette\n   * @default 1\n   */\n  get vignettingAlpha() {\n    return this.uniforms.uVignetting[1];\n  }\n  set vignettingAlpha(value) {\n    this.uniforms.uVignetting[1] = value;\n  }\n  /**\n   * Blur intensity of the vignette\n   * @default 1\n   */\n  get vignettingBlur() {\n    return this.uniforms.uVignetting[2];\n  }\n  set vignettingBlur(value) {\n    this.uniforms.uVignetting[2] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_OldFilmFilter, \"DEFAULT_OPTIONS\", {\n  sepia: 0.3,\n  noise: 0.3,\n  noiseSize: 1,\n  scratch: 0.5,\n  scratchDensity: 0.3,\n  scratchWidth: 1,\n  vignetting: 0.3,\n  vignettingAlpha: 1,\n  vignettingBlur: 0.3,\n  seed: 0\n});\nlet OldFilmFilter = _OldFilmFilter;\n\nexport { OldFilmFilter };\n//# sourceMappingURL=OldFilmFilter.mjs.map\n","var source = \"struct OldFilmUniforms {\\n    uSepia: f32,\\n    uNoise: vec2<f32>,\\n    uScratch: vec3<f32>,\\n    uVignetting: vec3<f32>,\\n    uSeed: f32,\\n    uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  if (oldFilmUniforms.uSepia > 0.)\\n  {\\n    color = vec4<f32>(sepia(color.rgb), color.a);\\n  }\\n\\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;\\n\\n  if (oldFilmUniforms.uVignetting[0] > 0.)\\n  {\\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\\n  }\\n\\n  let uScratch = oldFilmUniforms.uScratch; \\n\\n  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)\\n  {\\n    color = vec4<f32>(scratch(color.rgb, coord), color.a);\\n  }\\n\\n  let uNoise = oldFilmUniforms.uNoise;\\n\\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\\n  {\\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\\n  }\\n\\n  return color;\\n}\\n\\nconst SQRT_2: f32 = 1.414213;\\nconst SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\nfn rand(co: vec2<f32>) -> f32\\n{\\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nfn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>\\n{\\n    // if (dst <= 0.5) then: 2 * src * dst\\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\\n\\n    return vec3<f32>(\\n      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), \\n      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),\\n      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))\\n    );\\n}\\n\\nfn sepia(co: vec3<f32>) -> vec3<f32>\\n{\\n  let gray: f32 = (co.x + co.y + co.z) / 3.0;\\n  let grayscale: vec3<f32> = vec3<f32>(gray);\\n  let color = overlay(SEPIA_RGB, grayscale);\\n  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);\\n}\\n\\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\\n{\\n  let uVignetting = oldFilmUniforms.uVignetting;\\n  let uDimensions = oldFilmUniforms.uDimensions;\\n  \\n  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;\\n  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);\\n  dir.y *= uDimensions.y / uDimensions.x;\\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);\\n  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);\\n}\\n\\nfn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\\n{\\n  var color = co;\\n  let uScratch = oldFilmUniforms.uScratch;\\n  let uSeed = oldFilmUniforms.uSeed;\\n  let uDimensions = oldFilmUniforms.uDimensions;\\n\\n  let phase: f32 = uSeed * 256.0;\\n  let s: f32 = modulo(floor(phase), 2.0);\\n  let dist: f32 = 1.0 / uScratch[1];\\n  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));\\n\\n  if (d < uSeed * 0.6 + 0.4)\\n  {\\n    let period: f32 = uScratch[1] * 10.0;\\n\\n    let xx: f32 = coord.x * period + phase;\\n    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);\\n    let bb: f32 = modulo(floor(xx / 0.5), 2.0);\\n    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);\\n\\n    let kk: f32 = 2.0 * period;\\n    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);\\n    let dh: f32 = dw * kk;\\n\\n    var tine: f32 = (yy - (2.0 - dh));\\n\\n    if (tine > 0.0) {\\n        let _sign: f32 = sign(uScratch[0]);\\n\\n        tine = s * tine / period + uScratch[0] + 0.1;\\n        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\\n\\n        color *= tine;\\n    }\\n  }\\n\\n  return color;\\n}\\n\\nfn noise(coord: vec2<f32>) -> f32\\n{\\n  let uNoise = oldFilmUniforms.uNoise;\\n  let uSeed = oldFilmUniforms.uSeed;\\n\\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=old-film2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uThickness;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\nuniform float uKnockout;\\n\\nuniform vec4 uInputClamp;\\n\\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\\nconst float ANGLE_STEP = ${ANGLE_STEP};\\n\\nfloat outlineMaxAlphaAtPos(vec2 pos) {\\n    if (uThickness.x == 0. || uThickness.y == 0.) {\\n        return 0.;\\n    }\\n\\n    vec4 displacedColor;\\n    vec2 displacedPos;\\n    float maxAlpha = 0.;\\n\\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\\n        maxAlpha = max(maxAlpha, displacedColor.a);\\n    }\\n\\n    return maxAlpha;\\n}\\n\\nvoid main(void) {\\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\\n    finalColor = contentColor + outlineColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=outline.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './outline.mjs';\nimport source from './outline2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _OutlineFilter = class _OutlineFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }\");\n      options = { thickness: options };\n      if (args[1] !== void 0)\n        options.color = args[1];\n      if (args[2] !== void 0)\n        options.quality = args[2];\n      if (args[3] !== void 0)\n        options.alpha = args[3];\n      if (args[4] !== void 0)\n        options.knockout = args[4];\n    }\n    options = { ..._OutlineFilter.DEFAULT_OPTIONS, ...options };\n    const quality = options.quality ?? 0.1;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(/\\$\\{ANGLE_STEP\\}/, _OutlineFilter.getAngleStep(quality).toFixed(7)),\n      name: \"outline-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        outlineUniforms: {\n          uThickness: { value: new Float32Array(2), type: \"vec2<f32>\" },\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uAngleStep: { value: 0, type: \"f32\" },\n          uKnockout: { value: options.knockout ? 1 : 0, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_thickness\");\n    __publicField(this, \"_quality\");\n    __publicField(this, \"_color\");\n    this.uniforms = this.resources.outlineUniforms.uniforms;\n    this.uniforms.uAngleStep = _OutlineFilter.getAngleStep(quality);\n    this._color = new Color();\n    this.color = options.color ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uThickness[0] = this.thickness / input.source.width;\n    this.uniforms.uThickness[1] = this.thickness / input.source.height;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the angleStep by quality\n   * @param quality\n   */\n  static getAngleStep(quality) {\n    return parseFloat((Math.PI * 2 / Math.max(\n      quality * _OutlineFilter.MAX_SAMPLES,\n      _OutlineFilter.MIN_SAMPLES\n    )).toFixed(7));\n  }\n  /**\n   * The thickness of the outline\n   * @default 1\n   */\n  get thickness() {\n    return this._thickness;\n  }\n  set thickness(value) {\n    this._thickness = this.padding = value;\n  }\n  /**\n   * The color value of the ambient color\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n  /**\n   * The quality of the outline from `0` to `1`.\n   * Using a higher quality setting will result in more accuracy but slower performance\n   * @default 0.1\n   */\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.uniforms.uAngleStep = _OutlineFilter.getAngleStep(value);\n  }\n  /**\n   * Whether to only render outline, not the contents.\n   * @default false\n   */\n  get knockout() {\n    return this.uniforms.uKnockout === 1;\n  }\n  set knockout(value) {\n    this.uniforms.uKnockout = value ? 1 : 0;\n  }\n};\n/** Default values for options. */\n__publicField(_OutlineFilter, \"DEFAULT_OPTIONS\", {\n  thickness: 1,\n  color: 0,\n  alpha: 1,\n  quality: 0.1,\n  knockout: false\n});\n/** The minimum number of samples for rendering outline. */\n__publicField(_OutlineFilter, \"MIN_SAMPLES\", 1);\n/** The maximum number of samples for rendering outline. */\n__publicField(_OutlineFilter, \"MAX_SAMPLES\", 100);\nlet OutlineFilter = _OutlineFilter;\n\nexport { OutlineFilter };\n//# sourceMappingURL=OutlineFilter.mjs.map\n","var source = \"struct OutlineUniforms {\\n  uThickness:vec2<f32>,\\n  uColor:vec3<f32>,\\n  uAlpha:f32,\\n  uAngleStep:f32,\\n  uKnockout:f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\\n  \\n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\\n  \\n  return contentColor + outlineColor;\\n}\\n\\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\\n  let thickness = outlineUniforms.uThickness;\\n\\n  if (thickness.x == 0. || thickness.y == 0.) {\\n    return 0.;\\n  }\\n  \\n  let angleStep = outlineUniforms.uAngleStep;\\n\\n  var displacedColor: vec4<f32>;\\n  var displacedPos: vec2<f32>;\\n\\n  var maxAlpha: f32 = 0.;\\n  var displaced: vec2<f32>;\\n  var curColor: vec4<f32>;\\n\\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\\n  {\\n    displaced.x = uv.x + thickness.x * cos(angle);\\n    displaced.y = uv.y + thickness.y * sin(angle);\\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n    maxAlpha = max(maxAlpha, curColor.a);\\n  }\\n\\n  return maxAlpha;\\n}\\n\\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;\";\n\nexport { source as default };\n//# sourceMappingURL=outline2.mjs.map\n","import { Filter, GpuProgram, GlProgram, Point } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './pixelate2.mjs';\nimport source from './pixelate.mjs';\n\nclass PixelateFilter extends Filter {\n  /**\n   * @param {Point|Array<number>|number} [size=10] - Either the width/height of the size of the pixels, or square size\n   */\n  constructor(size = 10) {\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"pixelate-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        pixelateUniforms: {\n          uSize: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    this.size = size;\n  }\n  /**\n   * The size of the pixels\n   * @default [10,10]\n   */\n  get size() {\n    return this.resources.pixelateUniforms.uniforms.uSize;\n  }\n  set size(value) {\n    if (value instanceof Point) {\n      this.sizeX = value.x;\n      this.sizeY = value.y;\n    } else if (Array.isArray(value)) {\n      this.resources.pixelateUniforms.uniforms.uSize = value;\n    } else {\n      this.sizeX = this.sizeY = value;\n    }\n  }\n  /**\n  * The size of the pixels on the `x` axis\n  * @default 10\n  */\n  get sizeX() {\n    return this.resources.pixelateUniforms.uniforms.uSize[0];\n  }\n  set sizeX(value) {\n    this.resources.pixelateUniforms.uniforms.uSize[0] = value;\n  }\n  /**\n  * The size of the pixels on the `y` axis\n  * @default 10\n  */\n  get sizeY() {\n    return this.resources.pixelateUniforms.uniforms.uSize[1];\n  }\n  set sizeY(value) {\n    this.resources.pixelateUniforms.uniforms.uSize[1] = value;\n  }\n}\n\nexport { PixelateFilter };\n//# sourceMappingURL=PixelateFilter.mjs.map\n","var source = \"struct PixelateUniforms {\\n  uSize:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> pixelateUniforms : PixelateUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  let pixelSize: vec2<f32> = pixelateUniforms.uSize;\\n  let coord: vec2<f32> = mapCoord(uv);\\n\\n  var pixCoord: vec2<f32> = pixelate(coord, pixelSize);\\n  pixCoord = unmapCoord(pixCoord);\\n\\n  return textureSample(uTexture, uSampler, pixCoord);\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord *= gfu.uInputSize.xy;\\n  mappedCoord += gfu.uOutputFrame.xy;\\n  return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord -= gfu.uOutputFrame.xy;\\n  mappedCoord /= gfu.uInputSize.xy;\\n  return mappedCoord;\\n}\\n\\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\\n{\\n  return floor( coord / size ) * size;\\n}\\n\\n\";\n\nexport { source as default };\n//# sourceMappingURL=pixelate.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform vec2 uSize;\\nuniform sampler2D uTexture;\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 pixelate(vec2 coord, vec2 uSize)\\n{\\n\\treturn floor( coord / uSize ) * uSize;\\n}\\n\\nvoid main(void)\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n    coord = pixelate(coord, uSize);\\n    coord = unmapCoord(coord);\\n    finalColor = texture(uTexture, coord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=pixelate2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uRadian;\\nuniform vec2 uCenter;\\nuniform float uRadius;\\nuniform int uKernelSize;\\n\\nuniform vec4 uInputSize;\\n\\nconst int MAX_KERNEL_SIZE = 2048;\\n\\nvoid main(void)\\n{\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    if (uKernelSize == 0)\\n    {\\n        finalColor = color;\\n        return;\\n    }\\n\\n    float aspect = uInputSize.y / uInputSize.x;\\n    vec2 center = uCenter.xy / uInputSize.xy;\\n    float gradient = uRadius / uInputSize.x * 0.3;\\n    float radius = uRadius / uInputSize.x - gradient * 0.5;\\n    int k = uKernelSize - 1;\\n\\n    vec2 coord = vTextureCoord;\\n    vec2 dir = vec2(center - coord);\\n    float dist = length(vec2(dir.x, dir.y * aspect));\\n\\n    float radianStep = uRadian;\\n    if (radius >= 0.0 && dist > radius) {\\n        float delta = dist - radius;\\n        float gap = gradient;\\n        float scale = 1.0 - abs(delta / gap);\\n        if (scale <= 0.0) {\\n            finalColor = color;\\n            return;\\n        }\\n        radianStep *= scale;\\n    }\\n    radianStep /= float(k);\\n\\n    float s = sin(radianStep);\\n    float c = cos(radianStep);\\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\\n\\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\\n        if (i == k) {\\n            break;\\n        }\\n\\n        coord -= center;\\n        coord.y *= aspect;\\n        coord = rotationMatrix * coord;\\n        coord.y /= aspect;\\n        coord += center;\\n\\n        vec4 sample = texture(uTexture, coord);\\n\\n        // switch to pre-multiplied alpha to correctly blur transparent images\\n        // sample.rgb *= sample.a;\\n\\n        color += sample;\\n    }\\n\\n    finalColor = color / float(uKernelSize);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=radial-blur.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './radial-blur.mjs';\nimport source from './radial-blur2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _RadialBlurFilter = class _RadialBlurFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }\");\n      options = { angle: options };\n      if (args[1]) {\n        const x = \"x\" in args[1] ? args[1].x : args[1][0];\n        const y = \"y\" in args[1] ? args[1].y : args[1][1];\n        options.center = { x, y };\n      }\n      if (args[2])\n        options.kernelSize = args[2];\n      if (args[3])\n        options.radius = args[3];\n    }\n    options = { ..._RadialBlurFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"radial-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        radialBlurUniforms: {\n          uRadian: { value: 0, type: \"f32\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uKernelSize: { value: options.kernelSize, type: \"i32\" },\n          uRadius: { value: options.radius, type: \"f32\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_angle\");\n    __publicField(this, \"_kernelSize\");\n    this.uniforms = this.resources.radialBlurUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  _updateKernelSize() {\n    this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;\n  }\n  /**\n   * Sets the angle in degrees of the motion for blur effect.\n   * @default 0\n   */\n  get angle() {\n    return this._angle;\n  }\n  set angle(value) {\n    this._angle = value;\n    this.uniforms.uRadian = value * Math.PI / 180;\n    this._updateKernelSize();\n  }\n  /**\n   * The `x` and `y` offset coordinates to change the position of the center of the circle of effect.\n   * This should be a size 2 array or an object containing `x` and `y` values, you cannot change types\n   * once defined in the constructor\n   * @default {x:0,y:0}\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.center.x;\n  }\n  set centerX(value) {\n    this.center.x = value;\n  }\n  /**\n   * Sets the velocity of the motion for blur effect on the `x` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.center.y;\n  }\n  set centerY(value) {\n    this.center.y = value;\n  }\n  /**\n   * The kernelSize of the blur filter. Must be odd number >= 3\n   * @default 5\n   */\n  get kernelSize() {\n    return this._kernelSize;\n  }\n  set kernelSize(value) {\n    this._kernelSize = value;\n    this._updateKernelSize();\n  }\n  /**\n   * The maximum size of the blur radius, less than `0` equates to infinity\n   * @default -1\n   */\n  get radius() {\n    return this.uniforms.uRadius;\n  }\n  set radius(value) {\n    this.uniforms.uRadius = value < 0 || value === Infinity ? -1 : value;\n  }\n};\n/** Default values for options. */\n__publicField(_RadialBlurFilter, \"DEFAULT_OPTIONS\", {\n  angle: 0,\n  center: { x: 0, y: 0 },\n  kernelSize: 5,\n  radius: -1\n});\nlet RadialBlurFilter = _RadialBlurFilter;\n\nexport { RadialBlurFilter };\n//# sourceMappingURL=RadialBlurFilter.mjs.map\n","var source = \"struct RadialBlurUniforms {\\n  uRadian: f32,\\n  uCenter: vec2<f32>,\\n  uKernelSize: f32,\\n  uRadius: f32,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uRadian = radialBlurUniforms.uRadian;\\n  let uCenter = radialBlurUniforms.uCenter;\\n  let uKernelSize = radialBlurUniforms.uKernelSize;\\n  let uRadius = radialBlurUniforms.uRadius;\\n  \\n  var returnColorOnly = false;\\n\\n  if (uKernelSize == 0)\\n  {\\n    returnColorOnly = true;\\n  }\\n\\n  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;\\n  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;\\n  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;\\n  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;\\n  let k: i32 = i32(uKernelSize - 1);\\n\\n  var coord: vec2<f32> = uv;\\n  let dir: vec2<f32> = vec2<f32>(center - coord);\\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));\\n\\n  var radianStep: f32 = uRadian;\\n  \\n  if (radius >= 0.0 && dist > radius)\\n  {\\n    let delta: f32 = dist - radius;\\n    let gap: f32 = gradient;\\n    let scale: f32 = 1.0 - abs(delta / gap);\\n    if (scale <= 0.0) {\\n      returnColorOnly = true;\\n    }\\n    radianStep *= scale;\\n  }\\n\\n  radianStep /= f32(k);\\n\\n  let s: f32 = sin(radianStep);\\n  let c: f32 = cos(radianStep);\\n  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));\\n  \\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let baseColor = vec4<f32>(color);\\n\\n  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);\\n\\n  for(var i: i32 = 0; i < minK; i += 1) \\n  {\\n    coord -= center;\\n    coord.y *= aspect;\\n    coord = rotationMatrix * coord;\\n    coord.y /= aspect;\\n    coord += center;\\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);\\n    // switch to pre-multiplied alpha to correctly blur transparent images\\n    // sample.rgb *= sample.a;\\n    color += sample;\\n  }\\n\\n  return select(color / f32(uKernelSize), baseColor, returnColorOnly);\\n}\\n\\nconst MAX_KERNEL_SIZE: i32 = 2048;\";\n\nexport { source as default };\n//# sourceMappingURL=radial-blur2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uMirror;\\nuniform float uBoundary;\\nuniform vec2 uAmplitude;\\nuniform vec2 uWavelength;\\nuniform vec2 uAlpha;\\nuniform float uTime;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nfloat rand(vec2 co) {\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main(void)\\n{\\n    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\\n    vec2 coord = pixelCoord / uDimensions;\\n\\n    if (coord.y < uBoundary) {\\n        finalColor = texture(uTexture, vTextureCoord);\\n        return;\\n    }\\n\\n    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\\n    float areaY = uBoundary * uDimensions.y / uInputSize.y;\\n    float v = areaY + areaY - vTextureCoord.y;\\n    float y = uMirror > 0.5 ? v : vTextureCoord.y;\\n\\n    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;\\n    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;\\n    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;\\n\\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;\\n    x = clamp(x, uInputClamp.x, uInputClamp.z);\\n\\n    vec4 color = texture(uTexture, vec2(x, y));\\n\\n    finalColor = color * _alpha;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=reflection.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './reflection.mjs';\nimport source from './reflection2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ReflectionFilter = class _ReflectionFilter extends Filter {\n  /**\n   * @param options - Options for the ReflectionFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._ReflectionFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"reflection-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        reflectionUniforms: {\n          uMirror: { value: options.mirror ? 1 : 0, type: \"f32\" },\n          uBoundary: { value: options.boundary, type: \"f32\" },\n          uAmplitude: { value: options.amplitude, type: \"vec2<f32>\" },\n          uWavelength: { value: options.waveLength, type: \"vec2<f32>\" },\n          uAlpha: { value: options.alpha, type: \"vec2<f32>\" },\n          uTime: { value: options.time, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /**\n     * Time for animating position of waves\n     * @default 0\n     */\n    __publicField(this, \"time\", 0);\n    this.uniforms = this.resources.reflectionUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * `true` to reflect the image, `false` for waves-only\n   * @default true\n   */\n  get mirror() {\n    return this.uniforms.uMirror > 0.5;\n  }\n  set mirror(value) {\n    this.uniforms.uMirror = value ? 1 : 0;\n  }\n  /**\n   * Vertical position of the reflection point, default is 50% (middle)\n   * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.\n   * @default 0.5\n   */\n  get boundary() {\n    return this.uniforms.uBoundary;\n  }\n  set boundary(value) {\n    this.uniforms.uBoundary = value;\n  }\n  /**\n   * Starting and ending amplitude of waves\n   * @default [0,20]\n   */\n  get amplitude() {\n    return Array.from(this.uniforms.uAmplitude);\n  }\n  set amplitude(value) {\n    this.uniforms.uAmplitude[0] = value[0];\n    this.uniforms.uAmplitude[1] = value[1];\n  }\n  /**\n   * Starting amplitude of waves\n   * @default 0\n   */\n  get amplitudeStart() {\n    return this.uniforms.uAmplitude[0];\n  }\n  set amplitudeStart(value) {\n    this.uniforms.uAmplitude[0] = value;\n  }\n  /**\n   * Starting amplitude of waves\n   * @default 20\n   */\n  get amplitudeEnd() {\n    return this.uniforms.uAmplitude[1];\n  }\n  set amplitudeEnd(value) {\n    this.uniforms.uAmplitude[1] = value;\n  }\n  /**\n   * Starting and ending length of waves\n   * @default [30,100]\n   */\n  get waveLength() {\n    return Array.from(this.uniforms.uWavelength);\n  }\n  set waveLength(value) {\n    this.uniforms.uWavelength[0] = value[0];\n    this.uniforms.uWavelength[1] = value[1];\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 30\n   */\n  get wavelengthStart() {\n    return this.uniforms.uWavelength[0];\n  }\n  set wavelengthStart(value) {\n    this.uniforms.uWavelength[0] = value;\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 100\n   */\n  get wavelengthEnd() {\n    return this.uniforms.uWavelength[1];\n  }\n  set wavelengthEnd(value) {\n    this.uniforms.uWavelength[1] = value;\n  }\n  /**\n   * Starting and ending alpha values\n   * @default [1,1]\n   */\n  get alpha() {\n    return Array.from(this.uniforms.uAlpha);\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha[0] = value[0];\n    this.uniforms.uAlpha[1] = value[1];\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 1\n   */\n  get alphaStart() {\n    return this.uniforms.uAlpha[0];\n  }\n  set alphaStart(value) {\n    this.uniforms.uAlpha[0] = value;\n  }\n  /**\n   * Starting wavelength of waves\n   * @default 1\n   */\n  get alphaEnd() {\n    return this.uniforms.uAlpha[1];\n  }\n  set alphaEnd(value) {\n    this.uniforms.uAlpha[1] = value;\n  }\n};\n/** Default values for options. */\n__publicField(_ReflectionFilter, \"DEFAULT_OPTIONS\", {\n  mirror: true,\n  boundary: 0.5,\n  amplitude: [0, 20],\n  waveLength: [30, 100],\n  alpha: [1, 1],\n  time: 0\n});\nlet ReflectionFilter = _ReflectionFilter;\n\nexport { ReflectionFilter };\n//# sourceMappingURL=ReflectionFilter.mjs.map\n","var source = \"struct ReflectionUniforms {\\n  uMirror: f32,\\n  uBoundary: f32,\\n  uAmplitude: vec2<f32>,\\n  uWavelength: vec2<f32>,\\n  uAlpha: vec2<f32>,\\n  uTime: f32,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\\n  let uTime: f32 = reflectionUniforms.uTime;\\n\\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\\n  let coord: vec2<f32> = pixelCoord /uDimensions;\\n  var returnColorOnly: bool = false;\\n\\n  if (coord.y < uBoundary) {\\n    returnColorOnly = true;\\n  }\\n\\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\\n  let v: f32 = areaY + areaY - uv.y;\\n  let y: f32 = select(uv.y, v, uMirror);\\n\\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\\n\\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\\n  \\n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\\n}\\n\\nfn rand(co: vec2<f32>) -> f32 \\n{\\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=reflection2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec4 uInputSize;\\nuniform vec2 uRed;\\nuniform vec2 uGreen;\\nuniform vec2 uBlue;\\n\\nvoid main(void)\\n{\\n   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;\\n   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;\\n   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;\\n   float a = texture(uTexture, vTextureCoord).a;\\n   finalColor = vec4(r, g, b, a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=rgb-split2.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './rgb-split2.mjs';\nimport source from './rgb-split.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _RGBSplitFilter = class _RGBSplitFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options) || \"x\" in options && \"y\" in options) {\n      deprecation(\"6.0.0\", \"RGBSplitFilter constructor params are now options object. See params: { red, green, blue }\");\n      options = { red: options };\n      if (args[1] !== void 0)\n        options.green = args[1];\n      if (args[2] !== void 0)\n        options.blue = args[2];\n    }\n    options = { ..._RGBSplitFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"rgb-split-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        rgbSplitUniforms: {\n          uRed: { value: options.red, type: \"vec2<f32>\" },\n          uGreen: { value: options.green, type: \"vec2<f32>\" },\n          uBlue: { value: options.blue, type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.rgbSplitUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Red channel offset.\n   * @default {x:-10,y:0}\n   */\n  get red() {\n    return this.uniforms.uRed;\n  }\n  set red(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uRed = value;\n  }\n  /**\n   * Amount of x-axis offset for the red channel.\n   * @default -10\n   */\n  get redX() {\n    return this.red.x;\n  }\n  set redX(value) {\n    this.red.x = value;\n  }\n  /**\n   * Amount of y-axis offset for the red channel.\n   * @default 0\n   */\n  get redY() {\n    return this.red.y;\n  }\n  set redY(value) {\n    this.red.y = value;\n  }\n  /**\n   * Green channel offset.\n   * @default {x:0,y:10}\n   */\n  get green() {\n    return this.uniforms.uGreen;\n  }\n  set green(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uGreen = value;\n  }\n  /**\n   * Amount of x-axis offset for the green channel.\n   * @default 0\n   */\n  get greenX() {\n    return this.green.x;\n  }\n  set greenX(value) {\n    this.green.x = value;\n  }\n  /**\n   * Amount of y-axis offset for the green channel.\n   * @default 10\n   */\n  get greenY() {\n    return this.green.y;\n  }\n  set greenY(value) {\n    this.green.y = value;\n  }\n  /**\n   * Blue channel offset.\n   * @default {x:0,y:0}\n   */\n  get blue() {\n    return this.uniforms.uBlue;\n  }\n  set blue(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uBlue = value;\n  }\n  /**\n   * Amount of x-axis offset for the blue channel.\n   * @default 0\n   */\n  get blueX() {\n    return this.blue.x;\n  }\n  set blueX(value) {\n    this.blue.x = value;\n  }\n  /**\n   * Amount of y-axis offset for the blue channel.\n   * @default 0\n   */\n  get blueY() {\n    return this.blue.y;\n  }\n  set blueY(value) {\n    this.blue.y = value;\n  }\n};\n/** Default values for options. */\n__publicField(_RGBSplitFilter, \"DEFAULT_OPTIONS\", {\n  red: { x: -10, y: 0 },\n  green: { x: 0, y: 10 },\n  blue: { x: 0, y: 0 }\n});\nlet RGBSplitFilter = _RGBSplitFilter;\n\nexport { RGBSplitFilter };\n//# sourceMappingURL=RGBSplitFilter.mjs.map\n","var source = \"struct RgbSplitUniforms {\\n    uRed: vec2<f32>,\\n    uGreen: vec2<f32>,\\n    uBlue: vec3<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;\\n    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;\\n    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;\\n    let a = textureSample(uTexture, uSampler, uv).a;\\n    return vec4<f32>(r, g, b, a);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=rgb-split.mjs.map\n","var fragment = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uCenter;\\nuniform float uTime;\\nuniform float uSpeed;\\nuniform vec4 uWave;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\nconst float PI = 3.14159;\\n\\nvoid main()\\n{\\n    float uAmplitude = uWave[0];\\n    float uWavelength = uWave[1];\\n    float uBrightness = uWave[2];\\n    float uRadius = uWave[3];\\n\\n    float halfWavelength = uWavelength * 0.5 / uInputSize.x;\\n    float maxRadius = uRadius / uInputSize.x;\\n    float currentRadius = uTime * uSpeed / uInputSize.x;\\n\\n    float fade = 1.0;\\n\\n    if (maxRadius > 0.0) {\\n        if (currentRadius > maxRadius) {\\n            finalColor = texture(uTexture, vTextureCoord);\\n            return;\\n        }\\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\\n    }\\n\\n    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);\\n    dir.y *= uInputSize.y / uInputSize.x;\\n    float dist = length(dir);\\n\\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\\n        finalColor = texture(uTexture, vTextureCoord);\\n        return;\\n    }\\n\\n    vec2 diffUV = normalize(dir);\\n\\n    float diff = (dist - currentRadius) / halfWavelength;\\n\\n    float p = 1.0 - pow(abs(diff), 2.0);\\n\\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\\n    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\\n\\n    vec2 offset = diffUV * powDiff / uInputSize.xy;\\n\\n    // Do clamp :\\n    vec2 coord = vTextureCoord + offset;\\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\\n    vec4 color = texture(uTexture, clampedCoord);\\n    if (coord != clampedCoord) {\\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n\\n    // No clamp :\\n    // finalColor = texture(uTexture, vTextureCoord + offset);\\n\\n    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=shockwave2.mjs.map\n","import { Filter, deprecation, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './shockwave2.mjs';\nimport source from './shockwave.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ShockwaveFilter = class _ShockwaveFilter extends Filter {\n  /** @ignore */\n  // eslint-disable-next-line max-len\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (Array.isArray(options) || \"x\" in options && \"y\" in options) {\n      deprecation(\"6.0.0\", \"ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }\");\n      options = { center: options, ...args[1] };\n      if (args[2] !== void 0)\n        options.time = args[2];\n    }\n    options = { ..._ShockwaveFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"shockwave-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        shockwaveUniforms: {\n          uTime: { value: options.time, type: \"f32\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uSpeed: { value: options.speed, type: \"f32\" },\n          uWave: { value: new Float32Array(4), type: \"vec4<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    /** Sets the elapsed time of the shockwave. It could control the current size of shockwave. */\n    __publicField(this, \"time\");\n    this.time = 0;\n    this.uniforms = this.resources.shockwaveUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uTime = this.time;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * The `x` and `y` center coordinates to change the position of the center of the circle of effect.\n   * @default [0,0]\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.uniforms.uCenter.x;\n  }\n  set centerX(value) {\n    this.uniforms.uCenter.x = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `y` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.uniforms.uCenter.y;\n  }\n  set centerY(value) {\n    this.uniforms.uCenter.y = value;\n  }\n  /**\n   * The speed about the shockwave ripples out. The unit is `pixel-per-second`\n   * @default 500\n   */\n  get speed() {\n    return this.uniforms.uSpeed;\n  }\n  set speed(value) {\n    this.uniforms.uSpeed = value;\n  }\n  /**\n   * The amplitude of the shockwave\n   * @default 30\n   */\n  get amplitude() {\n    return this.uniforms.uWave[0];\n  }\n  set amplitude(value) {\n    this.uniforms.uWave[0] = value;\n  }\n  /**\n   * The wavelength of the shockwave\n   * @default 160\n   */\n  get wavelength() {\n    return this.uniforms.uWave[1];\n  }\n  set wavelength(value) {\n    this.uniforms.uWave[1] = value;\n  }\n  /**\n   * The brightness of the shockwave\n   * @default 1\n   */\n  get brightness() {\n    return this.uniforms.uWave[2];\n  }\n  set brightness(value) {\n    this.uniforms.uWave[2] = value;\n  }\n  /**\n   * The maximum radius of shockwave. less than `0` means the max is an infinite distance\n   * @default -1\n   */\n  get radius() {\n    return this.uniforms.uWave[3];\n  }\n  set radius(value) {\n    this.uniforms.uWave[3] = value;\n  }\n};\n/** Default shockwave filter options */\n__publicField(_ShockwaveFilter, \"DEFAULT_OPTIONS\", {\n  /** The `x` and `y` center coordinates to change the position of the center of the circle of effect. */\n  center: { x: 0, y: 0 },\n  /** The speed about the shockwave ripples out. The unit is `pixel-per-second` */\n  speed: 500,\n  /** The amplitude of the shockwave */\n  amplitude: 30,\n  /** The wavelength of the shockwave */\n  wavelength: 160,\n  /** The brightness of the shockwave */\n  brightness: 1,\n  /** The maximum radius of shockwave. less than `0` means the max is an infinite distance */\n  radius: -1\n});\nlet ShockwaveFilter = _ShockwaveFilter;\n\nexport { ShockwaveFilter };\n//# sourceMappingURL=ShockwaveFilter.mjs.map\n","var source = \"\\nstruct ShockWaveUniforms {\\n    uTime: f32,\\n    uOffset: vec2<f32>,\\n    uSpeed: f32,\\n    uWave: vec4<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n    uInputSize:vec4<f32>,\\n    uInputPixel:vec4<f32>,\\n    uInputClamp:vec4<f32>,\\n    uOutputFrame:vec4<f32>,\\n    uGlobalFrame:vec4<f32>,\\n    uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    let uTime = shockwaveUniforms.uTime;\\n    let uOffset = shockwaveUniforms.uOffset;\\n    let uSpeed = shockwaveUniforms.uSpeed;\\n    let uAmplitude = shockwaveUniforms.uWave[0];\\n    let uWavelength = shockwaveUniforms.uWave[1];\\n    let uBrightness = shockwaveUniforms.uWave[2];\\n    let uRadius = shockwaveUniforms.uWave[3];\\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\\n    var fade: f32 = 1.0;\\n    var returnColorOnly: bool = false;\\n    \\n    if (maxRadius > 0.0) {\\n        if (currentRadius > maxRadius) {\\n            returnColorOnly = true;\\n        }\\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\\n    }\\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\\n\\n    let dist:f32 = length(dir);\\n\\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\\n        returnColorOnly = true;\\n    }\\n\\n    let diffUV: vec2<f32> = normalize(dir);\\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\\n    // Do clamp :\\n    let coord: vec2<f32> = uv + offset;\\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\\n\\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\\n    \\n    if (boolVec2(coord, clampedCoord)) \\n    {\\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n    // No clamp :\\n    var finalColor = clampedColor;\\n\\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\\n}\\n\\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\\n{\\n    if (x.x == y.x && x.y == y.y)\\n    {\\n        return true;\\n    }\\n    \\n    return false;\\n}\\n\\nconst PI: f32 = 3.14159265358979323846264;\\n\";\n\nexport { source as default };\n//# sourceMappingURL=shockwave.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform vec3 uColor;\\nuniform float uAlpha;\\nuniform vec2 uDimensions;\\n\\nuniform vec4 uInputSize;\\n\\nvoid main() {\\n    vec4 diffuseColor = texture(uTexture, vTextureCoord);\\n    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;\\n    vec4 light = texture(uMapTexture, lightCoord);\\n    vec3 ambient = uColor.rgb * uAlpha;\\n    vec3 intensity = ambient + light.rgb;\\n    vec3 color = diffuseColor.rgb * intensity;\\n    finalColor = vec4(color, diffuseColor.a);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=simple-lightmap.mjs.map\n","import { Texture, Filter, deprecation, GpuProgram, GlProgram, Color } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './simple-lightmap.mjs';\nimport source from './simple-lightmap2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _SimpleLightmapFilter = class _SimpleLightmapFilter extends Filter {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Texture) {\n      deprecation(\"6.0.0\", \"SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }\");\n      options = { lightMap: options };\n      if (args[1] !== void 0)\n        options.color = args[1];\n      if (args[2] !== void 0)\n        options.alpha = args[2];\n    }\n    options = { ..._SimpleLightmapFilter.DEFAULT_OPTIONS, ...options };\n    if (!options.lightMap)\n      throw Error(\"No light map texture source was provided to SimpleLightmapFilter\");\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"simple-lightmap-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        simpleLightmapUniforms: {\n          uColor: { value: new Float32Array(3), type: \"vec3<f32>\" },\n          uAlpha: { value: options.alpha, type: \"f32\" },\n          uDimensions: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        },\n        uMapTexture: options.lightMap.source,\n        uMapSampler: options.lightMap.source.style\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_color\");\n    __publicField(this, \"_lightMap\");\n    this.uniforms = this.resources.simpleLightmapUniforms.uniforms;\n    this._color = new Color();\n    this.color = options.color ?? 0;\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.uDimensions[0] = input.frame.width;\n    this.uniforms.uDimensions[1] = input.frame.height;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /** A sprite where your lightmap is rendered */\n  get lightMap() {\n    return this._lightMap;\n  }\n  set lightMap(value) {\n    this._lightMap = value;\n    this.resources.uMapTexture = value.source;\n    this.resources.uMapSampler = value.source.style;\n  }\n  /**\n   * The color value of the ambient color\n   * @example [1.0, 1.0, 1.0] = 0xffffff\n   * @default 0x000000\n   */\n  get color() {\n    return this._color.value;\n  }\n  set color(value) {\n    this._color.setValue(value);\n    const [r, g, b] = this._color.toArray();\n    this.uniforms.uColor[0] = r;\n    this.uniforms.uColor[1] = g;\n    this.uniforms.uColor[2] = b;\n  }\n  /**\n   * Coefficient for alpha multiplication\n   * @default 1\n   */\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n};\n/** Default values for options. */\n__publicField(_SimpleLightmapFilter, \"DEFAULT_OPTIONS\", {\n  lightMap: Texture.WHITE,\n  color: 0,\n  alpha: 1\n});\nlet SimpleLightmapFilter = _SimpleLightmapFilter;\n\nexport { SimpleLightmapFilter };\n//# sourceMappingURL=SimpleLightmapFilter.mjs.map\n","var source = \"struct SimpleLightmapUniforms {\\n  uColor: vec3<f32>,\\n  uAlpha: f32,\\n  uDimensions: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler: sampler;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n  let uColor = simpleLightmapUniforms.uColor;\\n  let uAlpha = simpleLightmapUniforms.uAlpha;\\n  let uDimensions = simpleLightmapUniforms.uDimensions;\\n\\n  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;\\n  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);\\n  let ambient: vec3<f32> = uColor * uAlpha;\\n  let intensity: vec3<f32> = ambient + light.rgb;\\n  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;\\n  return vec4<f32>(finalColor, diffuseColor.a);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=simple-lightmap2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\nuniform float uNoiseScale;\\nuniform float uOffsetX;\\nuniform float uOffsetY;\\nuniform float uOffsetZ;\\nuniform float uStep;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uInputClamp;\\n\\n//Noise from: https://www.shadertoy.com/view/4sc3z2\\nconst vec3 MOD3 = vec3(.1031,.11369,.13787);\\nvec3 hash33(vec3 p3)\\n{\\n\\tp3 = fract(p3 * MOD3);\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\\n}\\n\\nfloat simplex_noise(vec3 p)\\n{\\n    const float K1 = 0.333333333;\\n    const float K2 = 0.166666667;\\n    \\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n    \\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n\\tvec3 i1 = e * (1.0 - e.zxy);\\n\\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n    \\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\\n    \\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\\n    \\n    return dot(vec4(31.316), n);\\n}\\n\\nvoid main(void)\\n{\\n    float noise = simplex_noise(\\n                    vec3(vTextureCoord*uNoiseScale+vec2(uOffsetX, uOffsetY), uOffsetZ)\\n                ) * 0.5 + 0.5;\\n\\n    noise += 2.0 * uStrength - 1.0;\\n    noise = clamp(noise, 0.0, 1.0);\\n\\n    if (uStep > 0.0) {  //step > 0.5\\n        noise = 1.0 - step(noise, uStep);\\n    }\\n\\n    finalColor = texture(uTexture, vTextureCoord) * noise;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=simplex.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './simplex.mjs';\nimport source from './simplex2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _SimplexNoiseFilter = class _SimplexNoiseFilter extends Filter {\n  /**\n   * @param options - Options for the SimplexNoise constructor.\n   */\n  constructor(options) {\n    options = { ..._SimplexNoiseFilter.defaults, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"simplex-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        simplexUniforms: {\n          uStrength: { value: options?.strength ?? 0, type: \"f32\" },\n          uNoiseScale: { value: options?.noiseScale ?? 0, type: \"f32\" },\n          uOffsetX: { value: options?.offsetX ?? 0, type: \"f32\" },\n          uOffsetY: { value: options?.offsetY ?? 0, type: \"f32\" },\n          uOffsetZ: { value: options?.offsetZ ?? 0, type: \"f32\" },\n          uStep: { value: options?.step ?? 0, type: \"f32\" }\n        }\n      }\n    });\n  }\n  /**\n   * Strength of the noise (color = (noiseMap + strength) * texture)\n   * @default 0.5\n   */\n  get strength() {\n    return this.resources.simplexUniforms.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.resources.simplexUniforms.uniforms.uStrength = value;\n  }\n  /**\n   * Noise map scale.\n   * @default 10\n   */\n  get noiseScale() {\n    return this.resources.simplexUniforms.uniforms.uNoiseScale;\n  }\n  set noiseScale(value) {\n    this.resources.simplexUniforms.uniforms.uNoiseScale = value;\n  }\n  /**\n   * Horizontal offset for the noise map.\n   * @default 0\n   */\n  get offsetX() {\n    return this.resources.simplexUniforms.uniforms.uOffsetX;\n  }\n  set offsetX(value) {\n    this.resources.simplexUniforms.uniforms.uOffsetX = value;\n  }\n  /**\n   * Vertical offset for the noise map.\n   * @default 0\n   */\n  get offsetY() {\n    return this.resources.simplexUniforms.uniforms.uOffsetY;\n  }\n  set offsetY(value) {\n    this.resources.simplexUniforms.uniforms.uOffsetY = value;\n  }\n  /**\n   * Depth offset for the noise map.\n   * @default 0\n   */\n  get offsetZ() {\n    return this.resources.simplexUniforms.uniforms.uOffsetZ;\n  }\n  set offsetZ(value) {\n    this.resources.simplexUniforms.uniforms.uOffsetZ = value;\n  }\n  /**\n   * The threshold used with the step function to create a blocky effect in the noise pattern.\n   * When this is greater than 0, the step function is used to compare the noise value to this threshold.\n   * @default -1\n   */\n  get step() {\n    return this.resources.simplexUniforms.uniforms.uStep;\n  }\n  set step(value) {\n    this.resources.simplexUniforms.uniforms.uStep = value;\n  }\n};\n/** Default constructor options. */\n__publicField(_SimplexNoiseFilter, \"defaults\", {\n  strength: 0.5,\n  noiseScale: 10,\n  offsetX: 0,\n  offsetY: 0,\n  offsetZ: 0,\n  step: -1\n});\nlet SimplexNoiseFilter = _SimplexNoiseFilter;\n\nexport { SimplexNoiseFilter };\n//# sourceMappingURL=SimplexNoiseFilter.mjs.map\n","var source = \"struct SimplexUniforms {\\n  uStrength:f32,\\n  uNoiseScale:f32,\\n  uOffsetX:f32,\\n  uOffsetY:f32,\\n  uOffsetZ:f32,\\n  uStep:f32\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> simplexUniforms : SimplexUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  var noise: f32 = simplex_noise(vec3<f32>(uv * simplexUniforms.uNoiseScale + vec2<f32>(simplexUniforms.uOffsetX, simplexUniforms.uOffsetY), simplexUniforms.uOffsetZ)) * 0.5 + 0.5;\\n\\tnoise = noise + (2. * simplexUniforms.uStrength - 1.);\\n\\tnoise = clamp(noise, 0.0, 1.0);\\n\\tif (simplexUniforms.uStep > 0.0) {\\n\\t\\tnoise = 1. - step(noise, simplexUniforms.uStep);\\n\\t}\\n\\treturn textureSample(uTexture, uSampler, uv) * noise;\\n}\\n\\nconst MOD3: vec3<f32> = vec3<f32>(0.1031, 0.11369, 0.13787);\\nfn hash33(p3: vec3<f32>) -> vec3<f32> {\\n\\tvar p3_var = p3;\\n\\tp3_var = fract(p3_var * MOD3);\\n\\tp3_var = p3_var + (dot(p3_var, p3_var.yxz + 19.19));\\n\\treturn -1. + 2. * fract(vec3<f32>((p3_var.x + p3_var.y) * p3_var.z, (p3_var.x + p3_var.z) * p3_var.y, (p3_var.y + p3_var.z) * p3_var.x));\\n} \\n\\nfn simplex_noise(p: vec3<f32>) -> f32 {\\n\\tlet K1: f32 = 0.33333334;\\n\\tlet K2: f32 = 0.16666667;\\n\\tlet i: vec3<f32> = floor(p + (p.x + p.y + p.z) * K1);\\n\\tlet d0: vec3<f32> = p - (i - (i.x + i.y + i.z) * K2);\\n\\tlet e: vec3<f32> = step(vec3<f32>(0.), d0 - d0.yzx);\\n\\tlet i1: vec3<f32> = e * (1. - e.zxy);\\n\\tlet i2: vec3<f32> = 1. - e.zxy * (1. - e);\\n\\tlet d1: vec3<f32> = d0 - (i1 - 1. * K2);\\n\\tlet d2: vec3<f32> = d0 - (i2 - 2. * K2);\\n\\tlet d3: vec3<f32> = d0 - (1. - 3. * K2);\\n\\tlet h: vec4<f32> = max(vec4<f32>(0.6) - vec4<f32>(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), vec4<f32>(0.0));\\n\\tlet n: vec4<f32> = h * h * h * h * vec4<f32>(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.)));\\n\\treturn dot(vec4<f32>(31.316), n);\\n} \";\n\nexport { source as default };\n//# sourceMappingURL=simplex2.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uBlur;\\nuniform vec2 uStart;\\nuniform vec2 uEnd;\\nuniform vec2 uDelta;\\nuniform vec4 uInputSize;\\n\\nfloat random(vec3 scale, float seed)\\n{\\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\n}\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n    float total = 0.0;\\n\\n    float blur = uBlur[0];\\n    float gradientBlur = uBlur[1];\\n\\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\\n    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));\\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uInputSize.xy - uStart, normal)) / gradientBlur) * blur;\\n\\n    for (float t = -30.0; t <= 30.0; t++)\\n    {\\n        float percent = (t + offset - 0.5) / 30.0;\\n        float weight = 1.0 - abs(percent);\\n        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uInputSize.xy * percent * radius);\\n        sample.rgb *= sample.a;\\n        color += sample * weight;\\n        total += weight;\\n    }\\n\\n    color /= total;\\n    color.rgb /= color.a + 0.00001;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=tilt-shift.mjs.map\n","import { Filter, ViewSystem, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './tilt-shift.mjs';\nimport source from './tilt-shift2.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _TiltShiftAxisFilter = class _TiltShiftAxisFilter extends Filter {\n  constructor(options) {\n    const { width, height } = ViewSystem.defaultOptions;\n    options = {\n      ..._TiltShiftAxisFilter.DEFAULT_OPTIONS,\n      /** The position to start the effect at. */\n      start: { x: 0, y: height / 2 },\n      /** The position to end the effect at. */\n      end: { x: width, y: height / 2 },\n      ...options\n    };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"tilt-shift-axis-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        tiltShiftUniforms: {\n          uBlur: {\n            value: new Float32Array([\n              options.blur,\n              options.gradientBlur\n            ]),\n            type: \"vec2<f32>\"\n          },\n          uStart: { value: options.start, type: \"vec2<f32>\" },\n          uEnd: { value: options.end, type: \"vec2<f32>\" },\n          uDelta: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    __publicField(this, \"_tiltAxis\");\n    this.uniforms = this.resources.tiltShiftUniforms.uniforms;\n    this._tiltAxis = options.axis;\n  }\n  /**\n   * Updates the filter delta values.\n   * @ignore\n   */\n  updateDelta() {\n    this.uniforms.uDelta[0] = 0;\n    this.uniforms.uDelta[1] = 0;\n    if (this._tiltAxis === void 0)\n      return;\n    const end = this.uniforms.uEnd;\n    const start = this.uniforms.uStart;\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const d = Math.sqrt(dx * dx + dy * dy);\n    const isVert = this._tiltAxis === \"vertical\";\n    this.uniforms.uDelta[0] = !isVert ? dx / d : -dy / d;\n    this.uniforms.uDelta[1] = !isVert ? dy / d : dx / d;\n  }\n};\n/** Default values for options. */\n__publicField(_TiltShiftAxisFilter, \"DEFAULT_OPTIONS\", {\n  /** The strength of the blur. */\n  blur: 100,\n  /** The strength of the blur gradient */\n  gradientBlur: 600\n});\nlet TiltShiftAxisFilter = _TiltShiftAxisFilter;\n\nexport { TiltShiftAxisFilter };\n//# sourceMappingURL=TiltShiftAxisFilter.mjs.map\n","var source = \"struct TiltShiftUniforms {\\n  uBlur: vec2<f32>,\\n  uStart: vec2<f32>,\\n  uEnd: vec2<f32>,\\n  uDelta: vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uBlur = tiltShiftUniforms.uBlur[0];\\n  let uBlurGradient = tiltShiftUniforms.uBlur[1];\\n  let uStart = tiltShiftUniforms.uStart;\\n  let uEnd = tiltShiftUniforms.uEnd;\\n  let uDelta = tiltShiftUniforms.uDelta;\\n\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n  var total: f32 = 0.0;\\n\\n  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);\\n  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));\\n  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * gfu.uInputSize.xy - uStart, normal)) / uBlurGradient) * uBlur;\\n\\n  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)\\n  {\\n    var percent: f32 = (t + offset - 0.5) / 30.0;\\n    var weight: f32 = 1.0 - abs(percent);\\n    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / gfu.uInputSize.xy * percent * radius);\\n    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a\\n    color += sample * weight;\\n    total += weight;\\n  }\\n\\n  color /= total;\\n  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001\\n\\n  return color;\\n}\\n\\n\\nfn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32\\n{\\n  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=tilt-shift2.mjs.map\n","import { TexturePool } from 'pixi.js';\nimport { TiltShiftAxisFilter } from './TiltShiftAxisFilter.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TiltShiftFilter extends TiltShiftAxisFilter {\n  /**\n   * @param options - Options for the TiltShiftFilter constructor.\n   */\n  constructor(options) {\n    options = { ...TiltShiftAxisFilter.DEFAULT_OPTIONS, ...options };\n    super({ ...options, axis: \"horizontal\" });\n    __publicField(this, \"_tiltShiftYFilter\");\n    this._tiltShiftYFilter = new TiltShiftAxisFilter({ ...options, axis: \"vertical\" });\n    this.updateDelta();\n    Object.assign(this, options);\n  }\n  /**\n   * Override existing apply method in `Filter`\n   * @override\n   * @ignore\n   */\n  apply(filterManager, input, output, clearMode) {\n    const renderTarget = TexturePool.getSameSizeTexture(input);\n    filterManager.applyFilter(this, input, renderTarget, true);\n    filterManager.applyFilter(this._tiltShiftYFilter, renderTarget, output, clearMode);\n    TexturePool.returnTexture(renderTarget);\n  }\n  /** @ignore */\n  updateDelta() {\n    super.updateDelta();\n    this._tiltShiftYFilter.updateDelta();\n  }\n  /** The strength of the blur. */\n  get blur() {\n    return this.uniforms.uBlur[0];\n  }\n  set blur(value) {\n    this.uniforms.uBlur[0] = this._tiltShiftYFilter.uniforms.uBlur[0] = value;\n  }\n  /** The strength of the gradient blur. */\n  get gradientBlur() {\n    return this.uniforms.uBlur[1];\n  }\n  set gradientBlur(value) {\n    this.uniforms.uBlur[1] = this._tiltShiftYFilter.uniforms.uBlur[1] = value;\n  }\n  /** The position to start the effect at. */\n  get start() {\n    return this.uniforms.uStart;\n  }\n  set start(value) {\n    this.uniforms.uStart = this._tiltShiftYFilter.uniforms.uStart = value;\n    this.updateDelta();\n  }\n  /** The position to start the effect at on the `x` axis. */\n  get startX() {\n    return this.start.x;\n  }\n  set startX(value) {\n    this.start.x = value;\n    this.updateDelta();\n  }\n  /** The position to start the effect at on the `x` axis. */\n  get startY() {\n    return this.start.y;\n  }\n  set startY(value) {\n    this.start.y = value;\n    this.updateDelta();\n  }\n  /** The position to end the effect at. */\n  get end() {\n    return this.uniforms.uEnd;\n  }\n  set end(value) {\n    this.uniforms.uEnd = this._tiltShiftYFilter.uniforms.uEnd = value;\n    this.updateDelta();\n  }\n  /** The position to end the effect at on the `x` axis. */\n  get endX() {\n    return this.end.x;\n  }\n  set endX(value) {\n    this.end.x = value;\n    this.updateDelta();\n  }\n  /** The position to end the effect at on the `y` axis. */\n  get endY() {\n    return this.end.y;\n  }\n  set endY(value) {\n    this.end.y = value;\n    this.updateDelta();\n  }\n}\n\nexport { TiltShiftFilter };\n//# sourceMappingURL=TiltShiftFilter.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uTwist;\\nuniform vec2 uOffset;\\nuniform vec4 uInputSize;\\n\\nvec2 mapCoord( vec2 coord )\\n{\\n    coord *= uInputSize.xy;\\n    coord += uInputSize.zw;\\n\\n    return coord;\\n}\\n\\nvec2 unmapCoord( vec2 coord )\\n{\\n    coord -= uInputSize.zw;\\n    coord /= uInputSize.xy;\\n\\n    return coord;\\n}\\n\\nvec2 twist(vec2 coord)\\n{\\n    coord -= uOffset;\\n\\n    float dist = length(coord);\\n    float uRadius = uTwist[0];\\n    float uAngle = uTwist[1];\\n\\n    if (dist < uRadius)\\n    {\\n        float ratioDist = (uRadius - dist) / uRadius;\\n        float angleMod = ratioDist * ratioDist * uAngle;\\n        float s = sin(angleMod);\\n        float c = cos(angleMod);\\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\\n    }\\n\\n    coord += uOffset;\\n\\n    return coord;\\n}\\n\\nvoid main(void)\\n{\\n    vec2 coord = mapCoord(vTextureCoord);\\n    coord = twist(coord);\\n    coord = unmapCoord(coord);\\n    finalColor = texture(uTexture, coord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=twist2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './twist2.mjs';\nimport source from './twist.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _TwistFilter = class _TwistFilter extends Filter {\n  /**\n   * @param options - Options for the TwistFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._TwistFilter.DEFAULT_OPTIONS, ...options };\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"twist-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        twistUniforms: {\n          uTwist: {\n            value: [options.radius ?? 0, options.angle ?? 0],\n            type: \"vec2<f32>\"\n          },\n          uOffset: {\n            value: options.offset,\n            type: \"vec2<f32>\"\n          }\n        }\n      },\n      ...options\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.twistUniforms.uniforms;\n  }\n  /**\n   * The radius of the twist\n   * @default 200\n   */\n  get radius() {\n    return this.uniforms.uTwist[0];\n  }\n  set radius(value) {\n    this.uniforms.uTwist[0] = value;\n  }\n  /**\n   * The angle of the twist\n   * @default 4\n   */\n  get angle() {\n    return this.uniforms.uTwist[1];\n  }\n  set angle(value) {\n    this.uniforms.uTwist[1] = value;\n  }\n  /**\n   * The `x` offset coordinate to change the position of the center of the circle of effect\n   * @default 0\n   */\n  get offset() {\n    return this.uniforms.uOffset;\n  }\n  set offset(value) {\n    this.uniforms.uOffset = value;\n  }\n  /**\n   * The `x` offset coordinate to change the position of the center of the circle of effect\n   * @default 0\n   */\n  get offsetX() {\n    return this.offset.x;\n  }\n  set offsetX(value) {\n    this.offset.x = value;\n  }\n  /**\n   * The `y` offset coordinate to change the position of the center of the circle of effect\n   * @default 0\n   */\n  get offsetY() {\n    return this.offset.y;\n  }\n  set offsetY(value) {\n    this.offset.y = value;\n  }\n};\n/** Default values for options. */\n__publicField(_TwistFilter, \"DEFAULT_OPTIONS\", {\n  padding: 20,\n  radius: 200,\n  angle: 4,\n  offset: { x: 0, y: 0 }\n});\nlet TwistFilter = _TwistFilter;\n\nexport { TwistFilter };\n//# sourceMappingURL=TwistFilter.mjs.map\n","var source = \"struct TwistUniforms {\\n  uTwist:vec2<f32>,\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));\\n}\\n\\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord *= gfu.uInputSize.xy;\\n  mappedCoord += gfu.uOutputFrame.xy;\\n  return mappedCoord;\\n}\\n\\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\\n{\\n  var mappedCoord: vec2<f32> = coord;\\n  mappedCoord -= gfu.uOutputFrame.xy;\\n  mappedCoord /= gfu.uInputSize.xy;\\n  return mappedCoord;\\n}\\n\\nfn twist(coord: vec2<f32>) -> vec2<f32>\\n{\\n  var twistedCoord: vec2<f32> = coord;\\n  let uRadius = twistUniforms.uTwist[0];\\n  let uAngle = twistUniforms.uTwist[1];\\n  let uOffset = twistUniforms.uOffset;\\n\\n  twistedCoord -= uOffset;\\n  \\n  let dist = length(twistedCoord);\\n\\n  if (dist < uRadius)\\n  {\\n    let ratioDist: f32 = (uRadius - dist) / uRadius;\\n    let angleMod: f32 = ratioDist * ratioDist * uAngle;\\n    let s: f32 = sin(angleMod);\\n    let c: f32 = cos(angleMod);\\n    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);\\n  }\\n\\n  twistedCoord += uOffset;\\n  return twistedCoord;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=twist.mjs.map\n","var fragment = \"precision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uStrength;\\nuniform vec2 uCenter;\\nuniform vec2 uRadii;\\n\\nuniform vec4 uInputSize;\\n\\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\\n\\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float rand(vec2 co, float seed) {\\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\\n    return fract(sin(sn) * c + seed);\\n}\\n\\nvoid main() {\\n    float minGradient = uRadii[0] * 0.3;\\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\\n\\n    float gradient = uRadii[1] * 0.3;\\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\\n\\n    float countLimit = MAX_KERNEL_SIZE;\\n\\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\\n\\n    float strength = uStrength;\\n\\n    float delta = 0.0;\\n    float gap;\\n    if (dist < innerRadius) {\\n        delta = innerRadius - dist;\\n        gap = minGradient;\\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\\n        delta = dist - radius;\\n        gap = gradient;\\n    }\\n\\n    if (delta > 0.0) {\\n        float normalCount = gap / uInputSize.x;\\n        delta = (normalCount - delta) / normalCount;\\n        countLimit *= delta;\\n        strength *= delta;\\n        if (countLimit < 1.0)\\n        {\\n            gl_FragColor = texture(uTexture, vTextureCoord);\\n            return;\\n        }\\n    }\\n\\n    // randomize the lookup values to hide the fixed number of samples\\n    float offset = rand(vTextureCoord, 0.0);\\n\\n    float total = 0.0;\\n    vec4 color = vec4(0.0);\\n\\n    dir *= strength;\\n\\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\\n        float weight = 4.0 * (percent - percent * percent);\\n        vec2 p = vTextureCoord + dir * percent;\\n        vec4 sample = texture(uTexture, p);\\n\\n        // switch to pre-multiplied alpha to correctly blur transparent images\\n        // sample.rgb *= sample.a;\\n\\n        color += sample * weight;\\n        total += weight;\\n\\n        if (t > countLimit){\\n            break;\\n        }\\n    }\\n\\n    color /= total;\\n    // switch back from pre-multiplied alpha\\n    // color.rgb /= color.a + 0.00001;\\n\\n    gl_FragColor = color;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=zoom-blur2.mjs.map\n","import { Filter, GpuProgram, GlProgram } from 'pixi.js';\nimport vertex from '../defaults/default.mjs';\nimport wgslVertex from '../defaults/default2.mjs';\nimport fragment from './zoom-blur2.mjs';\nimport source from './zoom-blur.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _ZoomBlurFilter = class _ZoomBlurFilter extends Filter {\n  /**\n   * @param options - Options for the ZoomBlurFilter constructor.\n   */\n  constructor(options) {\n    options = { ..._ZoomBlurFilter.DEFAULT_OPTIONS, ...options };\n    const kernelSize = options.maxKernelSize ?? 32;\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source: wgslVertex,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source: source.replace(\"${MAX_KERNEL_SIZE}\", kernelSize.toFixed(1)),\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment: fragment.replace(\"${MAX_KERNEL_SIZE}\", kernelSize.toFixed(1)),\n      name: \"zoom-blur-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram,\n      resources: {\n        zoomBlurUniforms: {\n          uStrength: { value: options.strength, type: \"f32\" },\n          uCenter: { value: options.center, type: \"vec2<f32>\" },\n          uRadii: { value: new Float32Array(2), type: \"vec2<f32>\" }\n        }\n      }\n    });\n    __publicField(this, \"uniforms\");\n    this.uniforms = this.resources.zoomBlurUniforms.uniforms;\n    Object.assign(this, options);\n  }\n  /**\n   * Sets the strength of the zoom blur effect\n   * @default 0.1\n   */\n  get strength() {\n    return this.uniforms.uStrength;\n  }\n  set strength(value) {\n    this.uniforms.uStrength = value;\n  }\n  /**\n   * The center of the zoom\n   * @default [0,0]\n   */\n  get center() {\n    return this.uniforms.uCenter;\n  }\n  set center(value) {\n    if (Array.isArray(value)) {\n      value = { x: value[0], y: value[1] };\n    }\n    this.uniforms.uCenter = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `x` axis\n   * @default 0\n   */\n  get centerX() {\n    return this.uniforms.uCenter.x;\n  }\n  set centerX(value) {\n    this.uniforms.uCenter.x = value;\n  }\n  /**\n   * Sets the center of the effect in normalized screen coords on the `y` axis\n   * @default 0\n   */\n  get centerY() {\n    return this.uniforms.uCenter.y;\n  }\n  set centerY(value) {\n    this.uniforms.uCenter.y = value;\n  }\n  /**\n   * The inner radius of zoom. The part in inner circle won't apply zoom blur effect\n   * @default 0\n   */\n  get innerRadius() {\n    return this.uniforms.uRadii[0];\n  }\n  set innerRadius(value) {\n    this.uniforms.uRadii[0] = value;\n  }\n  /**\n   * Outer radius of the effect. less than `0` equates to infinity\n   * @default -1\n   */\n  get radius() {\n    return this.uniforms.uRadii[1];\n  }\n  set radius(value) {\n    this.uniforms.uRadii[1] = value < 0 || value === Infinity ? -1 : value;\n  }\n};\n/** Default values for options. */\n__publicField(_ZoomBlurFilter, \"DEFAULT_OPTIONS\", {\n  strength: 0.1,\n  center: { x: 0, y: 0 },\n  innerRadius: 0,\n  radius: -1,\n  maxKernelSize: 32\n});\nlet ZoomBlurFilter = _ZoomBlurFilter;\n\nexport { ZoomBlurFilter };\n//# sourceMappingURL=ZoomBlurFilter.mjs.map\n","var source = \"struct ZoomBlurUniforms {\\n    uStrength:f32,\\n    uCenter:vec2<f32>,\\n    uRadii:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uStrength = zoomBlurUniforms.uStrength;\\n  let uCenter = zoomBlurUniforms.uCenter;\\n  let uRadii = zoomBlurUniforms.uRadii;\\n\\n  let minGradient: f32 = uRadii[0] * 0.3;\\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\\n\\n  let gradient: f32 = uRadii[1] * 0.3;\\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\\n\\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\\n\\n  var countLimit: f32 = MAX_KERNEL_SIZE;\\n\\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\\n\\n  var strength: f32 = uStrength;\\n\\n  var delta: f32 = 0.0;\\n  var gap: f32;\\n\\n  if (dist < innerRadius) {\\n      delta = innerRadius - dist;\\n      gap = minGradient;\\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\\n      delta = dist - radius;\\n      gap = gradient;\\n  }\\n\\n  var returnColorOnly: bool = false;\\n\\n  if (delta > 0.0) {\\n    let normalCount: f32 = gap / gfu.uInputSize.x;\\n    delta = (normalCount - delta) / normalCount;\\n    countLimit *= delta;\\n    strength *= delta;\\n    \\n    if (countLimit < 1.0)\\n    {\\n      returnColorOnly = true;;\\n    }\\n  }\\n\\n  // randomize the lookup values to hide the fixed number of samples\\n  let offset: f32 = rand(uv, 0.0);\\n\\n  var total: f32 = 0.0;\\n  var color: vec4<f32> = vec4<f32>(0.);\\n\\n  dir *= strength;\\n\\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\\n    let weight: f32 = 4.0 * (percent - percent * percent);\\n    let p: vec2<f32> = uv + dir * percent;\\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\\n    \\n    if (t < countLimit)\\n    {\\n      color += sample * weight;\\n      total += weight;\\n    }\\n  }\\n\\n  color /= total;\\n\\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\\n}\\n\\nfn modulo(x: f32, y: f32) -> f32\\n{\\n  return x - y * floor(x/y);\\n}\\n\\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nfn rand(co: vec2<f32>, seed: f32) -> f32\\n{\\n  let a: f32 = 12.9898;\\n  let b: f32 = 78.233;\\n  let c: f32 = 43758.5453;\\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\\n  let sn: f32 = modulo(dt, 3.14159);\\n  return fract(sin(sn) * c + seed);\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=zoom-blur.mjs.map\n"],"names":["source","_AlphaFilter","Filter","constructor","options","defaultOptions","gpuProgram","GpuProgram","from","vertex","entryPoint","fragment","glProgram","GlProgram","name","alpha","rest","super","resources","alphaUniforms","UniformGroup","uAlpha","value","type","this","uniforms","AlphaFilter","GAUSSIAN_VALUES","fragTemplate","join","generateBlurGlProgram","horizontal","kernelSize","x","halfLength","Math","ceil","template","vertSource","blurLoop","i","blur","replace","toString","generateBlurVertSource","kernel","length","fragSource","generateBlurFragSource","_BlurFilterPass","blurStructSource","blurOutSource","blurSamplingSource","kernelValue","blurStruct","blurOut","blurSampling","finalSource","generateBlurProgram","blurUniforms","uStrength","_quality","quality","strength","_uniforms","apply","filterManager","input","output","clearMode","passes","applyFilter","tempTexture","TexturePool","getSameSizeTexture","flip","flop","_state","blend","shouldClear","renderer","RendererType","WEBGPU","temp","returnTexture","padding","abs","BlurFilterPass","BlurFilter","args","deprecation","v8_0_0","resolution","strengthX","strengthY","compatibleRenderers","BOTH","_repeatEdgePixels","blurXFilter","blurYFilter","repeatEdgePixels","xStrength","yStrength","blendMode","updatePadding","max","Error","blurX","blurY","wgslVertex","__defProp","Object","defineProperty","__publicField","obj","key","enumerable","configurable","writable","__defNormalProp","_AdjustmentFilter","DEFAULT_OPTIONS","adjustmentUniforms","uGamma","gamma","uContrast","contrast","uSaturation","saturation","uBrightness","brightness","uColor","red","green","blue","AdjustmentFilter","_KawaseBlurFilter","Array","isArray","clamp","kawaseBlurUniforms","uOffset","Float32Array","y","pixelSize","kernels","_blur","_clamp","uvX","pixelSizeX","width","uvY","pixelSizeY","height","offset","_kernels","renderTarget","tmp","source2","target","last","_generateKernels","round","_pixelSize","_updatePadding","reduce","acc","v","k","step","push","KawaseBlurFilter","_ExtractBrightnessFilter","extractBrightnessUniforms","uThreshold","threshold","ExtractBrightnessFilter","_AdvancedBloomFilter","advancedBloomUniforms","uBloomScale","bloomScale","uMapTexture","Texture","WHITE","_extractFilter","_blurFilter","assign","brightTarget","bloomTarget","AdvancedBloomFilter","_AsciiFilter","size","replaceColor","color","asciiUniforms","uSize","uReplaceColor","Number","_color","Color","setValue","r","g","b","toArray","AsciiFilter","BackdropBlurFilter","blendRequired","_blendPass","uBackground","EMPTY","backTexture","_activeFilterData","blurredBackground","_BevelFilter","bevelUniforms","uLightColor","uLightAlpha","lightAlpha","uShadowColor","uShadowAlpha","shadowAlpha","uTransform","_lightColor","_shadowColor","lightColor","shadowColor","rotation","_rotation","DEG_TO_RAD","_updateTransform","thickness","_thickness","cos","sin","BevelFilter","_BloomFilter","_strength","_blurXFilter","_blurYFilter","clear","_updateStrength","BloomFilter","_BulgePinchFilter","bulgePinchUniforms","uDimensions","uCenter","center","uRadius","radius","frame","centerX","centerY","BulgePinchFilter","GradientParser","stringify","visitor","node","visit_gradient","orientation","visit","colorStops","visit_shape","result","at","style","visit_position","visit_em","visit_px","visit_literal","visit_color","visit_hex","visit_rgb","visit_rgba","resultColor","visit_angular","visit_directional","visit_array","elements","forEach","element","nodeVisitor","root","parse","tokens","error","msg","err","getAST","ast","matchListing","matchDefinition","matchGradient","matchLinearOrientation","matchListRadialOrientations","gradientType","pattern","orientationMatcher","matchCall","captures","scan","matchColorStop","callback","match","radialOrientations","lookaheadCache","radialOrientation","matchRadialOrientation","radialType","circle","matchLength","matchExtentKeyword","matchCircle","ellipse","matchDistance","matchEllipse","matchAtPosition","extent","positionAt","defaultPosition","matchPositioning","positioning","location","matcher","matchNumber","captureIndex","regexp","blankCaptures","exec","consume","substr","code","parseCssGradient","cssGradient","cssGradientNodes","trimCssGradient","cssGradientNode","typeFromCssType","stops","stopsFromCssStops","angle","angleFromCssOrientation","supportedTypes","offsets","offsetsFromCssColorStops","colorString","colorAsStringFromCssStop","rgbaColor","slice","stop","cssStop","stopOffset","parseFloat","findNextFixedStop","fromIndex","indexDelta","prevFixedOffset","nextFixed","stepSize","s","map","fixFloatRounding","substring","angleFromDirectionalValue","supportedValues","left","top","bottom","right","value_","trim","_ColorGradientFilter","css","defaults","maxColors","baseUniforms","uOptions","uCounts","stopsUniforms","uColors","maxStops","uStops","_stops","sortedStops","sort","a","sortColorStops","indexStart","LINEAR","ColorGradientFilter","_ColorMapFilter","TextureSource","colorMap","nearest","mix","colorMapUniforms","uMix","uSliceSize","uSlicePixelSize","uSliceInnerSize","uMapSampler","colorSize","_size","_colorMap","scaleMode","_scaleMode","autoGenerateMipmaps","_sliceSize","_slicePixelSize","_sliceInnerSize","_nearest","texture","update","updateColorMap","destroy","ColorMapFilter","_ColorOverlayFilter","colorOverlayUniforms","ColorOverlayFilter","_ColorReplaceFilter","originalColor","targetColor","tolerance","colorReplaceUniforms","uOriginalColor","uTargetColor","uTolerance","_originalColor","_targetColor","newColor","epsilon","ColorReplaceFilter","_ConvolutionFilter","matrix","convolutionUniforms","uMatrix","uTexelSize","ConvolutionFilter","CrossHatchFilter","_CRTFilter","crtUniforms","uLine","uNoise","uVignette","uSeed","seed","uTime","time","curvature","lineWidth","lineContrast","verticalLine","noise","noiseSize","vignetting","vignettingAlpha","vignettingBlur","CRTFilter","_DotFilter","scale","grayscale","dotUniforms","uScale","uAngle","uGrayScale","DotFilter","_DropShadowFilter","dropShadowUniforms","_basePass","shadowOnly","offsetX","offsetY","offsetPadding","DropShadowFilter","EmbossFilter","embossUniforms","_GlitchFilter","canvas","document","createElement","sampleSize","ImageSource","resource","glitchUniforms","uAspect","uFillMode","fillMode","uDirection","direction","uRed","uGreen","uBlue","uDisplacementMap","uDisplacementSampler","_canvas","_randomizeSizes","arr","_sizes","_slices","min","minSize","average","count","averageWidth","w","random","ratio","sqrt","shuffle","rand","_randomizeOffsets","_offsets","refresh","redraw","ctx","getContext","clearRect","floor","fillStyle","fillRect","sizes","len","slices","GlitchFilter","_GlowFilter","distance","toFixed","glowUniforms","uDistance","innerStrength","outerStrength","uQuality","uKnockout","knockout","GlowFilter","_GodrayFilter","godrayUniforms","uLight","uParallel","uRay","parallel","_angleLight","_center","_angle","radians","gain","lacunarity","GodrayFilter","GrayscaleFilter","_HslAdjustmentFilter","hslUniforms","uHsl","uColorize","colorize","hue","_hue","PI","lightness","HslAdjustmentFilter","_MotionBlurFilter","ObservablePoint","velocity","motionBlurUniforms","uVelocity","uKernelSize","trunc","_updateDirty","velocityX","velocityY","_kernelSize","MotionBlurFilter","_MultiColorReplaceFilter","replacements","multiColorReplaceUniforms","uOriginalColors","uTargetColors","_maxColors","originals","targets","colorCount","pair","_replacements","MultiColorReplaceFilter","_OldFilmFilter","oldFilmUniforms","uSepia","sepia","uScratch","uVignetting","scratch","scratchDensity","scratchWidth","OldFilmFilter","_OutlineFilter","getAngleStep","outlineUniforms","uThickness","uAngleStep","MAX_SAMPLES","MIN_SAMPLES","OutlineFilter","PixelateFilter","pixelateUniforms","Point","sizeX","sizeY","_RadialBlurFilter","radialBlurUniforms","uRadian","_updateKernelSize","Infinity","RadialBlurFilter","_ReflectionFilter","reflectionUniforms","uMirror","mirror","uBoundary","boundary","uAmplitude","amplitude","uWavelength","waveLength","amplitudeStart","amplitudeEnd","wavelengthStart","wavelengthEnd","alphaStart","alphaEnd","ReflectionFilter","_RGBSplitFilter","rgbSplitUniforms","redX","redY","greenX","greenY","blueX","blueY","RGBSplitFilter","_ShockwaveFilter","shockwaveUniforms","uSpeed","speed","uWave","wavelength","ShockwaveFilter","_SimpleLightmapFilter","lightMap","simpleLightmapUniforms","_lightMap","SimpleLightmapFilter","_SimplexNoiseFilter","simplexUniforms","uNoiseScale","noiseScale","uOffsetX","uOffsetY","uOffsetZ","offsetZ","uStep","SimplexNoiseFilter","_TiltShiftAxisFilter","ViewSystem","start","end","tiltShiftUniforms","uBlur","gradientBlur","uStart","uEnd","uDelta","_tiltAxis","axis","updateDelta","dx","dy","d","isVert","TiltShiftAxisFilter","TiltShiftFilter","_tiltShiftYFilter","startX","startY","endX","endY","_TwistFilter","twistUniforms","uTwist","TwistFilter","_ZoomBlurFilter","maxKernelSize","zoomBlurUniforms","uRadii","innerRadius","ZoomBlurFilter"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132]}