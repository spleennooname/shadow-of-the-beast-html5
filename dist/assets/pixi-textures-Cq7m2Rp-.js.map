{"version":3,"file":"pixi-textures-Cq7m2Rp-.js","sources":["../../node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs","../../node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs","../../node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs","../../node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs","../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"],"sourcesContent":["import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { Cache } from '../../../../cache/Cache.mjs';\n\n\"use strict\";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache.has(url)) {\n      Cache.remove(url);\n    }\n  };\n  texture.source.once(\"destroy\", () => {\n    if (loader.promiseCache[url]) {\n      warn(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n      unload();\n    }\n  });\n  texture.once(\"destroy\", () => {\n    if (!source.destroyed) {\n      warn(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n      unload();\n    }\n  });\n  return texture;\n}\n\nexport { createTexture };\n//# sourceMappingURL=createTexture.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validSVGExtension = \".svg\";\nconst validSVGMIME = \"image/svg+xml\";\nconst loadSvg = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low,\n    name: \"loadSVG\"\n  },\n  /** used for deprecation purposes */\n  name: \"loadSVG\",\n  id: \"svg\",\n  config: {\n    crossOrigin: \"anonymous\",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await DOMAdapter.get().fetch(url);\n  const image = DOMAdapter.get().createImage();\n  image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await response.text())}`;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const canvasWidth = Math.ceil(width * resolution);\n  const canvasHeight = Math.ceil(height * resolution);\n  const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);\n  const context = canvas.getContext(\"2d\");\n  context.imageSmoothingEnabled = true;\n  context.imageSmoothingQuality = \"high\";\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n  const base = new ImageSource({\n    resource: canvas,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext();\n  context.svg(svgSource);\n  return context;\n}\n\nexport { loadSvg };\n//# sourceMappingURL=loadSVG.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { WorkerManager } from '../../workers/WorkerManager.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/webp\",\n  \"image/avif\"\n];\nasync function loadImageBitmap(url, asset) {\n  const response = await DOMAdapter.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  return asset?.data?.alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \"none\" }) : createImageBitmap(imageBlob);\n}\nconst loadTextures = {\n  /** used for deprecation purposes */\n  name: \"loadTextures\",\n  id: \"texture\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High,\n    name: \"loadTextures\"\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url, asset);\n      } else {\n        src = await loadImageBitmap(url, asset);\n      }\n    } else {\n      src = await new Promise((resolve, reject) => {\n        src = DOMAdapter.get().createImage();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n          src.onerror = reject;\n        }\n      });\n    }\n    const base = new ImageSource({\n      resource: src,\n      alphaMode: \"premultiply-alpha-on-upload\",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { loadImageBitmap, loadTextures };\n//# sourceMappingURL=loadTextures.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { testVideoFormat } from '../../../detections/utils/testVideoFormat.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst potentialVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nlet validVideoExtensions;\nlet validVideoMIMEs;\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc || (loc = globalThis.location);\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nfunction getBrowserSupportedVideoExtensions() {\n  const supportedExtensions = [];\n  const supportedMimes = [];\n  for (const ext of potentialVideoExtensions) {\n    const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;\n    if (testVideoFormat(mimeType)) {\n      supportedExtensions.push(ext);\n      if (!supportedMimes.includes(mimeType)) {\n        supportedMimes.push(mimeType);\n      }\n    }\n  }\n  return {\n    validVideoExtensions: supportedExtensions,\n    validVideoMime: supportedMimes\n  };\n}\nconst loadVideoTextures = {\n  /** used for deprecation purposes */\n  name: \"loadVideo\",\n  id: \"video\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    name: \"loadVideo\"\n  },\n  test(url) {\n    if (!validVideoExtensions || !validVideoMIMEs) {\n      const { validVideoExtensions: ve, validVideoMime: vm } = getBrowserSupportedVideoExtensions();\n      validVideoExtensions = ve;\n      validVideoMIMEs = vm;\n    }\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (options.mime) {\n      mime = options.mime;\n    } else if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource({ ...options, resource: videoElement });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      if (options.preload && !options.autoPlay) {\n        videoElement.load();\n      }\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo };\n//# sourceMappingURL=loadVideoTextures.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n"],"names":["createTexture","source","loader","url","label","_sourceOrigin","texture","Texture","unload","promiseCache","Cache","has","remove","once","warn","destroyed","loadSvg","extension","type","ExtensionType","LoadParser","priority","LoaderParserPriority","Low","name","id","config","crossOrigin","parseAsGraphicsContext","test","checkDataUrl","checkExtension","load","asset","data","this","async","response","DOMAdapter","get","fetch","svgSource","text","context","GraphicsContext","svg","loadAsGraphics","image","createImage","src","encodeURIComponent","decode","width","height","resolution","getResolutionOfUrl","canvasWidth","Math","ceil","canvasHeight","canvas","createCanvas","getContext","imageSmoothingEnabled","imageSmoothingQuality","drawImage","_p","rest","ImageSource","resource","alphaMode","loadAsTexture","destroy","validImageExtensions","validImageMIMEs","loadTextures","High","preferWorkers","preferCreateImageBitmap","globalThis","createImageBitmap","WorkerManager","isImageBitmapSupported","loadImageBitmap","ok","Error","status","statusText","imageBlob","blob","premultiplyAlpha","Promise","resolve","reject","complete","onload","onerror","potentialVideoExtensions","validVideoExtensions","validVideoMIMEs","element","crossorigin","startsWith","loc","location","parsedUrl","URL","document","baseURI","hostname","port","protocol","determineCrossOrigin","loadVideoTextures","ve","validVideoMime","vm","supportedExtensions","supportedMimes","ext","mimeType","VideoSource","MIME_TYPES","substring","testVideoFormat","push","includes","getBrowserSupportedVideoExtensions","isValidDataUrl","isValidExtension","options","defaultOptions","detectVideoAlphaMode","videoElement","createElement","attributeMap","preload","autoLoad","playsinline","muted","loop","autoplay","autoPlay","Object","keys","forEach","key","value","setAttribute","sourceElement","mime","slice","indexOf","split","lastIndexOf","toLowerCase","onCanPlay","base","removeEventListener","loaded","cleanup","error","err","addEventListener","appendChild","textureBit","vertex","header","main","fragment","textureBitGl"],"mappings":"sOAKA,SAASA,EAAcC,EAAQC,EAAQC,GACrCF,EAAOG,MAAQD,EACfF,EAAOI,cAAgBF,EACvB,MAAMG,EAAU,IAAIC,EAAQ,CAC1BN,SACAG,MAAOD,IAEHK,EAAS,YACNN,EAAOO,aAAaN,GACvBO,EAAMC,IAAIR,IACZO,EAAME,OAAOT,IAejB,OAZAG,EAAQL,OAAOY,KAAK,UAAW,KACzBX,EAAOO,aAAaN,KACtBW,EAAK,8IACLN,OAGJF,EAAQO,KAAK,UAAW,KACjBZ,EAAOc,YACVD,EAAK,kIACLN,OAGGF,CACT,CCpBA,MAEMU,EAAU,CACdC,UAAW,CACTC,KAAMC,EAAcC,WACpBC,SAAUC,EAAqBC,IAC/BC,KAAM,WAGRA,KAAM,UACNC,GAAI,MACJC,OAAQ,CACNC,YAAa,YACbC,wBAAwB,GAE1BC,KAAK1B,GACI2B,EAAa3B,EAfH,kBAeyB4B,EAAe5B,EAhBnC,QAkBxB,UAAM6B,CAAK7B,EAAK8B,EAAO/B,GACrB,OAAI+B,EAAMC,MAAMN,wBAA0BO,KAAKT,OAAOE,uBAkC1DQ,eAA8BjC,GAC5B,MAAMkC,QAAiBC,EAAWC,MAAMC,MAAMrC,GACxCsC,QAAkBJ,EAASK,OAC3BC,EAAU,IAAIC,EAEpB,OADAD,EAAQE,IAAIJ,GACLE,CACT,CAvCaG,CAAe3C,GAQ5BiC,eAA6BjC,EAAK8B,EAAO/B,EAAQyB,GAC/C,MAAMU,QAAiBC,EAAWC,MAAMC,MAAMrC,GACxC4C,EAAQT,EAAWC,MAAMS,cAC/BD,EAAME,IAAM,oCAAoCC,yBAAyBb,EAASK,UAClFK,EAAMpB,YAAcA,QACdoB,EAAMI,SACZ,MAAMC,EAAQnB,EAAMC,MAAMkB,OAASL,EAAMK,MACnCC,EAASpB,EAAMC,MAAMmB,QAAUN,EAAMM,OACrCC,EAAarB,EAAMC,MAAMoB,YAAcC,EAAmBpD,GAC1DqD,EAAcC,KAAKC,KAAKN,EAAQE,GAChCK,EAAeF,KAAKC,KAAKL,EAASC,GAClCM,EAAStB,EAAWC,MAAMsB,aAAaL,EAAaG,GACpDhB,EAAUiB,EAAOE,WAAW,MAClCnB,EAAQoB,uBAAwB,EAChCpB,EAAQqB,sBAAwB,OAChCrB,EAAQsB,UAAUlB,EAAO,EAAG,EAAGK,EAAQE,EAAYD,EAASC,GAC5D,MAAQ1B,uBAAwBsC,KAAOC,GAASlC,EAAMC,MAAQ,CAAA,EAO9D,OAAOlC,EANM,IAAIoE,EAAY,CAC3BC,SAAUT,EACVU,UAAW,8BACXhB,gBACGa,IAEsBjE,EAAQC,EACrC,CA9BWoE,CAAcpE,EAAK8B,EAAO/B,EAAQiC,KAAKT,OAAOC,YACvD,EACA,MAAAnB,CAAOyB,GACLA,EAAMuC,SAAQ,EAChB,GC1BF,MAAMC,EAAuB,CAAC,QAAS,OAAQ,OAAQ,QAAS,SAC1DC,EAAkB,CACtB,aACA,YACA,aACA,cAUG,MAACC,EAAe,CAEnBnD,KAAM,eACNC,GAAI,UACJR,UAAW,CACTC,KAAMC,EAAcC,WACpBC,SAAUC,EAAqBsD,KAC/BpD,KAAM,gBAERE,OAAQ,CACNmD,eAAe,EACfC,yBAAyB,EACzBnD,YAAa,aAEfE,KAAK1B,GACI2B,EAAa3B,EAAKuE,IAAoB3C,EAAe5B,EAAKsE,GAEnE,UAAMzC,CAAK7B,EAAK8B,EAAO/B,GACrB,IAAI+C,EAAM,KAGNA,EAFA8B,WAAWC,mBAAqB7C,KAAKT,OAAOoD,wBAC1C3C,KAAKT,OAAOmD,qBAAuBI,EAAcC,+BACvCD,EAAcE,gBAAgBhF,EAAK8B,SA7BvDG,eAA+BjC,EAAK8B,GAClC,MAAMI,QAAiBC,EAAWC,MAAMC,MAAMrC,GAC9C,IAAKkC,EAAS+C,GACZ,MAAM,IAAIC,MAAM,qCAAqClF,MAAQkC,EAASiD,UAAUjD,EAASkD,cAE3F,MAAMC,QAAkBnD,EAASoD,OACjC,MAAkC,wBAA3BxD,GAAOC,MAAMoC,UAAsCU,kBAAkBQ,EAAW,CAAEE,iBAAkB,SAAYV,kBAAkBQ,EAC3I,CAwBoBL,CAAgBhF,EAAK8B,SAGvB,IAAI0D,QAAQ,CAACC,EAASC,KAChC5C,EAAMX,EAAWC,MAAMS,cACvBC,EAAItB,YAAcQ,KAAKT,OAAOC,YAC9BsB,EAAIA,IAAM9C,EACN8C,EAAI6C,SACNF,EAAQ3C,IAERA,EAAI8C,OAAS,KACXH,EAAQ3C,IAEVA,EAAI+C,QAAUH,KAUpB,OAAO7F,EANM,IAAIoE,EAAY,CAC3BC,SAAUpB,EACVqB,UAAW,8BACXhB,WAAYrB,EAAMC,MAAMoB,YAAcC,EAAmBpD,MACtD8B,EAAMC,OAEgBhC,EAAQC,EACrC,EACA,MAAAK,CAAOF,GACLA,EAAQkE,SAAQ,EAClB,GClEIyB,EAA2B,CAAC,OAAQ,OAAQ,QAAS,OAAQ,OAAQ,QAAS,OAAQ,QAC5F,IAAIC,EACAC,EACJ,SAASxE,EAAYyE,EAASjG,EAAKkG,QACb,IAAhBA,GAA2BlG,EAAImG,WAAW,UAEnB,IAAhBD,IACTD,EAAQzE,YAAqC,iBAAhB0E,EAA2BA,EAAc,aAFtED,EAAQzE,YAwBZ,SAA8BxB,EAAKoG,EAAMxB,WAAWyB,UAClD,GAAIrG,EAAImG,WAAW,SACjB,MAAO,GAETC,IAAQA,EAAMxB,WAAWyB,UACzB,MAAMC,EAAY,IAAIC,IAAIvG,EAAKwG,SAASC,SACxC,GAAIH,EAAUI,WAAaN,EAAIM,UAAYJ,EAAUK,OAASP,EAAIO,MAAQL,EAAUM,WAAaR,EAAIQ,SACnG,MAAO,YAET,MAAO,EACT,CAlC0BC,CAAqB7G,EAI/C,CAgDK,MAAC8G,EAAoB,CAExBzF,KAAM,YACNC,GAAI,QACJR,UAAW,CACTC,KAAMC,EAAcC,WACpBI,KAAM,aAER,IAAAK,CAAK1B,GACH,IAAK+F,IAAyBC,EAAiB,CAC7C,MAAQD,qBAAsBgB,EAAIC,eAAgBC,GA3BxD,WACE,MAAMC,EAAsB,GACtBC,EAAiB,GACvB,IAAA,MAAWC,KAAOtB,EAA0B,CAC1C,MAAMuB,EAAWC,EAAYC,WAAWH,EAAII,UAAU,KAAO,SAASJ,EAAII,UAAU,KAChFC,EAAgBJ,KAClBH,EAAoBQ,KAAKN,GACpBD,EAAeQ,SAASN,IAC3BF,EAAeO,KAAKL,GAG1B,CACA,MAAO,CACLtB,qBAAsBmB,EACtBF,eAAgBG,EAEpB,CAW+DS,GACzD7B,EAAuBgB,EACvBf,EAAkBiB,CACpB,CACA,MAAMY,EAAiBlG,EAAa3B,EAAKgG,GACnC8B,EAAmBlG,EAAe5B,EAAK+F,GAC7C,OAAO8B,GAAkBC,CAC3B,EACA,UAAMjG,CAAK7B,EAAK8B,EAAO/B,GACrB,MAAMgI,EAAU,IACXT,EAAYU,eACf7E,WAAYrB,EAAMC,MAAMoB,YAAcC,EAAmBpD,GACzDmE,UAAWrC,EAAMC,MAAMoC,iBAAmB8D,OACvCnG,EAAMC,MAELmG,EAAe1B,SAAS2B,cAAc,SACtCC,EAAe,CACnBC,SAA8B,IAArBN,EAAQO,SAAqB,YAAS,EAC/C,sBAA8C,IAAxBP,EAAQQ,YAAwB,QAAK,EAC3DA,aAAqC,IAAxBR,EAAQQ,YAAwB,QAAK,EAClDC,OAAyB,IAAlBT,EAAQS,MAAiB,QAAK,EACrCC,MAAuB,IAAjBV,EAAQU,KAAgB,QAAK,EACnCC,UAA+B,IAArBX,EAAQY,SAAqB,QAAK,GAE9CC,OAAOC,KAAKT,GAAcU,QAASC,IACjC,MAAMC,EAAQZ,EAAaW,QACb,IAAVC,GACFd,EAAae,aAAaF,EAAKC,MAEb,IAAlBjB,EAAQS,QACVN,EAAaM,OAAQ,GAEvBhH,EAAY0G,EAAclI,EAAK+H,EAAQ7B,aACvC,MAAMgD,EAAgB1C,SAAS2B,cAAc,UAC7C,IAAIgB,EACJ,GAAIpB,EAAQoB,KACVA,EAAOpB,EAAQoB,UACjB,GAAWnJ,EAAImG,WAAW,SACxBgD,EAAOnJ,EAAIoJ,MAAM,EAAGpJ,EAAIqJ,QAAQ,WAClC,IAAYrJ,EAAImG,WAAW,SAAU,CACnC,MAAMiB,EAAMpH,EAAIsJ,MAAM,KAAK,GAAGF,MAAMpJ,EAAIuJ,YAAY,KAAO,GAAGC,cAC9DL,EAAO7B,EAAYC,WAAWH,IAAQ,SAASA,GACjD,CAKA,OAJA8B,EAAcpG,IAAM9C,EAChBmJ,IACFD,EAAcnI,KAAOoI,GAEhB,IAAI3D,QAASC,IAClB,MAAMgE,EAAYxH,UAChB,MAAMyH,EAAO,IAAIpC,EAAY,IAAKS,EAAS7D,SAAUgE,IA1G7D,IAAsBjC,EA2GdiC,EAAayB,oBAAoB,UAAWF,GACxC3H,EAAMC,KAAKsG,eA5GDpC,EA6GOiC,EA5GpB,IAAI1C,QAAQ,CAACC,EAASC,KAI3B,SAASkE,IACPC,IACApE,GACF,CACA,SAASqE,EAAMC,GACbF,IACAnE,EAAOqE,EACT,CACA,SAASF,IACP5D,EAAQ0D,oBAAoB,iBAAkBC,GAC9C3D,EAAQ0D,oBAAoB,QAASG,EACvC,CAdA7D,EAAQ+D,iBAAiB,iBAAkBJ,GAC3C3D,EAAQ+D,iBAAiB,QAASF,GAClC7D,EAAQpE,UA2GJ4D,EAAQ5F,EAAc6J,EAAM3J,EAAQC,KAElC+H,EAAQM,UAAYN,EAAQY,UAC9BT,EAAarG,OAEfqG,EAAa8B,iBAAiB,UAAWP,GACzCvB,EAAa+B,YAAYf,IAE7B,EACA,MAAA7I,CAAOF,GACLA,EAAQkE,SAAQ,EAClB,GC7II6F,EAAa,CACjB7I,KAAM,cACN8I,OAAQ,CACNC,OAEE,sLASFC,KAEE,qFAKJC,SAAU,CACRF,OAEE,6IAOFC,KAEE,+EAMAE,EAAe,CACnBlJ,KAAM,cACN8I,OAAQ,CACNC,OAEE,uDAIFC,KAEE,qEAKJC,SAAU,CACRF,OAEE,sDAMFC,KAEE","x_google_ignoreList":[0,1,2,3,4]}