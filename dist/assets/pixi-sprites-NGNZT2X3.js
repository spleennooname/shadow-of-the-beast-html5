import{o as t,O as e,aa as i,d as r,R as s,ab as n,E as o,ac as a,ad as h,ae as u,e as l,T as c,af as d,v as p,ag as _,Q as m,ah as g,ai as x,y as f,aj as y,G as b,p as T,t as w,x as S,M as v,ak as U}from"./pixi-core-Cm8ucNvR.js";import{e as P,t as C,S as A,U as M,f as F,h as B,R as k}from"./pixi-renderer-DLoYYMz9.js";import{c as z}from"./pixi-graphics-q8yFmetg.js";class H extends t{constructor(t=P.EMPTY){t instanceof P&&(t={texture:t});const{texture:i=P.EMPTY,anchor:r,roundPixels:s,width:n,height:o,...a}=t;super({label:"Sprite",...a}),this.renderPipeId="sprite",this.batched=!0,this._visualBounds={minX:0,maxX:1,minY:0,maxY:0},this._anchor=new e({_onUpdate:()=>{this.onViewUpdate()}}),r?this.anchor=r:i.defaultAnchor&&(this.anchor=i.defaultAnchor),this.texture=i,this.allowChildren=!1,this.roundPixels=s??!1,void 0!==n&&(this.width=n),void 0!==o&&(this.height=o)}static from(t,e=!1){return new H(t instanceof P?t:P.from(t,e))}set texture(t){t||(t=P.EMPTY);const e=this._texture;e!==t&&(e&&e.dynamic&&e.off("update",this.onViewUpdate,this),t.dynamic&&t.on("update",this.onViewUpdate,this),this._texture=t,this._width&&this._setWidth(this._width,this._texture.orig.width),this._height&&this._setHeight(this._height,this._texture.orig.height),this.onViewUpdate())}get texture(){return this._texture}get visualBounds(){return i(this._visualBounds,this._anchor,this._texture),this._visualBounds}get sourceBounds(){return r("8.6.1","Sprite.sourceBounds is deprecated, use visualBounds instead."),this.visualBounds}updateBounds(){const t=this._anchor,e=this._texture,i=this._bounds,{width:r,height:s}=e.orig;i.minX=-t._x*r,i.maxX=i.minX+r,i.minY=-t._y*s,i.maxY=i.minY+s}destroy(t=!1){super.destroy(t);if("boolean"==typeof t?t:t?.texture){const e="boolean"==typeof t?t:t?.textureSource;this._texture.destroy(e)}this._texture=null,this._visualBounds=null,this._bounds=null,this._anchor=null,this._gpuData=null}get anchor(){return this._anchor}set anchor(t){"number"==typeof t?this._anchor.set(t):this._anchor.copyFrom(t)}get width(){return Math.abs(this.scale.x)*this._texture.orig.width}set width(t){this._setWidth(t,this._texture.orig.width),this._width=t}get height(){return Math.abs(this.scale.y)*this._texture.orig.height}set height(t){this._setHeight(t,this._texture.orig.height),this._height=t}getSize(t){return t||(t={}),t.width=Math.abs(this.scale.x)*this._texture.orig.width,t.height=Math.abs(this.scale.y)*this._texture.orig.height,t}setSize(t,e){"object"==typeof t?(e=t.height??t.width,t=t.width):e??(e=t),void 0!==t&&this._setWidth(t,this._texture.orig.width),void 0!==e&&this._setHeight(e,this._texture.orig.height)}}const W=class t{constructor(t,e){this.linkedSheets=[];let i=t;t?.source instanceof C&&(i={texture:t,data:e});const{texture:r,data:s,cachePrefix:n=""}=i;this.cachePrefix=n,this._texture=r instanceof P?r:null,this.textureSource=r.source,this.textures={},this.animations={},this.data=s;const o=parseFloat(s.meta.scale);o?(this.resolution=o,r.source.resolution=this.resolution):this.resolution=r.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(e=>{this._callback=e,this._batchIndex=0,this._frameKeys.length<=t.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(e){let i=e;const r=t.BATCH_SIZE;for(;i-e<r&&i<this._frameKeys.length;){const t=this._frameKeys[i],e=this._frames[t],r=e.frame;if(r){let i=null,n=null;const o=!1!==e.trimmed&&e.sourceSize?e.sourceSize:e.frame,a=new s(0,0,Math.floor(o.w)/this.resolution,Math.floor(o.h)/this.resolution);i=e.rotated?new s(Math.floor(r.x)/this.resolution,Math.floor(r.y)/this.resolution,Math.floor(r.h)/this.resolution,Math.floor(r.w)/this.resolution):new s(Math.floor(r.x)/this.resolution,Math.floor(r.y)/this.resolution,Math.floor(r.w)/this.resolution,Math.floor(r.h)/this.resolution),!1!==e.trimmed&&e.spriteSourceSize&&(n=new s(Math.floor(e.spriteSourceSize.x)/this.resolution,Math.floor(e.spriteSourceSize.y)/this.resolution,Math.floor(r.w)/this.resolution,Math.floor(r.h)/this.resolution)),this.textures[t]=new P({source:this.textureSource,frame:i,orig:a,trim:n,rotate:e.rotated?2:0,defaultAnchor:e.anchor,defaultBorders:e.borders,label:t.toString()})}i++}}_processAnimations(){const t=this.data.animations||{};for(const e in t){this.animations[e]=[];for(let i=0;i<t[e].length;i++){const r=t[e][i];this.animations[e].push(this.textures[r])}}}_parseComplete(){const t=this._callback;this._callback=null,this._batchIndex=0,t.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*t.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*t.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(t=!1){for(const e in this.textures)this.textures[e].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,t&&(this._texture?.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};W.BATCH_SIZE=1e3;let R=W;const V=["jpg","png","jpeg","avif","webp","basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"];function E(t,e,i){const r={};if(t.forEach(t=>{r[t]=e}),Object.keys(e.textures).forEach(t=>{r[`${e.cachePrefix}${t}`]=e.textures[t]}),!i){const i=a.dirname(t[0]);e.linkedSheets.forEach((t,s)=>{const n=E([`${i}/${e.data.meta.related_multi_packs[s]}`],t,!0);Object.assign(r,n)})}return r}const G={extension:o.Asset,cache:{test:t=>t instanceof R,getCacheableAssets:(t,e)=>E(t,e,!1)},resolver:{extension:{type:o.ResolveParser,name:"resolveSpritesheet"},test:t=>{const e=t.split("?")[0].split("."),i=e.pop(),r=e.pop();return"json"===i&&V.includes(r)},parse:t=>{const e=t.split(".");return{resolution:parseFloat(u.RETINA_PREFIX.exec(t)?.[1]??"1"),format:e[e.length-2],src:t}}},loader:{name:"spritesheetLoader",id:"spritesheet",extension:{type:o.LoadParser,priority:n.Normal,name:"spritesheetLoader"},testParse:async(t,e)=>".json"===a.extname(e.src).toLowerCase()&&!!t.frames,async parse(t,e,i){const{texture:r,imageFilename:s,textureOptions:n,cachePrefix:o}=e?.data??{};let u,l=a.dirname(e.src);if(l&&l.lastIndexOf("/")!==l.length-1&&(l+="/"),r instanceof P)u=r;else{const r=h(l+(s??t.meta.image),e.src);u=(await i.load([{src:r,data:n}]))[r]}const c=new R({texture:u.source,data:t,cachePrefix:o});await c.parse();const d=t?.meta?.related_multi_packs;if(Array.isArray(d)){const t=[];for(const s of d){if("string"!=typeof s)continue;let r=l+s;e.data?.ignoreMultiPack||(r=h(r,e.src),t.push(i.load({src:r,data:{textureOptions:n,ignoreMultiPack:!0}})))}const r=await Promise.all(t);c.linkedSheets=r,r.forEach(t=>{t.linkedSheets=[c].concat(c.linkedSheets.filter(e=>e!==t))})}return c},async unload(t,e,i){await i.unload(t.textureSource._sourceOrigin),t.destroy(!1)}}};l.add(G);class O extends H{constructor(...t){let e=t[0];Array.isArray(t[0])&&(e={textures:t[0],autoUpdate:t[1]});const{animationSpeed:i=1,autoPlay:r=!1,autoUpdate:s=!0,loop:n=!0,onComplete:o=null,onFrameChange:a=null,onLoop:h=null,textures:u,updateAnchor:l=!1,...c}=e,[d]=u;super({...c,texture:d instanceof P?d:d.texture}),this._textures=null,this._durations=null,this._autoUpdate=s,this._isConnectedToTicker=!1,this.animationSpeed=i,this.loop=n,this.updateAnchor=l,this.onComplete=o,this.onFrameChange=a,this.onLoop=h,this._currentTime=0,this._playing=!1,this._previousFrame=null,this.textures=u,r&&this.play()}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(c.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(c.shared.add(this.update,this,d.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(t){this.stop(),this.currentFrame=t}gotoAndPlay(t){this.currentFrame=t,this.play()}update(t){if(!this._playing)return;const e=t.deltaTime,i=this.animationSpeed*e,r=this.currentFrame;if(null!==this._durations){let t=this._currentTime%1*this._durations[this.currentFrame];for(t+=i/60*1e3;t<0;)this._currentTime--,t+=this._durations[this.currentFrame];const r=Math.sign(this.animationSpeed*e);for(this._currentTime=Math.floor(this._currentTime);t>=this._durations[this.currentFrame];)t-=this._durations[this.currentFrame]*r,this._currentTime+=r;this._currentTime+=t/this._durations[this.currentFrame]}else this._currentTime+=i;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):r!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<r||this.animationSpeed<0&&this.currentFrame>r)&&this.onLoop(),this._updateTexture())}_updateTexture(){const t=this.currentFrame;this._previousFrame!==t&&(this._previousFrame=t,this.texture=this._textures[t],this.updateAnchor&&this.texture.defaultAnchor&&this.anchor.copyFrom(this.texture.defaultAnchor),this.onFrameChange&&this.onFrameChange(this.currentFrame))}destroy(t=!1){if("boolean"==typeof t?t:t?.texture){const e="boolean"==typeof t?t:t?.textureSource;this._textures.forEach(t=>{this.texture!==t&&t.destroy(e)})}this._textures=[],this._durations=null,this.stop(),super.destroy(t),this.onComplete=null,this.onFrameChange=null,this.onLoop=null}static fromFrames(t){const e=[];for(let i=0;i<t.length;++i)e.push(P.from(t[i]));return new O(e)}static fromImages(t){const e=[];for(let i=0;i<t.length;++i)e.push(P.from(t[i]));return new O(e)}get totalFrames(){return this._textures.length}get textures(){return this._textures}set textures(t){if(t[0]instanceof P)this._textures=t,this._durations=null;else{this._textures=[],this._durations=[];for(let e=0;e<t.length;e++)this._textures.push(t[e].texture),this._durations.push(t[e].time)}this._previousFrame=null,this.gotoAndStop(0),this._updateTexture()}get currentFrame(){let t=Math.floor(this._currentTime)%this._textures.length;return t<0&&(t+=this._textures.length),t}set currentFrame(t){if(t<0||t>this.totalFrames-1)throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);const e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this._updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(c.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(c.shared.add(this.update,this),this._isConnectedToTicker=!0))}}const I=class i extends t{constructor(...t){let s=t[0]||{};s instanceof P&&(s={texture:s}),t.length>1&&(r(p,"use new TilingSprite({ texture, width:100, height:100 }) instead"),s.width=t[1],s.height=t[2]),s={...i.defaultOptions,...s};const{texture:n,anchor:o,tilePosition:a,tileScale:h,tileRotation:u,width:l,height:c,applyAnchorToTexture:d,roundPixels:m,...g}=s??{};super({label:"TilingSprite",...g}),this.renderPipeId="tilingSprite",this.batched=!0,this.allowChildren=!1,this._anchor=new e({_onUpdate:()=>{this.onViewUpdate()}}),this.applyAnchorToTexture=d,this.texture=n,this._width=l??n.width,this._height=c??n.height,this._tileTransform=new _({observer:{_onUpdate:()=>this.onViewUpdate()}}),o&&(this.anchor=o),this.tilePosition=a,this.tileScale=h,this.tileRotation=u,this.roundPixels=m??!1}static from(t,e={}){return new i("string"==typeof t?{texture:m.get(t),...e}:{texture:t,...e})}get uvRespectAnchor(){return r(p,"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),this.applyAnchorToTexture}set uvRespectAnchor(t){r(p,"uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),this.applyAnchorToTexture=t}get clampMargin(){return this._texture.textureMatrix.clampMargin}set clampMargin(t){this._texture.textureMatrix.clampMargin=t}get anchor(){return this._anchor}set anchor(t){"number"==typeof t?this._anchor.set(t):this._anchor.copyFrom(t)}get tilePosition(){return this._tileTransform.position}set tilePosition(t){this._tileTransform.position.copyFrom(t)}get tileScale(){return this._tileTransform.scale}set tileScale(t){"number"==typeof t?this._tileTransform.scale.set(t):this._tileTransform.scale.copyFrom(t)}set tileRotation(t){this._tileTransform.rotation=t}get tileRotation(){return this._tileTransform.rotation}get tileTransform(){return this._tileTransform}set texture(t){t||(t=P.EMPTY);const e=this._texture;e!==t&&(e&&e.dynamic&&e.off("update",this.onViewUpdate,this),t.dynamic&&t.on("update",this.onViewUpdate,this),this._texture=t,this.onViewUpdate())}get texture(){return this._texture}set width(t){this._width=t,this.onViewUpdate()}get width(){return this._width}set height(t){this._height=t,this.onViewUpdate()}get height(){return this._height}setSize(t,e){"object"==typeof t&&(e=t.height??t.width,t=t.width),this._width=t,this._height=e??t,this.onViewUpdate()}getSize(t){return t||(t={}),t.width=this._width,t.height=this._height,t}updateBounds(){const t=this._bounds,e=this._anchor,i=this._width,r=this._height;t.minX=-e._x*i,t.maxX=t.minX+i,t.minY=-e._y*r,t.maxY=t.minY+r}containsPoint(t){const e=this._width,i=this._height,r=-e*this._anchor._x;let s=0;return t.x>=r&&t.x<=r+e&&(s=-i*this._anchor._y,t.y>=s&&t.y<=s+i)}destroy(t=!1){super.destroy(t),this._anchor=null,this._tileTransform=null,this._bounds=null;if("boolean"==typeof t?t:t?.texture){const e="boolean"==typeof t?t:t?.textureSource;this._texture.destroy(e)}this._texture=null}};I.defaultOptions={texture:P.EMPTY,anchor:{x:0,y:0},tilePosition:{x:0,y:0},tileScale:{x:1,y:1},tileRotation:0,applyAnchorToTexture:!1};let Y=I;class D{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}destroy(){}}class j{constructor(t){this._renderer=t}addRenderable(t,e){const i=this._getGpuSprite(t);t.didViewUpdate&&this._updateBatchableSprite(t,i),this._renderer.renderPipes.batch.addToBatch(i,e)}updateRenderable(t){const e=this._getGpuSprite(t);t.didViewUpdate&&this._updateBatchableSprite(t,e),e._batcher.updateElement(e)}validateRenderable(t){const e=this._getGpuSprite(t);return!e._batcher.checkAndUpdateTexture(e,t._texture)}_updateBatchableSprite(t,e){e.bounds=t.visualBounds,e.texture=t._texture}_getGpuSprite(t){return t._gpuData[this._renderer.uid]||this._initGPUSprite(t)}_initGPUSprite(t){const e=new D;return e.renderable=t,e.transform=t.groupTransform,e.texture=t._texture,e.bounds=t.visualBounds,e.roundPixels=this._renderer._roundPixels|t._roundPixels,t._gpuData[this._renderer.uid]=e,e}destroy(){this._renderer=null}}j.extension={type:[o.WebGLPipes,o.WebGPUPipes,o.CanvasPipes],name:"sprite"};const L=class t extends g{constructor(e={}){super({width:(e={...t.defaultOptions,...e}).width,height:e.height,verticesX:4,verticesY:4}),this.update(e)}update(t){this.width=t.width??this.width,this.height=t.height??this.height,this._originalWidth=t.originalWidth??this._originalWidth,this._originalHeight=t.originalHeight??this._originalHeight,this._leftWidth=t.leftWidth??this._leftWidth,this._rightWidth=t.rightWidth??this._rightWidth,this._topHeight=t.topHeight??this._topHeight,this._bottomHeight=t.bottomHeight??this._bottomHeight,this._anchorX=t.anchor?.x,this._anchorY=t.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){const t=this.positions,{width:e,height:i,_leftWidth:r,_rightWidth:s,_topHeight:n,_bottomHeight:o,_anchorX:a,_anchorY:h}=this,u=r+s,l=e>u?1:e/u,c=n+o,d=i>c?1:i/c,p=Math.min(l,d),_=a*e,m=h*i;t[0]=t[8]=t[16]=t[24]=-_,t[2]=t[10]=t[18]=t[26]=r*p-_,t[4]=t[12]=t[20]=t[28]=e-s*p-_,t[6]=t[14]=t[22]=t[30]=e-_,t[1]=t[3]=t[5]=t[7]=-m,t[9]=t[11]=t[13]=t[15]=n*p-m,t[17]=t[19]=t[21]=t[23]=i-o*p-m,t[25]=t[27]=t[29]=t[31]=i-m,this.getBuffer("aPosition").update()}updateUvs(){const t=this.uvs;t[0]=t[8]=t[16]=t[24]=0,t[1]=t[3]=t[5]=t[7]=0,t[6]=t[14]=t[22]=t[30]=1,t[25]=t[27]=t[29]=t[31]=1;const e=1/this._originalWidth,i=1/this._originalHeight;t[2]=t[10]=t[18]=t[26]=e*this._leftWidth,t[9]=t[11]=t[13]=t[15]=i*this._topHeight,t[4]=t[12]=t[20]=t[28]=1-e*this._rightWidth,t[17]=t[19]=t[21]=t[23]=1-i*this._bottomHeight,this.getBuffer("aUV").update()}};L.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let X=L;class K extends x{constructor(){super(),this.geometry=new X}destroy(){this.geometry.destroy()}}class ${constructor(t){this._renderer=t}addRenderable(t,e){const i=this._getGpuSprite(t);t.didViewUpdate&&this._updateBatchableSprite(t,i),this._renderer.renderPipes.batch.addToBatch(i,e)}updateRenderable(t){const e=this._getGpuSprite(t);t.didViewUpdate&&this._updateBatchableSprite(t,e),e._batcher.updateElement(e)}validateRenderable(t){const e=this._getGpuSprite(t);return!e._batcher.checkAndUpdateTexture(e,t._texture)}_updateBatchableSprite(t,e){e.geometry.update(t),e.setTexture(t._texture)}_getGpuSprite(t){return t._gpuData[this._renderer.uid]||this._initGPUSprite(t)}_initGPUSprite(t){const e=t._gpuData[this._renderer.uid]=new K,i=e;return i.renderable=t,i.transform=t.groupTransform,i.texture=t._texture,i.roundPixels=this._renderer._roundPixels|t._roundPixels,t.didViewUpdate||this._updateBatchableSprite(t,i),e}destroy(){this._renderer=null}}$.extension={type:[o.WebGLPipes,o.WebGPUPipes,o.CanvasPipes],name:"nineSliceSprite"};const Z={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},N={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        "}};let Q,q;class J extends A{constructor(){Q??(Q=f({name:"tiling-sprite-shader",bits:[y,Z,b]})),q??(q=T({name:"tiling-sprite-shader",bits:[w,N,S]}));const t=new M({uMapCoord:{value:new v,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new v,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:q,gpuProgram:Q,resources:{localUniforms:new M({uTransformMatrix:{value:new v,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:t,uTexture:P.EMPTY.source,uSampler:P.EMPTY.source.style}})}updateUniforms(t,e,i,r,s,n){const o=this.resources.tilingUniforms,a=n.width,h=n.height,u=n.textureMatrix,l=o.uniforms.uTextureTransform;l.set(i.a*a/t,i.b*a/e,i.c*h/t,i.d*h/e,i.tx/t,i.ty/e),l.invert(),o.uniforms.uMapCoord=u.mapCoord,o.uniforms.uClampFrame=u.uClampFrame,o.uniforms.uClampOffset=u.uClampOffset,o.uniforms.uTextureTransform=l,o.uniforms.uSizeAnchor[0]=t,o.uniforms.uSizeAnchor[1]=e,o.uniforms.uSizeAnchor[2]=r,o.uniforms.uSizeAnchor[3]=s,n&&(this.resources.uTexture=n.source,this.resources.uSampler=n.source.style)}}const tt=new class extends U{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}};class et{constructor(){this.canBatch=!0,this.geometry=new U({indices:tt.indices.slice(),positions:tt.positions.slice(),uvs:tt.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class it{constructor(t){this._state=F.default2d,this._renderer=t}validateRenderable(t){const e=this._getTilingSpriteData(t),i=e.canBatch;this._updateCanBatch(t);const r=e.canBatch;if(r&&r===i){const{batchableMesh:i}=e;return!i._batcher.checkAndUpdateTexture(i,t.texture)}return i!==r}addRenderable(t,e){const i=this._renderer.renderPipes.batch;this._updateCanBatch(t);const r=this._getTilingSpriteData(t),{geometry:s,canBatch:n}=r;if(n){r.batchableMesh||(r.batchableMesh=new x);const n=r.batchableMesh;t.didViewUpdate&&(this._updateBatchableMesh(t),n.geometry=s,n.renderable=t,n.transform=t.groupTransform,n.setTexture(t._texture)),n.roundPixels=this._renderer._roundPixels|t._roundPixels,i.addToBatch(n,e)}else i.break(e),r.shader||(r.shader=new J),this.updateRenderable(t),e.add(t)}execute(t){const{shader:e}=this._getTilingSpriteData(t);e.groups[0]=this._renderer.globalUniforms.bindGroup;const i=e.resources.localUniforms.uniforms;i.uTransformMatrix=t.groupTransform,i.uRound=this._renderer._roundPixels|t._roundPixels,z(t.groupColorAlpha,i.uColor,0),this._state.blendMode=B(t.groupBlendMode,t.texture._source),this._renderer.encoder.draw({geometry:tt,shader:e,state:this._state})}updateRenderable(t){const e=this._getTilingSpriteData(t),{canBatch:i}=e;if(i){const{batchableMesh:i}=e;t.didViewUpdate&&this._updateBatchableMesh(t),i._batcher.updateElement(i)}else if(t.didViewUpdate){const{shader:i}=e;i.updateUniforms(t.width,t.height,t._tileTransform.matrix,t.anchor.x,t.anchor.y,t.texture)}}_getTilingSpriteData(t){return t._gpuData[this._renderer.uid]||this._initTilingSpriteData(t)}_initTilingSpriteData(t){const e=new et;return e.renderable=t,t._gpuData[this._renderer.uid]=e,e}_updateBatchableMesh(t){const e=this._getTilingSpriteData(t),{geometry:i}=e,r=t.texture.source.style;"repeat"!==r.addressMode&&(r.addressMode="repeat",r.update()),function(t,e){const i=t.texture,r=i.frame.width,s=i.frame.height;let n=0,o=0;t.applyAnchorToTexture&&(n=t.anchor.x,o=t.anchor.y),e[0]=e[6]=-n,e[2]=e[4]=1-n,e[1]=e[3]=-o,e[5]=e[7]=1-o;const a=v.shared;a.copyFrom(t._tileTransform.matrix),a.tx/=t.width,a.ty/=t.height,a.invert(),a.scale(t.width/r,t.height/s),function(t,e,i,r){let s=0;const n=t.length/e,o=r.a,a=r.b,h=r.c,u=r.d,l=r.tx,c=r.ty;for(i*=e;s<n;){const r=t[i],n=t[i+1];t[i]=o*r+h*n+l,t[i+1]=a*r+u*n+c,i+=e,s++}}(e,2,0,a)}(t,i.uvs),function(t,e){const i=t.anchor.x,r=t.anchor.y;e[0]=-i*t.width,e[1]=-r*t.height,e[2]=(1-i)*t.width,e[3]=-r*t.height,e[4]=(1-i)*t.width,e[5]=(1-r)*t.height,e[6]=-i*t.width,e[7]=(1-r)*t.height}(t,i.positions)}destroy(){this._renderer=null}_updateCanBatch(t){const e=this._getTilingSpriteData(t),i=t.texture;let r=!0;return this._renderer.type===k.WEBGL&&(r=this._renderer.context.supports.nonPowOf2wrapping),e.canBatch=i.textureMatrix.isSimple&&(r||i.source.isPowerOfTwo),e.canBatch}}it.extension={type:[o.WebGLPipes,o.WebGPUPipes,o.CanvasPipes],name:"tilingSprite"},l.add(it),l.add($);export{O as A,D as B,H as S,Y as T,j as a};
//# sourceMappingURL=pixi-sprites-NGNZT2X3.js.map
