{"version":3,"file":"WebGPURenderer-DJUExRKR.js","sources":["../../node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","../../node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","../../node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = shader.gpuProgram;\n    this._shader = shader;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(\n        textureBatch.textures,\n        textureBatch.count,\n        renderer.limits.maxBatchableTextures\n      );\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState,\n      batch.topology\n    );\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GpuBatchAdaptor };\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_hash\");\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView({});\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    for (const key of Object.keys(this._hash)) {\n      this._hash[key] = null;\n    }\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexport { BindGroupSystem };\n//# sourceMappingURL=BindGroupSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\n\"use strict\";\nclass GpuBufferSystem {\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._managedBuffers = [];\n    renderer.renderableGC.addManagedHash(this, \"_gpuBuffers\");\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n      buffer.on(\"destroy\", this.onBufferDestroy, this);\n      this._managedBuffers.push(buffer);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n    buffer.off(\"destroy\", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GpuBufferSystem };\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n","\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this.data = null;\n  }\n}\n\nexport { UboBatch };\n//# sourceMappingURL=UboBatch.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GpuColorMaskSystem };\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexport { GpuDeviceSystem };\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount ?? geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexport { GpuEncoderSystem };\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuLimitsSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  contextChange() {\n    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n    this.maxBatchableTextures = this.maxTextures;\n  }\n  destroy() {\n  }\n}\n/** @ignore */\nGpuLimitsSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"limits\"\n};\n\nexport { GpuLimitsSystem };\n//# sourceMappingURL=GpuLimitsSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GpuStencilSystem };\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n","\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL };\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL.mjs';\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  const data = uboElement.data.type.indexOf(\"i32\") >= 0 ? \"dataInt32\" : \"data\";\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexport { generateArraySyncWGSL };\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL,\n    uboSyncFunctionsWGSL\n  );\n}\n\nexport { createUboSyncFunctionWGSL };\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL.mjs';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL.mjs';\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexport { GpuUboSystem };\n//# sourceMappingURL=GpuUboSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_bindGroupHash\");\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0)\n        usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i]?.destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexport { GpuUniformBatchPipe };\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology || (topology = geometry.topology);\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join(\"|\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join(\"|\");\n    program._attributeLocationsKey = createIdFromString(stringKey, \"programAttributes\");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key])\n      return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      const attributes = Object.values(data[i].attributes);\n      const shaderLocation = attributes[0].shaderLocation;\n      for (const j in attributeData) {\n        if (attributeData[j].location === shaderLocation) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey)\n      this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexport { PipelineSystem };\n//# sourceMappingURL=PipelineSystem.mjs.map\n","\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexport { GpuRenderTarget };\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n","import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (colorTexture instanceof CanvasSource) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexport { GpuRenderTargetAdaptor };\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexport { GpuRenderTargetSystem };\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GpuShaderSystem };\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n","\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  }\n};\n\nexport { GpuBlendModesToPixi };\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi.mjs';\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */\n  getColorTargets(state) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    return [\n      {\n        format: \"bgra8unorm\",\n        writeMask: 0,\n        blend\n      }\n    ];\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexport { GpuStateSystem };\n//# sourceMappingURL=GpuStateSystem.mjs.map\n","\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelHeight * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexport { gpuUploadBufferImageResource };\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n","\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { blockDataMap, gpuUploadCompressedTextureResource };\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {\n      const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(resource, 0, 0, resource.width, resource.height);\n      source.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas and replacing resource.\");\n    }\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexport { gpuUploadImageResource };\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n","import { gpuUploadImageResource } from './gpuUploadImageSource.mjs';\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\nexport { gpuUploadVideoResource };\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n","\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexport { GpuMipmapGenerator };\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\n\"use strict\";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */ Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._textureViewHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuSources\");\n    renderer.renderableGC.addManagedHash(this, \"_gpuSamplers\");\n    renderer.renderableGC.addManagedHash(this, \"_bindGroupHash\");\n    renderer.renderableGC.addManagedHash(this, \"_textureViewHash\");\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  /**\n   * Initializes a texture source, if it has already been initialized nothing will happen.\n   * @param source - The texture source to initialize.\n   * @returns The initialized texture source.\n   */\n  initSource(source) {\n    if (this._gpuSources[source.uid]) {\n      return this._gpuSources[source.uid];\n    }\n    return this._initSource(source);\n  }\n  _initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpuSources[source.uid] = this._gpu.device.createTexture(textureDescriptor);\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup({\n      0: source,\n      1: source.style,\n      2: new UniformGroup({\n        uTextureMatrix: { type: \"mat3x3<f32>\", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GpuTextureSystem };\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  constructor() {\n    this._maxTextures = 0;\n  }\n  contextChange(renderer) {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this._maxTextures = renderer.limits.maxBatchableTextures;\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(this._maxTextures),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(\n          batcher.geometry,\n          shader.gpuProgram,\n          graphicsPipe.state,\n          batch.topology\n        );\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(\n          textureBatch.textures,\n          textureBatch.count,\n          this._maxTextures\n        );\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit,\n        textureBit,\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.EMPTY._source,\n        uSampler: Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GpuMeshAdapter };\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter.mjs';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { BindGroupSystem } from './BindGroupSystem.mjs';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem.mjs';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem.mjs';\nimport { GpuDeviceSystem } from './GpuDeviceSystem.mjs';\nimport { GpuEncoderSystem } from './GpuEncoderSystem.mjs';\nimport { GpuLimitsSystem } from './GpuLimitsSystem.mjs';\nimport { GpuStencilSystem } from './GpuStencilSystem.mjs';\nimport { GpuUboSystem } from './GpuUboSystem.mjs';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe.mjs';\nimport { PipelineSystem } from './pipeline/PipelineSystem.mjs';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem.mjs';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem.mjs';\nimport { GpuStateSystem } from './state/GpuStateSystem.mjs';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuLimitsSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGPURenderer };\n//# sourceMappingURL=WebGPURenderer.mjs.map\n"],"names":["tempState","State","for2d","GpuBatchAdaptor","start","batchPipe","geometry","shader","renderer","encoder","program","gpuProgram","this","_shader","_geometry","setGeometry","blendMode","pipeline","getPipeline","globalUniformsBindGroup","globalUniforms","bindGroup","resetBindGroup","setBindGroup","execute","batch","textureBatch","textures","getTextureBatchBindGroup","count","limits","maxBatchableTextures","gpuBindGroup","getBindGroup","topology","_touch","textureGC","setPipeline","renderPassEncoder","drawIndexed","size","extension","type","ExtensionType","WebGPUPipesAdaptor","name","BindGroupSystem","constructor","_hash","Object","create","_renderer","renderableGC","addManagedHash","contextChange","gpu","_gpu","groupIndex","_updateKey","_key","_createBindGroup","group","device","groupLayout","layout","entries","j","resource","resources","gpuResource","_resourceType","uniformGroup","ubo","updateUniformGroup","buffer","getGPUBuffer","offset","descriptor","bufferResource","sampler","texture","getGpuSampler","getGpuSource","createView","push","binding","getProgramData","bindGroups","createBindGroup","destroy","key","keys","WebGPUSystem","GpuBufferSystem","_gpuBuffers","_managedBuffers","uid","createGPUBuffer","updateBuffer","gpuBuffer","data","_updateID","queue","writeBuffer","_updateSize","byteLength","destroyAll","id","on","onBufferChange","onBufferDestroy","createBuffer","fastCopy","getMappedRange","unmap","splice","indexOf","_destroyBuffer","forEach","off","UboBatch","minUniformOffsetAlignment","_minUniformOffsetAlignment","byteIndex","Float32Array","clear","addEmptyGroup","Error","newSize","Math","ceil","length","addGroup","array","i","GpuColorMaskSystem","_colorMaskCache","setMask","colorMask","setColorMask","GpuDeviceSystem","init","options","_initPromise","Promise","resolve","_createDeviceAndAdaptor","then","runners","emit","adapter","DOMAdapter","get","getNavigator","requestAdapter","powerPreference","forceFallbackAdapter","requiredFeatures","filter","feature","features","has","requestDevice","defaultOptions","GpuEncoderSystem","_boundBindGroup","_boundVertexBuffer","renderStart","commandFinished","_resolveCommandFinished","commandEncoder","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","end","setViewport","viewport","x","y","width","height","setPipelineFromGeometryProgramAndState","state","_boundPipeline","_setVertexBuffer","index","setVertexBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","BYTES_PER_ELEMENT","setIndexBuffer","buffersToBind","getBufferNamesToBind","parseInt","attributes","indexBuffer","_setShaderBindGroups","skipSync","groups","_syncBindGroup","isUniformGroup","draw","instanceCount","getSize","finishRenderPass","postrender","submit","finish","restoreRenderPass","renderTarget","adaptor","getDescriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","priority","GpuLimitsSystem","maxTextures","maxSampledTexturesPerShaderStage","GpuStencilSystem","_renderTargetStencilState","onRenderTargetChange","add","stencilState","stencilMode","STENCIL_MODES","DISABLED","stencilReference","_activeRenderTarget","setStencilMode","setStencilReference","remove","WGSL_ALIGN_SIZE_DATA","i32","align","u32","f32","f16","createUboElementsWGSL","uniformData","uboElements","map","uboElement","max","generateArraySyncWGSL","offsetToAdd","remainder","createUboSyncFunctionWGSL","createUboSyncFunction","uboSyncFunctionsWGSL","GpuUboSystem","UboSystem","super","createUboElements","generateUboSync","GpuUniformBatchPipe","_bindGroupHash","_buffers","_bindGroups","_bufferResources","_batchBuffer","usage","BufferUsage","UNIFORM","COPY_DST","COPY_SRC","Buffer","renderEnd","_uploadBindGroups","_resetBindGroups","getUniformBindGroup","duplicate","ensureUniformGroup","syncUniformGroup","_getBindGroup","getUboResource","_getBufferResource","getArrayBindGroup","getArrayBufferResource","BufferResource","BindGroup","bufferSystem","firstBuffer","update","copyBufferToBuffer","WebGPUPipes","topologyStringToId","PipelineSystem","_moduleCache","_bufferLayoutsCache","_bindingNamesCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","depthStencilAttachment","_stencilMode","_stencilState","GpuStencilModesToPixi","passEncoder","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","geometryLayout","shaderKey","getGraphicsStateKey","_blendModeId","_createPipeline","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","vertex","module","_getModule","source","entryPoint","fragment","targets","primitive","cullMode","multisample","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","attributeKeys","sort","attribute","stride","instance","stringKey","join","createIdFromString","_generateAttributeLocationsKey","location","_attributeLocationsKey","bufferNamesToBind","shaderLocation","values","vertexBuffersLayout","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","divisor","warn","stencilStateId","multiSampleCount","GpuRenderTarget","contexts","msaaTextures","GpuRenderTargetAdaptor","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","copyTextureToTexture","origin","startRenderPass","clearColor","getGpuRenderTarget","getCurrentTexture","colorTextures","clearValue","CLEAR","ALL","NONE","colorAttachments","context","view","resolveTarget","mipLevelCount","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","renderPassDescriptor","gpuCommands","initGpuRenderTarget","isRoot","colorTexture","CanvasSource","getContext","alphaMode","transparent","configure","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","e","antialias","msaaTexture","TextureSource","destroyGpuRenderTarget","unconfigure","resizeGpuRenderTarget","resize","_resolution","GpuRenderTargetSystem","RenderTargetSystem","GpuShaderSystem","_gpuProgramData","_createGPUProgramData","gpuLayout","createBindGroupLayout","pipelineLayoutDesc","bindGroupLayouts","createPipelineLayout","GpuBlendModesToPixi","alpha","srcFactor","dstFactor","operation","color","GpuStateSystem","defaultState","blend","normal","gpuUploadBufferImageResource","upload","gpuTexture","total","pixelWidth","pixelHeight","bytesPerPixel","writeTexture","rowsPerImage","bytesPerRow","depthOrArrayLayers","blockDataMap","blockBytes","blockWidth","blockHeight","defaultBlockData","gpuUploadCompressedTextureResource","mipWidth","mipHeight","blockData","levelBuffer","mipLevel","gpuUploadImageResource","globalThis","HTMLImageElement","canvas","createCanvas","drawImage","min","resourceWidth","resourceHeight","premultipliedAlpha","copyExternalImageToTexture","gpuUploadVideoResource","GpuMipmapGenerator","createSampler","minFilter","pipelines","_getMipmapPipeline","mipmapShaderModule","generateMipmap","dimension","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","createTexture","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","baseMipLevel","baseArrayLayer","dstMipLevel","dstView","r","g","b","a","mipLevelSize","GpuTextureSystem","managedTextures","_gpuSources","_gpuSamplers","_textureViewHash","_uploads","image","video","compressed","initSource","_initSource","autoGenerateMipmaps","biggestDimension","floor","log2","uploadMethodId","textureDescriptor","includes","onSourceUpdate","onSourceResize","onSourceDestroy","onSourceUnload","onUpdateMipmaps","_mipmapGenerator","_initSampler","_resourceId","getTextureBindGroup","_createTextureBindGroup","style","UniformGroup","uTextureMatrix","value","textureMatrix","mapCoord","_createTextureView","generateCanvas","getPreferredCanvasFormat","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","imageData","getImageData","pixels","Uint8ClampedArray","returnCanvasAndContext","slice","k","Number","GpuGraphicsAdaptor","_maxTextures","localUniforms","uTransformMatrix","Matrix","uColor","uRound","compileHighShaderGpuProgram","bits","colorBit","generateTextureBatchBit","localUniformBitGroup2","roundPixelsBit","Shader","graphicsPipe","renderable","customShader","contextSystem","graphicsContext","batcher","instructions","getContextRenderData","localBindGroup","renderPipes","uniformBatch","batches","instructionSize","GpuMeshAdapter","localUniformBit","textureBit","uTexture","Texture","EMPTY","_source","uSampler","textureUniforms","meshPipe","mesh","autoAssignGlobalUniforms","autoAssignLocalUniforms","DefaultWebGPUSystems","SharedSystems","DefaultWebGPUPipes","SharedRenderPipes","DefaultWebGPUAdapters","systems","renderPipeAdaptors","extensions","handleByNamedList","WebGPURenderer","AbstractRenderer","RendererType","WEBGPU"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]}